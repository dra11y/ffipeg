// ignore_for_file: type=lint, doc_directive_unknown, unused_field, unused_element

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class FFmpeg {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FFmpeg(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FFmpeg.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Extract the number of samples and frames from AAC data.
  /// @param[in]  buf     pointer to AAC data buffer
  /// @param[out] samples Pointer to where number of samples is written
  /// @param[out] frames  Pointer to where number of frames is written
  /// @return Returns 0 on success, error code on failure.
  int av_adts_header_parse(
    ffi.Pointer<ffi.Uint8> buf,
    ffi.Pointer<ffi.Uint32> samples,
    ffi.Pointer<ffi.Uint8> frames,
  ) {
    return _av_adts_header_parse(
      buf,
      samples,
      frames,
    );
  }

  late final _av_adts_header_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint32>,
              ffi.Pointer<ffi.Uint8>)>>('av_adts_header_parse');
  late final _av_adts_header_parse = _av_adts_header_parsePtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint32>,
          ffi.Pointer<ffi.Uint8>)>();

  /// Return the name of sample_fmt, or NULL if sample_fmt is not
  /// recognized.
  ffi.Pointer<ffi.Char> av_get_sample_fmt_name(
    AVSampleFormat sample_fmt,
  ) {
    return _av_get_sample_fmt_name(
      sample_fmt.value,
    );
  }

  late final _av_get_sample_fmt_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'av_get_sample_fmt_name');
  late final _av_get_sample_fmt_name = _av_get_sample_fmt_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
  /// on error.
  AVSampleFormat av_get_sample_fmt(
    ffi.Pointer<ffi.Char> name,
  ) {
    return AVSampleFormat.fromValue(_av_get_sample_fmt(
      name,
    ));
  }

  late final _av_get_sample_fmtPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_get_sample_fmt');
  late final _av_get_sample_fmt =
      _av_get_sample_fmtPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Return the planar<->packed alternative form of the given sample format, or
  /// AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
  /// requested planar/packed format, the format returned is the same as the
  /// input.
  AVSampleFormat av_get_alt_sample_fmt(
    AVSampleFormat sample_fmt,
    int planar,
  ) {
    return AVSampleFormat.fromValue(_av_get_alt_sample_fmt(
      sample_fmt.value,
      planar,
    ));
  }

  late final _av_get_alt_sample_fmtPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'av_get_alt_sample_fmt');
  late final _av_get_alt_sample_fmt =
      _av_get_alt_sample_fmtPtr.asFunction<int Function(int, int)>();

  /// Get the packed alternative form of the given sample format.
  ///
  /// If the passed sample_fmt is already in packed format, the format returned is
  /// the same as the input.
  ///
  /// @return  the packed alternative form of the given sample format or
  /// AV_SAMPLE_FMT_NONE on error.
  AVSampleFormat av_get_packed_sample_fmt(
    AVSampleFormat sample_fmt,
  ) {
    return AVSampleFormat.fromValue(_av_get_packed_sample_fmt(
      sample_fmt.value,
    ));
  }

  late final _av_get_packed_sample_fmtPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'av_get_packed_sample_fmt');
  late final _av_get_packed_sample_fmt =
      _av_get_packed_sample_fmtPtr.asFunction<int Function(int)>();

  /// Get the planar alternative form of the given sample format.
  ///
  /// If the passed sample_fmt is already in planar format, the format returned is
  /// the same as the input.
  ///
  /// @return  the planar alternative form of the given sample format or
  /// AV_SAMPLE_FMT_NONE on error.
  AVSampleFormat av_get_planar_sample_fmt(
    AVSampleFormat sample_fmt,
  ) {
    return AVSampleFormat.fromValue(_av_get_planar_sample_fmt(
      sample_fmt.value,
    ));
  }

  late final _av_get_planar_sample_fmtPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'av_get_planar_sample_fmt');
  late final _av_get_planar_sample_fmt =
      _av_get_planar_sample_fmtPtr.asFunction<int Function(int)>();

  /// Generate a string corresponding to the sample format with
  /// sample_fmt, or a header if sample_fmt is negative.
  ///
  /// @param buf the buffer where to write the string
  /// @param buf_size the size of buf
  /// @param sample_fmt the number of the sample format to print the
  /// corresponding info string, or a negative value to print the
  /// corresponding header.
  /// @return the pointer to the filled buffer or NULL if sample_fmt is
  /// unknown or in case of other errors
  ffi.Pointer<ffi.Char> av_get_sample_fmt_string(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    AVSampleFormat sample_fmt,
  ) {
    return _av_get_sample_fmt_string(
      buf,
      buf_size,
      sample_fmt.value,
    );
  }

  late final _av_get_sample_fmt_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('av_get_sample_fmt_string');
  late final _av_get_sample_fmt_string =
      _av_get_sample_fmt_stringPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Return number of bytes per sample.
  ///
  /// @param sample_fmt the sample format
  /// @return number of bytes per sample or zero if unknown for the given
  /// sample format
  int av_get_bytes_per_sample(
    AVSampleFormat sample_fmt,
  ) {
    return _av_get_bytes_per_sample(
      sample_fmt.value,
    );
  }

  late final _av_get_bytes_per_samplePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'av_get_bytes_per_sample');
  late final _av_get_bytes_per_sample =
      _av_get_bytes_per_samplePtr.asFunction<int Function(int)>();

  /// Check if the sample format is planar.
  ///
  /// @param sample_fmt the sample format to inspect
  /// @return 1 if the sample format is planar, 0 if it is interleaved
  int av_sample_fmt_is_planar(
    AVSampleFormat sample_fmt,
  ) {
    return _av_sample_fmt_is_planar(
      sample_fmt.value,
    );
  }

  late final _av_sample_fmt_is_planarPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'av_sample_fmt_is_planar');
  late final _av_sample_fmt_is_planar =
      _av_sample_fmt_is_planarPtr.asFunction<int Function(int)>();

  /// Get the required buffer size for the given audio parameters.
  ///
  /// @param[out] linesize calculated linesize, may be NULL
  /// @param nb_channels   the number of channels
  /// @param nb_samples    the number of samples in a single channel
  /// @param sample_fmt    the sample format
  /// @param align         buffer size alignment (0 = default, 1 = no alignment)
  /// @return              required buffer size, or negative error code on failure
  int av_samples_get_buffer_size(
    ffi.Pointer<ffi.Int> linesize,
    int nb_channels,
    int nb_samples,
    AVSampleFormat sample_fmt,
    int align,
  ) {
    return _av_samples_get_buffer_size(
      linesize,
      nb_channels,
      nb_samples,
      sample_fmt.value,
      align,
    );
  }

  late final _av_samples_get_buffer_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('av_samples_get_buffer_size');
  late final _av_samples_get_buffer_size = _av_samples_get_buffer_sizePtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, int, int, int, int)>();

  /// Fill plane data pointers and linesize for samples with sample
  /// format sample_fmt.
  ///
  /// The audio_data array is filled with the pointers to the samples data planes:
  /// for planar, set the start point of each channel's data within the buffer,
  /// for packed, set the start point of the entire buffer only.
  ///
  /// The value pointed to by linesize is set to the aligned size of each
  /// channel's data buffer for planar layout, or to the aligned size of the
  /// buffer for all channels for packed layout.
  ///
  /// The buffer in buf must be big enough to contain all the samples
  /// (use av_samples_get_buffer_size() to compute its minimum size),
  /// otherwise the audio_data pointers will point to invalid data.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param[out] audio_data  array to be filled with the pointer for each channel
  /// @param[out] linesize    calculated linesize, may be NULL
  /// @param buf              the pointer to a buffer containing the samples
  /// @param nb_channels      the number of channels
  /// @param nb_samples       the number of samples in a single channel
  /// @param sample_fmt       the sample format
  /// @param align            buffer size alignment (0 = default, 1 = no alignment)
  /// @return                 minimum size in bytes required for the buffer on success,
  /// or a negative error code on failure
  int av_samples_fill_arrays(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
    ffi.Pointer<ffi.Int> linesize,
    ffi.Pointer<ffi.Uint8> buf,
    int nb_channels,
    int nb_samples,
    AVSampleFormat sample_fmt,
    int align,
  ) {
    return _av_samples_fill_arrays(
      audio_data,
      linesize,
      buf,
      nb_channels,
      nb_samples,
      sample_fmt.value,
      align,
    );
  }

  late final _av_samples_fill_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_samples_fill_arrays');
  late final _av_samples_fill_arrays = _av_samples_fill_arraysPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Uint8>, int, int, int, int)>();

  /// Allocate a samples buffer for nb_samples samples, and fill data pointers and
  /// linesize accordingly.
  /// The allocated samples buffer can be freed by using av_freep(&audio_data[0])
  /// Allocated data will be initialized to silence.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param[out] audio_data  array to be filled with the pointer for each channel
  /// @param[out] linesize    aligned size for audio buffer(s), may be NULL
  /// @param nb_channels      number of audio channels
  /// @param nb_samples       number of samples per channel
  /// @param sample_fmt       the sample format
  /// @param align            buffer size alignment (0 = default, 1 = no alignment)
  /// @return                 >=0 on success or a negative error code on failure
  /// @todo return the size of the allocated buffer in case of success at the next bump
  /// @see av_samples_fill_arrays()
  /// @see av_samples_alloc_array_and_samples()
  int av_samples_alloc(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
    ffi.Pointer<ffi.Int> linesize,
    int nb_channels,
    int nb_samples,
    AVSampleFormat sample_fmt,
    int align,
  ) {
    return _av_samples_alloc(
      audio_data,
      linesize,
      nb_channels,
      nb_samples,
      sample_fmt.value,
      align,
    );
  }

  late final _av_samples_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_samples_alloc');
  late final _av_samples_alloc = _av_samples_allocPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Int>,
          int, int, int, int)>();

  /// Allocate a data pointers array, samples buffer for nb_samples
  /// samples, and fill data pointers and linesize accordingly.
  ///
  /// This is the same as av_samples_alloc(), but also allocates the data
  /// pointers array.
  ///
  /// @see av_samples_alloc()
  int av_samples_alloc_array_and_samples(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>> audio_data,
    ffi.Pointer<ffi.Int> linesize,
    int nb_channels,
    int nb_samples,
    AVSampleFormat sample_fmt,
    int align,
  ) {
    return _av_samples_alloc_array_and_samples(
      audio_data,
      linesize,
      nb_channels,
      nb_samples,
      sample_fmt.value,
      align,
    );
  }

  late final _av_samples_alloc_array_and_samplesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_samples_alloc_array_and_samples');
  late final _av_samples_alloc_array_and_samples =
      _av_samples_alloc_array_and_samplesPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>>,
              ffi.Pointer<ffi.Int>, int, int, int, int)>();

  /// Copy samples from src to dst.
  ///
  /// @param dst destination array of pointers to data planes
  /// @param src source array of pointers to data planes
  /// @param dst_offset offset in samples at which the data will be written to dst
  /// @param src_offset offset in samples at which the data will be read from src
  /// @param nb_samples number of samples to be copied
  /// @param nb_channels number of audio channels
  /// @param sample_fmt audio sample format
  int av_samples_copy(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src,
    int dst_offset,
    int src_offset,
    int nb_samples,
    int nb_channels,
    AVSampleFormat sample_fmt,
  ) {
    return _av_samples_copy(
      dst,
      src,
      dst_offset,
      src_offset,
      nb_samples,
      nb_channels,
      sample_fmt.value,
    );
  }

  late final _av_samples_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_samples_copy');
  late final _av_samples_copy = _av_samples_copyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int, int, int, int, int)>();

  /// Fill an audio buffer with silence.
  ///
  /// @param audio_data  array of pointers to data planes
  /// @param offset      offset in samples at which to start filling
  /// @param nb_samples  number of samples to fill
  /// @param nb_channels number of audio channels
  /// @param sample_fmt  audio sample format
  int av_samples_set_silence(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
    int offset,
    int nb_samples,
    int nb_channels,
    AVSampleFormat sample_fmt,
  ) {
    return _av_samples_set_silence(
      audio_data,
      offset,
      nb_samples,
      nb_channels,
      sample_fmt.value,
    );
  }

  late final _av_samples_set_silencePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Int,
              ffi.Int, ffi.Int, ffi.Int)>>('av_samples_set_silence');
  late final _av_samples_set_silence = _av_samples_set_silencePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int, int, int, int)>();

  /// Return the LIBAVUTIL_VERSION_INT constant.
  int avutil_version() {
    return _avutil_version();
  }

  late final _avutil_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>('avutil_version');
  late final _avutil_version = _avutil_versionPtr.asFunction<int Function()>();

  /// Return an informative version string. This usually is the actual release
  /// version number or a git commit description. This string has no fixed format
  /// and can change any time. It should never be parsed by code.
  ffi.Pointer<ffi.Char> av_version_info() {
    return _av_version_info();
  }

  late final _av_version_infoPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'av_version_info');
  late final _av_version_info =
      _av_version_infoPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libavutil build-time configuration.
  ffi.Pointer<ffi.Char> avutil_configuration() {
    return _avutil_configuration();
  }

  late final _avutil_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avutil_configuration');
  late final _avutil_configuration =
      _avutil_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libavutil license.
  ffi.Pointer<ffi.Char> avutil_license() {
    return _avutil_license();
  }

  late final _avutil_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avutil_license');
  late final _avutil_license =
      _avutil_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return a string describing the media_type enum, NULL if media_type
  /// is unknown.
  ffi.Pointer<ffi.Char> av_get_media_type_string(
    AVMediaType media_type,
  ) {
    return _av_get_media_type_string(
      media_type.value,
    );
  }

  late final _av_get_media_type_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'av_get_media_type_string');
  late final _av_get_media_type_string = _av_get_media_type_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return a single letter to describe the given picture type
  /// pict_type.
  ///
  /// @param[in] pict_type the picture type @return a single character
  /// representing the picture type, '?' if pict_type is unknown
  int av_get_picture_type_char(
    AVPictureType pict_type,
  ) {
    return _av_get_picture_type_char(
      pict_type.value,
    );
  }

  late final _av_get_picture_type_charPtr =
      _lookup<ffi.NativeFunction<ffi.Char Function(ffi.UnsignedInt)>>(
          'av_get_picture_type_char');
  late final _av_get_picture_type_char =
      _av_get_picture_type_charPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Int> __error() {
    return ___error();
  }

  late final ___errorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function()>>('__error');
  late final ___error =
      ___errorPtr.asFunction<ffi.Pointer<ffi.Int> Function()>();

  int imaxabs(
    int j,
  ) {
    return _imaxabs(
      j,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  int strtoimax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int wcstoimax(
    ffi.Pointer<ffi.WChar> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  int wcstoumax(
    ffi.Pointer<ffi.WChar> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.WChar>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.WChar>,
              ffi.Pointer<ffi.Pointer<ffi.WChar>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Pointer<ffi.WChar>>, int)>();

  int __math_errhandling() {
    return ___math_errhandling();
  }

  late final ___math_errhandlingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('__math_errhandling');
  late final ___math_errhandling =
      ___math_errhandlingPtr.asFunction<int Function()>();

  int __fpclassifyf(
    double arg0,
  ) {
    return ___fpclassifyf(
      arg0,
    );
  }

  late final ___fpclassifyfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('__fpclassifyf');
  late final ___fpclassifyf =
      ___fpclassifyfPtr.asFunction<int Function(double)>();

  int __fpclassifyd(
    double arg0,
  ) {
    return ___fpclassifyd(
      arg0,
    );
  }

  late final ___fpclassifydPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>(
          '__fpclassifyd');
  late final ___fpclassifyd =
      ___fpclassifydPtr.asFunction<int Function(double)>();

  /// *
  /// Math Functions                                *
  /// *
  double acosf(
    double arg0,
  ) {
    return _acosf(
      arg0,
    );
  }

  late final _acosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acosf');
  late final _acosf = _acosfPtr.asFunction<double Function(double)>();

  double acos(
    double arg0,
  ) {
    return _acos(
      arg0,
    );
  }

  late final _acosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acos');
  late final _acos = _acosPtr.asFunction<double Function(double)>();

  double asinf(
    double arg0,
  ) {
    return _asinf(
      arg0,
    );
  }

  late final _asinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinf');
  late final _asinf = _asinfPtr.asFunction<double Function(double)>();

  double asin(
    double arg0,
  ) {
    return _asin(
      arg0,
    );
  }

  late final _asinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asin');
  late final _asin = _asinPtr.asFunction<double Function(double)>();

  double atanf(
    double arg0,
  ) {
    return _atanf(
      arg0,
    );
  }

  late final _atanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanf');
  late final _atanf = _atanfPtr.asFunction<double Function(double)>();

  double atan(
    double arg0,
  ) {
    return _atan(
      arg0,
    );
  }

  late final _atanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atan');
  late final _atan = _atanPtr.asFunction<double Function(double)>();

  double atan2f(
    double arg0,
    double arg1,
  ) {
    return _atan2f(
      arg0,
      arg1,
    );
  }

  late final _atan2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'atan2f');
  late final _atan2f = _atan2fPtr.asFunction<double Function(double, double)>();

  double atan2(
    double arg0,
    double arg1,
  ) {
    return _atan2(
      arg0,
      arg1,
    );
  }

  late final _atan2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'atan2');
  late final _atan2 = _atan2Ptr.asFunction<double Function(double, double)>();

  double cosf(
    double arg0,
  ) {
    return _cosf(
      arg0,
    );
  }

  late final _cosfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cosf');
  late final _cosf = _cosfPtr.asFunction<double Function(double)>();

  double cos(
    double arg0,
  ) {
    return _cos(
      arg0,
    );
  }

  late final _cosPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cos');
  late final _cos = _cosPtr.asFunction<double Function(double)>();

  double sinf(
    double arg0,
  ) {
    return _sinf(
      arg0,
    );
  }

  late final _sinfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinf');
  late final _sinf = _sinfPtr.asFunction<double Function(double)>();

  double sin(
    double arg0,
  ) {
    return _sin(
      arg0,
    );
  }

  late final _sinPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sin');
  late final _sin = _sinPtr.asFunction<double Function(double)>();

  double tanf(
    double arg0,
  ) {
    return _tanf(
      arg0,
    );
  }

  late final _tanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanf');
  late final _tanf = _tanfPtr.asFunction<double Function(double)>();

  double tan(
    double arg0,
  ) {
    return _tan(
      arg0,
    );
  }

  late final _tanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tan');
  late final _tan = _tanPtr.asFunction<double Function(double)>();

  double acoshf(
    double arg0,
  ) {
    return _acoshf(
      arg0,
    );
  }

  late final _acoshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('acoshf');
  late final _acoshf = _acoshfPtr.asFunction<double Function(double)>();

  double acosh(
    double arg0,
  ) {
    return _acosh(
      arg0,
    );
  }

  late final _acoshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('acosh');
  late final _acosh = _acoshPtr.asFunction<double Function(double)>();

  double asinhf(
    double arg0,
  ) {
    return _asinhf(
      arg0,
    );
  }

  late final _asinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('asinhf');
  late final _asinhf = _asinhfPtr.asFunction<double Function(double)>();

  double asinh(
    double arg0,
  ) {
    return _asinh(
      arg0,
    );
  }

  late final _asinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('asinh');
  late final _asinh = _asinhPtr.asFunction<double Function(double)>();

  double atanhf(
    double arg0,
  ) {
    return _atanhf(
      arg0,
    );
  }

  late final _atanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('atanhf');
  late final _atanhf = _atanhfPtr.asFunction<double Function(double)>();

  double atanh(
    double arg0,
  ) {
    return _atanh(
      arg0,
    );
  }

  late final _atanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('atanh');
  late final _atanh = _atanhPtr.asFunction<double Function(double)>();

  double coshf(
    double arg0,
  ) {
    return _coshf(
      arg0,
    );
  }

  late final _coshfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('coshf');
  late final _coshf = _coshfPtr.asFunction<double Function(double)>();

  double cosh(
    double arg0,
  ) {
    return _cosh(
      arg0,
    );
  }

  late final _coshPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cosh');
  late final _cosh = _coshPtr.asFunction<double Function(double)>();

  double sinhf(
    double arg0,
  ) {
    return _sinhf(
      arg0,
    );
  }

  late final _sinhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sinhf');
  late final _sinhf = _sinhfPtr.asFunction<double Function(double)>();

  double sinh(
    double arg0,
  ) {
    return _sinh(
      arg0,
    );
  }

  late final _sinhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sinh');
  late final _sinh = _sinhPtr.asFunction<double Function(double)>();

  double tanhf(
    double arg0,
  ) {
    return _tanhf(
      arg0,
    );
  }

  late final _tanhfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tanhf');
  late final _tanhf = _tanhfPtr.asFunction<double Function(double)>();

  double tanh(
    double arg0,
  ) {
    return _tanh(
      arg0,
    );
  }

  late final _tanhPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tanh');
  late final _tanh = _tanhPtr.asFunction<double Function(double)>();

  double expf(
    double arg0,
  ) {
    return _expf(
      arg0,
    );
  }

  late final _expfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expf');
  late final _expf = _expfPtr.asFunction<double Function(double)>();

  double exp(
    double arg0,
  ) {
    return _exp(
      arg0,
    );
  }

  late final _expPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp');
  late final _exp = _expPtr.asFunction<double Function(double)>();

  double exp2f(
    double arg0,
  ) {
    return _exp2f(
      arg0,
    );
  }

  late final _exp2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('exp2f');
  late final _exp2f = _exp2fPtr.asFunction<double Function(double)>();

  double exp2(
    double arg0,
  ) {
    return _exp2(
      arg0,
    );
  }

  late final _exp2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('exp2');
  late final _exp2 = _exp2Ptr.asFunction<double Function(double)>();

  double expm1f(
    double arg0,
  ) {
    return _expm1f(
      arg0,
    );
  }

  late final _expm1fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('expm1f');
  late final _expm1f = _expm1fPtr.asFunction<double Function(double)>();

  double expm1(
    double arg0,
  ) {
    return _expm1(
      arg0,
    );
  }

  late final _expm1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('expm1');
  late final _expm1 = _expm1Ptr.asFunction<double Function(double)>();

  double logf(
    double arg0,
  ) {
    return _logf(
      arg0,
    );
  }

  late final _logfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logf');
  late final _logf = _logfPtr.asFunction<double Function(double)>();

  double log(
    double arg0,
  ) {
    return _log(
      arg0,
    );
  }

  late final _logPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log');
  late final _log = _logPtr.asFunction<double Function(double)>();

  double log10f(
    double arg0,
  ) {
    return _log10f(
      arg0,
    );
  }

  late final _log10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log10f');
  late final _log10f = _log10fPtr.asFunction<double Function(double)>();

  double log10(
    double arg0,
  ) {
    return _log10(
      arg0,
    );
  }

  late final _log10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log10');
  late final _log10 = _log10Ptr.asFunction<double Function(double)>();

  double log2f(
    double arg0,
  ) {
    return _log2f(
      arg0,
    );
  }

  late final _log2fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log2f');
  late final _log2f = _log2fPtr.asFunction<double Function(double)>();

  double log2(
    double arg0,
  ) {
    return _log2(
      arg0,
    );
  }

  late final _log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log2');
  late final _log2 = _log2Ptr.asFunction<double Function(double)>();

  double log1pf(
    double arg0,
  ) {
    return _log1pf(
      arg0,
    );
  }

  late final _log1pfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('log1pf');
  late final _log1pf = _log1pfPtr.asFunction<double Function(double)>();

  double log1p(
    double arg0,
  ) {
    return _log1p(
      arg0,
    );
  }

  late final _log1pPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('log1p');
  late final _log1p = _log1pPtr.asFunction<double Function(double)>();

  double logbf(
    double arg0,
  ) {
    return _logbf(
      arg0,
    );
  }

  late final _logbfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('logbf');
  late final _logbf = _logbfPtr.asFunction<double Function(double)>();

  double logb(
    double arg0,
  ) {
    return _logb(
      arg0,
    );
  }

  late final _logbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('logb');
  late final _logb = _logbPtr.asFunction<double Function(double)>();

  double modff(
    double arg0,
    ffi.Pointer<ffi.Float> arg1,
  ) {
    return _modff(
      arg0,
      arg1,
    );
  }

  late final _modffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Float>)>>('modff');
  late final _modff =
      _modffPtr.asFunction<double Function(double, ffi.Pointer<ffi.Float>)>();

  double modf(
    double arg0,
    ffi.Pointer<ffi.Double> arg1,
  ) {
    return _modf(
      arg0,
      arg1,
    );
  }

  late final _modfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Double>)>>('modf');
  late final _modf =
      _modfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Double>)>();

  double ldexpf(
    double arg0,
    int arg1,
  ) {
    return _ldexpf(
      arg0,
      arg1,
    );
  }

  late final _ldexpfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'ldexpf');
  late final _ldexpf = _ldexpfPtr.asFunction<double Function(double, int)>();

  double ldexp(
    double arg0,
    int arg1,
  ) {
    return _ldexp(
      arg0,
      arg1,
    );
  }

  late final _ldexpPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'ldexp');
  late final _ldexp = _ldexpPtr.asFunction<double Function(double, int)>();

  double frexpf(
    double arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _frexpf(
      arg0,
      arg1,
    );
  }

  late final _frexpfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Pointer<ffi.Int>)>>('frexpf');
  late final _frexpf =
      _frexpfPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  double frexp(
    double arg0,
    ffi.Pointer<ffi.Int> arg1,
  ) {
    return _frexp(
      arg0,
      arg1,
    );
  }

  late final _frexpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Pointer<ffi.Int>)>>('frexp');
  late final _frexp =
      _frexpPtr.asFunction<double Function(double, ffi.Pointer<ffi.Int>)>();

  int ilogbf(
    double arg0,
  ) {
    return _ilogbf(
      arg0,
    );
  }

  late final _ilogbfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Float)>>('ilogbf');
  late final _ilogbf = _ilogbfPtr.asFunction<int Function(double)>();

  int ilogb(
    double arg0,
  ) {
    return _ilogb(
      arg0,
    );
  }

  late final _ilogbPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Double)>>('ilogb');
  late final _ilogb = _ilogbPtr.asFunction<int Function(double)>();

  double scalbnf(
    double arg0,
    int arg1,
  ) {
    return _scalbnf(
      arg0,
      arg1,
    );
  }

  late final _scalbnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Int)>>(
          'scalbnf');
  late final _scalbnf = _scalbnfPtr.asFunction<double Function(double, int)>();

  double scalbn(
    double arg0,
    int arg1,
  ) {
    return _scalbn(
      arg0,
      arg1,
    );
  }

  late final _scalbnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Int)>>(
          'scalbn');
  late final _scalbn = _scalbnPtr.asFunction<double Function(double, int)>();

  double scalblnf(
    double arg0,
    int arg1,
  ) {
    return _scalblnf(
      arg0,
      arg1,
    );
  }

  late final _scalblnfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Long)>>(
          'scalblnf');
  late final _scalblnf =
      _scalblnfPtr.asFunction<double Function(double, int)>();

  double scalbln(
    double arg0,
    int arg1,
  ) {
    return _scalbln(
      arg0,
      arg1,
    );
  }

  late final _scalblnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Long)>>(
          'scalbln');
  late final _scalbln = _scalblnPtr.asFunction<double Function(double, int)>();

  double fabsf(
    double arg0,
  ) {
    return _fabsf(
      arg0,
    );
  }

  late final _fabsfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('fabsf');
  late final _fabsf = _fabsfPtr.asFunction<double Function(double)>();

  double fabs(
    double arg0,
  ) {
    return _fabs(
      arg0,
    );
  }

  late final _fabsPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('fabs');
  late final _fabs = _fabsPtr.asFunction<double Function(double)>();

  double cbrtf(
    double arg0,
  ) {
    return _cbrtf(
      arg0,
    );
  }

  late final _cbrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('cbrtf');
  late final _cbrtf = _cbrtfPtr.asFunction<double Function(double)>();

  double cbrt(
    double arg0,
  ) {
    return _cbrt(
      arg0,
    );
  }

  late final _cbrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('cbrt');
  late final _cbrt = _cbrtPtr.asFunction<double Function(double)>();

  double hypotf(
    double arg0,
    double arg1,
  ) {
    return _hypotf(
      arg0,
      arg1,
    );
  }

  late final _hypotfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'hypotf');
  late final _hypotf = _hypotfPtr.asFunction<double Function(double, double)>();

  double hypot(
    double arg0,
    double arg1,
  ) {
    return _hypot(
      arg0,
      arg1,
    );
  }

  late final _hypotPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'hypot');
  late final _hypot = _hypotPtr.asFunction<double Function(double, double)>();

  double powf(
    double arg0,
    double arg1,
  ) {
    return _powf(
      arg0,
      arg1,
    );
  }

  late final _powfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'powf');
  late final _powf = _powfPtr.asFunction<double Function(double, double)>();

  double pow(
    double arg0,
    double arg1,
  ) {
    return _pow(
      arg0,
      arg1,
    );
  }

  late final _powPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'pow');
  late final _pow = _powPtr.asFunction<double Function(double, double)>();

  double sqrtf(
    double arg0,
  ) {
    return _sqrtf(
      arg0,
    );
  }

  late final _sqrtfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('sqrtf');
  late final _sqrtf = _sqrtfPtr.asFunction<double Function(double)>();

  double sqrt(
    double arg0,
  ) {
    return _sqrt(
      arg0,
    );
  }

  late final _sqrtPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('sqrt');
  late final _sqrt = _sqrtPtr.asFunction<double Function(double)>();

  double erff(
    double arg0,
  ) {
    return _erff(
      arg0,
    );
  }

  late final _erffPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erff');
  late final _erff = _erffPtr.asFunction<double Function(double)>();

  double erf(
    double arg0,
  ) {
    return _erf(
      arg0,
    );
  }

  late final _erfPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erf');
  late final _erf = _erfPtr.asFunction<double Function(double)>();

  double erfcf(
    double arg0,
  ) {
    return _erfcf(
      arg0,
    );
  }

  late final _erfcfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('erfcf');
  late final _erfcf = _erfcfPtr.asFunction<double Function(double)>();

  double erfc(
    double arg0,
  ) {
    return _erfc(
      arg0,
    );
  }

  late final _erfcPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('erfc');
  late final _erfc = _erfcPtr.asFunction<double Function(double)>();

  double lgammaf(
    double arg0,
  ) {
    return _lgammaf(
      arg0,
    );
  }

  late final _lgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('lgammaf');
  late final _lgammaf = _lgammafPtr.asFunction<double Function(double)>();

  double lgamma(
    double arg0,
  ) {
    return _lgamma(
      arg0,
    );
  }

  late final _lgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('lgamma');
  late final _lgamma = _lgammaPtr.asFunction<double Function(double)>();

  double tgammaf(
    double arg0,
  ) {
    return _tgammaf(
      arg0,
    );
  }

  late final _tgammafPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('tgammaf');
  late final _tgammaf = _tgammafPtr.asFunction<double Function(double)>();

  double tgamma(
    double arg0,
  ) {
    return _tgamma(
      arg0,
    );
  }

  late final _tgammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('tgamma');
  late final _tgamma = _tgammaPtr.asFunction<double Function(double)>();

  double ceilf(
    double arg0,
  ) {
    return _ceilf(
      arg0,
    );
  }

  late final _ceilfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('ceilf');
  late final _ceilf = _ceilfPtr.asFunction<double Function(double)>();

  double ceil(
    double arg0,
  ) {
    return _ceil(
      arg0,
    );
  }

  late final _ceilPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('ceil');
  late final _ceil = _ceilPtr.asFunction<double Function(double)>();

  double floorf(
    double arg0,
  ) {
    return _floorf(
      arg0,
    );
  }

  late final _floorfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('floorf');
  late final _floorf = _floorfPtr.asFunction<double Function(double)>();

  double floor(
    double arg0,
  ) {
    return _floor(
      arg0,
    );
  }

  late final _floorPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('floor');
  late final _floor = _floorPtr.asFunction<double Function(double)>();

  double nearbyintf(
    double arg0,
  ) {
    return _nearbyintf(
      arg0,
    );
  }

  late final _nearbyintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('nearbyintf');
  late final _nearbyintf = _nearbyintfPtr.asFunction<double Function(double)>();

  double nearbyint(
    double arg0,
  ) {
    return _nearbyint(
      arg0,
    );
  }

  late final _nearbyintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('nearbyint');
  late final _nearbyint = _nearbyintPtr.asFunction<double Function(double)>();

  double rintf(
    double arg0,
  ) {
    return _rintf(
      arg0,
    );
  }

  late final _rintfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('rintf');
  late final _rintf = _rintfPtr.asFunction<double Function(double)>();

  double rint(
    double arg0,
  ) {
    return _rint(
      arg0,
    );
  }

  late final _rintPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('rint');
  late final _rint = _rintPtr.asFunction<double Function(double)>();

  int lrintf(
    double arg0,
  ) {
    return _lrintf(
      arg0,
    );
  }

  late final _lrintfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lrintf');
  late final _lrintf = _lrintfPtr.asFunction<int Function(double)>();

  int lrint(
    double arg0,
  ) {
    return _lrint(
      arg0,
    );
  }

  late final _lrintPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lrint');
  late final _lrint = _lrintPtr.asFunction<int Function(double)>();

  double roundf(
    double arg0,
  ) {
    return _roundf(
      arg0,
    );
  }

  late final _roundfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('roundf');
  late final _roundf = _roundfPtr.asFunction<double Function(double)>();

  double round(
    double arg0,
  ) {
    return _round(
      arg0,
    );
  }

  late final _roundPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('round');
  late final _round = _roundPtr.asFunction<double Function(double)>();

  int lroundf(
    double arg0,
  ) {
    return _lroundf(
      arg0,
    );
  }

  late final _lroundfPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Float)>>('lroundf');
  late final _lroundf = _lroundfPtr.asFunction<int Function(double)>();

  int lround(
    double arg0,
  ) {
    return _lround(
      arg0,
    );
  }

  late final _lroundPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Double)>>('lround');
  late final _lround = _lroundPtr.asFunction<int Function(double)>();

  int llrintf(
    double arg0,
  ) {
    return _llrintf(
      arg0,
    );
  }

  late final _llrintfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llrintf');
  late final _llrintf = _llrintfPtr.asFunction<int Function(double)>();

  int llrint(
    double arg0,
  ) {
    return _llrint(
      arg0,
    );
  }

  late final _llrintPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llrint');
  late final _llrint = _llrintPtr.asFunction<int Function(double)>();

  int llroundf(
    double arg0,
  ) {
    return _llroundf(
      arg0,
    );
  }

  late final _llroundfPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Float)>>('llroundf');
  late final _llroundf = _llroundfPtr.asFunction<int Function(double)>();

  int llround(
    double arg0,
  ) {
    return _llround(
      arg0,
    );
  }

  late final _llroundPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Double)>>('llround');
  late final _llround = _llroundPtr.asFunction<int Function(double)>();

  double truncf(
    double arg0,
  ) {
    return _truncf(
      arg0,
    );
  }

  late final _truncfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('truncf');
  late final _truncf = _truncfPtr.asFunction<double Function(double)>();

  double trunc(
    double arg0,
  ) {
    return _trunc(
      arg0,
    );
  }

  late final _truncPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('trunc');
  late final _trunc = _truncPtr.asFunction<double Function(double)>();

  double fmodf(
    double arg0,
    double arg1,
  ) {
    return _fmodf(
      arg0,
      arg1,
    );
  }

  late final _fmodfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmodf');
  late final _fmodf = _fmodfPtr.asFunction<double Function(double, double)>();

  double fmod(
    double arg0,
    double arg1,
  ) {
    return _fmod(
      arg0,
      arg1,
    );
  }

  late final _fmodPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmod');
  late final _fmod = _fmodPtr.asFunction<double Function(double, double)>();

  double remainderf(
    double arg0,
    double arg1,
  ) {
    return _remainderf(
      arg0,
      arg1,
    );
  }

  late final _remainderfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'remainderf');
  late final _remainderf =
      _remainderfPtr.asFunction<double Function(double, double)>();

  double remainder(
    double arg0,
    double arg1,
  ) {
    return _remainder(
      arg0,
      arg1,
    );
  }

  late final _remainderPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'remainder');
  late final _remainder =
      _remainderPtr.asFunction<double Function(double, double)>();

  double remquof(
    double arg0,
    double arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _remquof(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _remquofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(
              ffi.Float, ffi.Float, ffi.Pointer<ffi.Int>)>>('remquof');
  late final _remquof = _remquofPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double remquo(
    double arg0,
    double arg1,
    ffi.Pointer<ffi.Int> arg2,
  ) {
    return _remquo(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _remquoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(
              ffi.Double, ffi.Double, ffi.Pointer<ffi.Int>)>>('remquo');
  late final _remquo = _remquoPtr
      .asFunction<double Function(double, double, ffi.Pointer<ffi.Int>)>();

  double copysignf(
    double arg0,
    double arg1,
  ) {
    return _copysignf(
      arg0,
      arg1,
    );
  }

  late final _copysignfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'copysignf');
  late final _copysignf =
      _copysignfPtr.asFunction<double Function(double, double)>();

  double copysign(
    double arg0,
    double arg1,
  ) {
    return _copysign(
      arg0,
      arg1,
    );
  }

  late final _copysignPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'copysign');
  late final _copysign =
      _copysignPtr.asFunction<double Function(double, double)>();

  double nanf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _nanf(
      arg0,
    );
  }

  late final _nanfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Pointer<ffi.Char>)>>(
          'nanf');
  late final _nanf =
      _nanfPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nan(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _nan(
      arg0,
    );
  }

  late final _nanPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'nan');
  late final _nan =
      _nanPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  double nextafterf(
    double arg0,
    double arg1,
  ) {
    return _nextafterf(
      arg0,
      arg1,
    );
  }

  late final _nextafterfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'nextafterf');
  late final _nextafterf =
      _nextafterfPtr.asFunction<double Function(double, double)>();

  double nextafter(
    double arg0,
    double arg1,
  ) {
    return _nextafter(
      arg0,
      arg1,
    );
  }

  late final _nextafterPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'nextafter');
  late final _nextafter =
      _nextafterPtr.asFunction<double Function(double, double)>();

  double fdimf(
    double arg0,
    double arg1,
  ) {
    return _fdimf(
      arg0,
      arg1,
    );
  }

  late final _fdimfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fdimf');
  late final _fdimf = _fdimfPtr.asFunction<double Function(double, double)>();

  double fdim(
    double arg0,
    double arg1,
  ) {
    return _fdim(
      arg0,
      arg1,
    );
  }

  late final _fdimPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fdim');
  late final _fdim = _fdimPtr.asFunction<double Function(double, double)>();

  double fmaxf(
    double arg0,
    double arg1,
  ) {
    return _fmaxf(
      arg0,
      arg1,
    );
  }

  late final _fmaxfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fmaxf');
  late final _fmaxf = _fmaxfPtr.asFunction<double Function(double, double)>();

  double fmax(
    double arg0,
    double arg1,
  ) {
    return _fmax(
      arg0,
      arg1,
    );
  }

  late final _fmaxPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmax');
  late final _fmax = _fmaxPtr.asFunction<double Function(double, double)>();

  double fminf(
    double arg0,
    double arg1,
  ) {
    return _fminf(
      arg0,
      arg1,
    );
  }

  late final _fminfPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float, ffi.Float)>>(
          'fminf');
  late final _fminf = _fminfPtr.asFunction<double Function(double, double)>();

  double fmin(
    double arg0,
    double arg1,
  ) {
    return _fmin(
      arg0,
      arg1,
    );
  }

  late final _fminPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'fmin');
  late final _fmin = _fminPtr.asFunction<double Function(double, double)>();

  double fmaf(
    double arg0,
    double arg1,
    double arg2,
  ) {
    return _fmaf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fmafPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Float, ffi.Float, ffi.Float)>>('fmaf');
  late final _fmaf =
      _fmafPtr.asFunction<double Function(double, double, double)>();

  double fma(
    double arg0,
    double arg1,
    double arg2,
  ) {
    return _fma(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fmaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Double, ffi.Double, ffi.Double)>>('fma');
  late final _fma =
      _fmaPtr.asFunction<double Function(double, double, double)>();

  /// Apple extensions to the C standard                                        *
  double __exp10f(
    double arg0,
  ) {
    return ___exp10f(
      arg0,
    );
  }

  late final ___exp10fPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__exp10f');
  late final ___exp10f = ___exp10fPtr.asFunction<double Function(double)>();

  double __exp10(
    double arg0,
  ) {
    return ___exp10(
      arg0,
    );
  }

  late final ___exp10Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__exp10');
  late final ___exp10 = ___exp10Ptr.asFunction<double Function(double)>();

  double __cospif(
    double arg0,
  ) {
    return ___cospif(
      arg0,
    );
  }

  late final ___cospifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__cospif');
  late final ___cospif = ___cospifPtr.asFunction<double Function(double)>();

  double __cospi(
    double arg0,
  ) {
    return ___cospi(
      arg0,
    );
  }

  late final ___cospiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__cospi');
  late final ___cospi = ___cospiPtr.asFunction<double Function(double)>();

  double __sinpif(
    double arg0,
  ) {
    return ___sinpif(
      arg0,
    );
  }

  late final ___sinpifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__sinpif');
  late final ___sinpif = ___sinpifPtr.asFunction<double Function(double)>();

  double __sinpi(
    double arg0,
  ) {
    return ___sinpi(
      arg0,
    );
  }

  late final ___sinpiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__sinpi');
  late final ___sinpi = ___sinpiPtr.asFunction<double Function(double)>();

  double __tanpif(
    double arg0,
  ) {
    return ___tanpif(
      arg0,
    );
  }

  late final ___tanpifPtr =
      _lookup<ffi.NativeFunction<ffi.Float Function(ffi.Float)>>('__tanpif');
  late final ___tanpif = ___tanpifPtr.asFunction<double Function(double)>();

  double __tanpi(
    double arg0,
  ) {
    return ___tanpi(
      arg0,
    );
  }

  late final ___tanpiPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('__tanpi');
  late final ___tanpi = ___tanpiPtr.asFunction<double Function(double)>();

  __float2 __sincosf_stret(
    double arg0,
  ) {
    return ___sincosf_stret(
      arg0,
    );
  }

  late final ___sincosf_stretPtr =
      _lookup<ffi.NativeFunction<__float2 Function(ffi.Float)>>(
          '__sincosf_stret');
  late final ___sincosf_stret =
      ___sincosf_stretPtr.asFunction<__float2 Function(double)>();

  __double2 __sincos_stret(
    double arg0,
  ) {
    return ___sincos_stret(
      arg0,
    );
  }

  late final ___sincos_stretPtr =
      _lookup<ffi.NativeFunction<__double2 Function(ffi.Double)>>(
          '__sincos_stret');
  late final ___sincos_stret =
      ___sincos_stretPtr.asFunction<__double2 Function(double)>();

  __float2 __sincospif_stret(
    double arg0,
  ) {
    return ___sincospif_stret(
      arg0,
    );
  }

  late final ___sincospif_stretPtr =
      _lookup<ffi.NativeFunction<__float2 Function(ffi.Float)>>(
          '__sincospif_stret');
  late final ___sincospif_stret =
      ___sincospif_stretPtr.asFunction<__float2 Function(double)>();

  __double2 __sincospi_stret(
    double arg0,
  ) {
    return ___sincospi_stret(
      arg0,
    );
  }

  late final ___sincospi_stretPtr =
      _lookup<ffi.NativeFunction<__double2 Function(ffi.Double)>>(
          '__sincospi_stret');
  late final ___sincospi_stret =
      ___sincospi_stretPtr.asFunction<__double2 Function(double)>();

  double j0(
    double arg0,
  ) {
    return _j0(
      arg0,
    );
  }

  late final _j0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j0');
  late final _j0 = _j0Ptr.asFunction<double Function(double)>();

  double j1(
    double arg0,
  ) {
    return _j1(
      arg0,
    );
  }

  late final _j1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('j1');
  late final _j1 = _j1Ptr.asFunction<double Function(double)>();

  double jn(
    int arg0,
    double arg1,
  ) {
    return _jn(
      arg0,
      arg1,
    );
  }

  late final _jnPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'jn');
  late final _jn = _jnPtr.asFunction<double Function(int, double)>();

  double y0(
    double arg0,
  ) {
    return _y0(
      arg0,
    );
  }

  late final _y0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y0');
  late final _y0 = _y0Ptr.asFunction<double Function(double)>();

  double y1(
    double arg0,
  ) {
    return _y1(
      arg0,
    );
  }

  late final _y1Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>('y1');
  late final _y1 = _y1Ptr.asFunction<double Function(double)>();

  double yn(
    int arg0,
    double arg1,
  ) {
    return _yn(
      arg0,
      arg1,
    );
  }

  late final _ynPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Int, ffi.Double)>>(
          'yn');
  late final _yn = _ynPtr.asFunction<double Function(int, double)>();

  double scalb(
    double arg0,
    double arg1,
  ) {
    return _scalb(
      arg0,
      arg1,
    );
  }

  late final _scalbPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>(
          'scalb');
  late final _scalb = _scalbPtr.asFunction<double Function(double, double)>();

  late final ffi.Pointer<ffi.Int> _signgam = _lookup<ffi.Int>('signgam');

  int get signgam => _signgam.value;

  set signgam(int value) => _signgam.value = value;

  int renameat(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return _renameat(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _renameatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('renameat');
  late final _renameat = _renameatPtr.asFunction<
      int Function(int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int renamex_np(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _renamex_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _renamex_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('renamex_np');
  late final _renamex_np = _renamex_npPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int renameatx_np(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    int arg4,
  ) {
    return _renameatx_np(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _renameatx_npPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('renameatx_np');
  late final _renameatx_np = _renameatx_npPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  int printf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _printf(
      arg0,
    );
  }

  late final _printfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'printf');
  late final _printf =
      _printfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdinp =
      _lookup<ffi.Pointer<FILE>>('__stdinp');

  ffi.Pointer<FILE> get __stdinp => ___stdinp.value;

  set __stdinp(ffi.Pointer<FILE> value) => ___stdinp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stdoutp =
      _lookup<ffi.Pointer<FILE>>('__stdoutp');

  ffi.Pointer<FILE> get __stdoutp => ___stdoutp.value;

  set __stdoutp(ffi.Pointer<FILE> value) => ___stdoutp.value = value;

  late final ffi.Pointer<ffi.Pointer<FILE>> ___stderrp =
      _lookup<ffi.Pointer<FILE>>('__stderrp');

  ffi.Pointer<FILE> get __stderrp => ___stderrp.value;

  set __stderrp(ffi.Pointer<FILE> value) => ___stderrp.value = value;

  void clearerr(
    ffi.Pointer<FILE> arg0,
  ) {
    return _clearerr(
      arg0,
    );
  }

  late final _clearerrPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'clearerr');
  late final _clearerr =
      _clearerrPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int fclose(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fclose(
      arg0,
    );
  }

  late final _fclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fclose');
  late final _fclose = _fclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int feof(
    ffi.Pointer<FILE> arg0,
  ) {
    return _feof(
      arg0,
    );
  }

  late final _feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('feof');
  late final _feof = _feofPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int ferror(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ferror(
      arg0,
    );
  }

  late final _ferrorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ferror');
  late final _ferror = _ferrorPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fflush(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fflush(
      arg0,
    );
  }

  late final _fflushPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fflush');
  late final _fflush = _fflushPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetc(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fgetc(
      arg0,
    );
  }

  late final _fgetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('fgetc');
  late final _fgetc = _fgetcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fgetpos(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<fpos_t> arg1,
  ) {
    return _fgetpos(
      arg0,
      arg1,
    );
  }

  late final _fgetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fgetpos');
  late final _fgetpos = _fgetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  ffi.Pointer<ffi.Char> fgets(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<FILE> arg2,
  ) {
    return _fgets(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fgetsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<FILE>)>>('fgets');
  late final _fgets = _fgetsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fopen(
    ffi.Pointer<ffi.Char> __filename,
    ffi.Pointer<ffi.Char> __mode,
  ) {
    return _fopen(
      __filename,
      __mode,
    );
  }

  late final _fopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fopen');
  late final _fopen = _fopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fprintf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fprintf(
      arg0,
      arg1,
    );
  }

  late final _fprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fprintf');
  late final _fprintf = _fprintfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int fputc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _fputc(
      arg0,
      arg1,
    );
  }

  late final _fputcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'fputc');
  late final _fputc =
      _fputcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int fputs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _fputs(
      arg0,
      arg1,
    );
  }

  late final _fputsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('fputs');
  late final _fputs = _fputsPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fread(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __nitems,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fread(
      __ptr,
      __size,
      __nitems,
      __stream,
    );
  }

  late final _freadPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fread');
  late final _fread = _freadPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> freopen(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<FILE> arg2,
  ) {
    return _freopen(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _freopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>>('freopen');
  late final _freopen = _freopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<FILE>)>();

  int fscanf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fscanf(
      arg0,
      arg1,
    );
  }

  late final _fscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('fscanf');
  late final _fscanf = _fscanfPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int fseek(
    ffi.Pointer<FILE> arg0,
    int arg1,
    int arg2,
  ) {
    return _fseek(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _fseekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Long, ffi.Int)>>('fseek');
  late final _fseek =
      _fseekPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int fsetpos(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<fpos_t> arg1,
  ) {
    return _fsetpos(
      arg0,
      arg1,
    );
  }

  late final _fsetposPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>>('fsetpos');
  late final _fsetpos = _fsetposPtr
      .asFunction<int Function(ffi.Pointer<FILE>, ffi.Pointer<fpos_t>)>();

  int ftell(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ftell(
      arg0,
    );
  }

  late final _ftellPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<FILE>)>>(
          'ftell');
  late final _ftell = _ftellPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int fwrite(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
    int __nitems,
    ffi.Pointer<FILE> __stream,
  ) {
    return _fwrite(
      __ptr,
      __size,
      __nitems,
      __stream,
    );
  }

  late final _fwritePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              ffi.Pointer<FILE>)>>('fwrite');
  late final _fwrite = _fwritePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<FILE>)>();

  int getc(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getc(
      arg0,
    );
  }

  late final _getcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getc');
  late final _getc = _getcPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar() {
    return _getchar();
  }

  late final _getcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar');
  late final _getchar = _getcharPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> gets(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _gets(
      arg0,
    );
  }

  late final _getsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('gets');
  late final _gets = _getsPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void perror(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _perror(
      arg0,
    );
  }

  late final _perrorPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'perror');
  late final _perror =
      _perrorPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int putc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putc(
      arg0,
      arg1,
    );
  }

  late final _putcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc');
  late final _putc =
      _putcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar(
    int arg0,
  ) {
    return _putchar(
      arg0,
    );
  }

  late final _putcharPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('putchar');
  late final _putchar = _putcharPtr.asFunction<int Function(int)>();

  int puts(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _puts(
      arg0,
    );
  }

  late final _putsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'puts');
  late final _puts = _putsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int remove(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _remove(
      arg0,
    );
  }

  late final _removePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'remove');
  late final _remove =
      _removePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int rename(
    ffi.Pointer<ffi.Char> __old,
    ffi.Pointer<ffi.Char> __new,
  ) {
    return _rename(
      __old,
      __new,
    );
  }

  late final _renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('rename');
  late final _rename = _renamePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  void rewind(
    ffi.Pointer<FILE> arg0,
  ) {
    return _rewind(
      arg0,
    );
  }

  late final _rewindPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'rewind');
  late final _rewind =
      _rewindPtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int scanf(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _scanf(
      arg0,
    );
  }

  late final _scanfPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'scanf');
  late final _scanf =
      _scanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  void setbuf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _setbuf(
      arg0,
      arg1,
    );
  }

  late final _setbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>>('setbuf');
  late final _setbuf = _setbufPtr
      .asFunction<void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>)>();

  int setvbuf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
    int arg3,
  ) {
    return _setvbuf(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _setvbufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Size)>>('setvbuf');
  late final _setvbuf = _setvbufPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int, int)>();

  int sprintf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _sprintf(
      arg0,
      arg1,
    );
  }

  late final _sprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sprintf');
  late final _sprintf = _sprintfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int sscanf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _sscanf(
      arg0,
      arg1,
    );
  }

  late final _sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('sscanf');
  late final _sscanf = _sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> tmpfile() {
    return _tmpfile();
  }

  late final _tmpfilePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<FILE> Function()>>('tmpfile');
  late final _tmpfile = _tmpfilePtr.asFunction<ffi.Pointer<FILE> Function()>();

  ffi.Pointer<ffi.Char> tmpnam(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _tmpnam(
      arg0,
    );
  }

  late final _tmpnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('tmpnam');
  late final _tmpnam = _tmpnamPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int ungetc(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _ungetc(
      arg0,
      arg1,
    );
  }

  late final _ungetcPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'ungetc');
  late final _ungetc =
      _ungetcPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int vfprintf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vfprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vfprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>>('vfprintf');
  late final _vfprintf = _vfprintfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int vprintf(
    ffi.Pointer<ffi.Char> arg0,
    va_list arg1,
  ) {
    return _vprintf(
      arg0,
      arg1,
    );
  }

  late final _vprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, va_list)>>(
      'vprintf');
  late final _vprintf =
      _vprintfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, va_list)>();

  int vsprintf(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vsprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vsprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('vsprintf');
  late final _vsprintf = _vsprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  ffi.Pointer<ffi.Char> ctermid(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid(
      arg0,
    );
  }

  late final _ctermidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid');
  late final _ctermid = _ctermidPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> fdopen(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fdopen(
      arg0,
      arg1,
    );
  }

  late final _fdopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Int, ffi.Pointer<ffi.Char>)>>('fdopen');
  late final _fdopen = _fdopenPtr
      .asFunction<ffi.Pointer<FILE> Function(int, ffi.Pointer<ffi.Char>)>();

  int fileno(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fileno(
      arg0,
    );
  }

  late final _filenoPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fileno');
  late final _fileno = _filenoPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int pclose(
    ffi.Pointer<FILE> arg0,
  ) {
    return _pclose(
      arg0,
    );
  }

  late final _pclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'pclose');
  late final _pclose = _pclosePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> popen(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _popen(
      arg0,
      arg1,
    );
  }

  late final _popenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('popen');
  late final _popen = _popenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int __srget(
    ffi.Pointer<FILE> arg0,
  ) {
    return ___srget(
      arg0,
    );
  }

  late final ___srgetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          '__srget');
  late final ___srget =
      ___srgetPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int __svfscanf(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return ___svfscanf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final ___svfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>,
              va_list)>>('__svfscanf');
  late final ___svfscanf = ___svfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int __swbuf(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return ___swbuf(
      arg0,
      arg1,
    );
  }

  late final ___swbufPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          '__swbuf');
  late final ___swbuf =
      ___swbufPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  void flockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _flockfile(
      arg0,
    );
  }

  late final _flockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'flockfile');
  late final _flockfile =
      _flockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int ftrylockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _ftrylockfile(
      arg0,
    );
  }

  late final _ftrylockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'ftrylockfile');
  late final _ftrylockfile =
      _ftrylockfilePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void funlockfile(
    ffi.Pointer<FILE> arg0,
  ) {
    return _funlockfile(
      arg0,
    );
  }

  late final _funlockfilePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FILE>)>>(
          'funlockfile');
  late final _funlockfile =
      _funlockfilePtr.asFunction<void Function(ffi.Pointer<FILE>)>();

  int getc_unlocked(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getc_unlocked(
      arg0,
    );
  }

  late final _getc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'getc_unlocked');
  late final _getc_unlocked =
      _getc_unlockedPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int getchar_unlocked() {
    return _getchar_unlocked();
  }

  late final _getchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('getchar_unlocked');
  late final _getchar_unlocked =
      _getchar_unlockedPtr.asFunction<int Function()>();

  int putc_unlocked(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putc_unlocked(
      arg0,
      arg1,
    );
  }

  late final _putc_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putc_unlocked');
  late final _putc_unlocked =
      _putc_unlockedPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  int putchar_unlocked(
    int arg0,
  ) {
    return _putchar_unlocked(
      arg0,
    );
  }

  late final _putchar_unlockedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'putchar_unlocked');
  late final _putchar_unlocked =
      _putchar_unlockedPtr.asFunction<int Function(int)>();

  int getw(
    ffi.Pointer<FILE> arg0,
  ) {
    return _getw(
      arg0,
    );
  }

  late final _getwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>('getw');
  late final _getw = _getwPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int putw(
    int arg0,
    ffi.Pointer<FILE> arg1,
  ) {
    return _putw(
      arg0,
      arg1,
    );
  }

  late final _putwPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<FILE>)>>(
          'putw');
  late final _putw =
      _putwPtr.asFunction<int Function(int, ffi.Pointer<FILE>)>();

  ffi.Pointer<ffi.Char> tempnam(
    ffi.Pointer<ffi.Char> __dir,
    ffi.Pointer<ffi.Char> __prefix,
  ) {
    return _tempnam(
      __dir,
      __prefix,
    );
  }

  late final _tempnamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('tempnam');
  late final _tempnam = _tempnamPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fseeko(
    ffi.Pointer<FILE> __stream,
    int __offset,
    int __whence,
  ) {
    return _fseeko(
      __stream,
      __offset,
      __whence,
    );
  }

  late final _fseekoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<FILE>, off_t, ffi.Int)>>('fseeko');
  late final _fseeko =
      _fseekoPtr.asFunction<int Function(ffi.Pointer<FILE>, int, int)>();

  int ftello(
    ffi.Pointer<FILE> __stream,
  ) {
    return _ftello(
      __stream,
    );
  }

  late final _ftelloPtr =
      _lookup<ffi.NativeFunction<off_t Function(ffi.Pointer<FILE>)>>('ftello');
  late final _ftello = _ftelloPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int snprintf(
    ffi.Pointer<ffi.Char> __str,
    int __size,
    ffi.Pointer<ffi.Char> __format,
  ) {
    return _snprintf(
      __str,
      __size,
      __format,
    );
  }

  late final _snprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('snprintf');
  late final _snprintf = _snprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  int vfscanf(
    ffi.Pointer<FILE> __stream,
    ffi.Pointer<ffi.Char> __format,
    va_list arg2,
  ) {
    return _vfscanf(
      __stream,
      __format,
      arg2,
    );
  }

  late final _vfscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>>('vfscanf');
  late final _vfscanf = _vfscanfPtr.asFunction<
      int Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, va_list)>();

  int vscanf(
    ffi.Pointer<ffi.Char> __format,
    va_list arg1,
  ) {
    return _vscanf(
      __format,
      arg1,
    );
  }

  late final _vscanfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, va_list)>>(
      'vscanf');
  late final _vscanf =
      _vscanfPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, va_list)>();

  int vsnprintf(
    ffi.Pointer<ffi.Char> __str,
    int __size,
    ffi.Pointer<ffi.Char> __format,
    va_list arg3,
  ) {
    return _vsnprintf(
      __str,
      __size,
      __format,
      arg3,
    );
  }

  late final _vsnprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('vsnprintf');
  late final _vsnprintf = _vsnprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, va_list)>();

  int vsscanf(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __format,
    va_list arg2,
  ) {
    return _vsscanf(
      __str,
      __format,
      arg2,
    );
  }

  late final _vsscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              va_list)>>('vsscanf');
  late final _vsscanf = _vsscanfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, va_list)>();

  int dprintf(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _dprintf(
      arg0,
      arg1,
    );
  }

  late final _dprintfPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'dprintf');
  late final _dprintf =
      _dprintfPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  int vdprintf(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vdprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vdprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, va_list)>>('vdprintf');
  late final _vdprintf = _vdprintfPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, va_list)>();

  int getdelim(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __linep,
    ffi.Pointer<ffi.Size> __linecapp,
    int __delimiter,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getdelim(
      __linep,
      __linecapp,
      __delimiter,
      __stream,
    );
  }

  late final _getdelimPtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Int, ffi.Pointer<FILE>)>>('getdelim');
  late final _getdelim = _getdelimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          int, ffi.Pointer<FILE>)>();

  int getline(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __linep,
    ffi.Pointer<ffi.Size> __linecapp,
    ffi.Pointer<FILE> __stream,
  ) {
    return _getline(
      __linep,
      __linecapp,
      __stream,
    );
  }

  late final _getlinePtr = _lookup<
      ffi.NativeFunction<
          ssize_t Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>, ffi.Pointer<FILE>)>>('getline');
  late final _getline = _getlinePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<FILE>)>();

  ffi.Pointer<FILE> fmemopen(
    ffi.Pointer<ffi.Void> __buf,
    int __size,
    ffi.Pointer<ffi.Char> __mode,
  ) {
    return _fmemopen(
      __buf,
      __size,
      __mode,
    );
  }

  late final _fmemopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('fmemopen');
  late final _fmemopen = _fmemopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<FILE> open_memstream(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __bufp,
    ffi.Pointer<ffi.Size> __sizep,
  ) {
    return _open_memstream(
      __bufp,
      __sizep,
    );
  }

  late final _open_memstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Size>)>>('open_memstream');
  late final _open_memstream = _open_memstreamPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Size>)>();

  late final ffi.Pointer<ffi.Int> _sys_nerr = _lookup<ffi.Int>('sys_nerr');

  int get sys_nerr => _sys_nerr.value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _sys_errlist =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('sys_errlist');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get sys_errlist => _sys_errlist.value;

  set sys_errlist(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      _sys_errlist.value = value;

  int asprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _asprintf(
      arg0,
      arg1,
    );
  }

  late final _asprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('asprintf');
  late final _asprintf = _asprintfPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctermid_r(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _ctermid_r(
      arg0,
    );
  }

  late final _ctermid_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('ctermid_r');
  late final _ctermid_r = _ctermid_rPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> fgetln(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Size> arg1,
  ) {
    return _fgetln(
      arg0,
      arg1,
    );
  }

  late final _fgetlnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Size>)>>('fgetln');
  late final _fgetln = _fgetlnPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<FILE>, ffi.Pointer<ffi.Size>)>();

  ffi.Pointer<ffi.Char> fmtcheck(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _fmtcheck(
      arg0,
      arg1,
    );
  }

  late final _fmtcheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('fmtcheck');
  late final _fmtcheck = _fmtcheckPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int fpurge(
    ffi.Pointer<FILE> arg0,
  ) {
    return _fpurge(
      arg0,
    );
  }

  late final _fpurgePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'fpurge');
  late final _fpurge = _fpurgePtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  void setbuffer(
    ffi.Pointer<FILE> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _setbuffer(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setbufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, ffi.Int)>>('setbuffer');
  late final _setbuffer = _setbufferPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Char>, int)>();

  int setlinebuf(
    ffi.Pointer<FILE> arg0,
  ) {
    return _setlinebuf(
      arg0,
    );
  }

  late final _setlinebufPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<FILE>)>>(
          'setlinebuf');
  late final _setlinebuf =
      _setlinebufPtr.asFunction<int Function(ffi.Pointer<FILE>)>();

  int vasprintf(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Char> arg1,
    va_list arg2,
  ) {
    return _vasprintf(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _vasprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>, va_list)>>('vasprintf');
  late final _vasprintf = _vasprintfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          va_list)>();

  ffi.Pointer<FILE> funopen(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>
        arg1,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>
        arg2,
    ffi.Pointer<
            ffi.NativeFunction<
                fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>
        arg3,
    ffi.Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
        arg4,
  ) {
    return _funopen(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final _funopenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FILE> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Char>, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>)>>)>>('funopen');
  late final _funopen = _funopenPtr.asFunction<
      ffi.Pointer<FILE> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>>,
          ffi.Pointer<
              ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>)>();

  int __sprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
  ) {
    return ___sprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final ___sprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('__sprintf_chk');
  late final ___sprintf_chk = ___sprintf_chkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>)>();

  int __snprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
    ffi.Pointer<ffi.Char> arg4,
  ) {
    return ___snprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final ___snprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('__snprintf_chk');
  late final ___snprintf_chk = ___snprintf_chkPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Char>)>();

  int __vsprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    ffi.Pointer<ffi.Char> arg3,
    va_list arg4,
  ) {
    return ___vsprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
    );
  }

  late final ___vsprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('__vsprintf_chk');
  late final ___vsprintf_chk = ___vsprintf_chkPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, int, ffi.Pointer<ffi.Char>, va_list)>();

  int __vsnprintf_chk(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    int arg2,
    int arg3,
    ffi.Pointer<ffi.Char> arg4,
    va_list arg5,
  ) {
    return ___vsnprintf_chk(
      arg0,
      arg1,
      arg2,
      arg3,
      arg4,
      arg5,
    );
  }

  late final ___vsnprintf_chkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int, ffi.Size,
              ffi.Pointer<ffi.Char>, va_list)>>('__vsnprintf_chk');
  late final ___vsnprintf_chk = ___vsnprintf_chkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int, int, ffi.Pointer<ffi.Char>,
          va_list)>();

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait1(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait1(
      arg0,
    );
  }

  late final _wait1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait1 =
      _wait1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    idtype_t arg0,
    Dart__uint32_t arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0.value,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, id_t, ffi.Pointer<siginfo_t>,
              ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int arg0,
  ) {
    return _alloca(
      arg0,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _at_quick_exit(
      arg0,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void quick_exit(
    int arg0,
  ) {
    return _quick_exit(
      arg0,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int arg2,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _initstate(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int arg1,
  ) {
    return _arc4random_addrandom(
      arg0,
      arg1,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int arg1,
  ) {
    return _getloadavg(
      arg0,
      arg1,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  ffi.Pointer<ffi.Void> memchr(
    ffi.Pointer<ffi.Void> __s,
    int __c,
    int __n,
  ) {
    return _memchr(
      __s,
      __c,
      __n,
    );
  }

  late final _memchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memchr');
  late final _memchr = _memchrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  int memcmp(
    ffi.Pointer<ffi.Void> __s1,
    ffi.Pointer<ffi.Void> __s2,
    int __n,
  ) {
    return _memcmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _memcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memcmp');
  late final _memcmp = _memcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memcpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __n,
  ) {
    return _memcpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _memcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memcpy');
  late final _memcpy = _memcpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memmove(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __len,
  ) {
    return _memmove(
      __dst,
      __src,
      __len,
    );
  }

  late final _memmovePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmove');
  late final _memmove = _memmovePtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> memset(
    ffi.Pointer<ffi.Void> __b,
    int __c,
    int __len,
  ) {
    return _memset(
      __b,
      __c,
      __len,
    );
  }

  late final _memsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memset');
  late final _memset = _memsetPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> strcat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcat(
      __s1,
      __s2,
    );
  }

  late final _strcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcat');
  late final _strcat = _strcatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strchr(
      __s,
      __c,
    );
  }

  late final _strchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strchr');
  late final _strchr = _strchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strcmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcmp(
      __s1,
      __s2,
    );
  }

  late final _strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcmp');
  late final _strcmp = _strcmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcoll(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
  ) {
    return _strcoll(
      __s1,
      __s2,
    );
  }

  late final _strcollPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcoll');
  late final _strcoll = _strcollPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _strcpy(
      __dst,
      __src,
    );
  }

  late final _strcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcpy');
  late final _strcpy = _strcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strcspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strcspn(
      __s,
      __charset,
    );
  }

  late final _strcspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcspn');
  late final _strcspn = _strcspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strerror(
    int __errnum,
  ) {
    return _strerror(
      __errnum,
    );
  }

  late final _strerrorPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strerror');
  late final _strerror =
      _strerrorPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int strlen(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _strlen(
      __s,
    );
  }

  late final _strlenPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>)>>(
      'strlen');
  late final _strlen =
      _strlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strncat(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncat(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncat');
  late final _strncat = _strncatPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strncmp(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strncmp(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncmp');
  late final _strncmp = _strncmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _strncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _strncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strncpy');
  late final _strncpy = _strncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strpbrk(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strpbrk(
      __s,
      __charset,
    );
  }

  late final _strpbrkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strpbrk');
  late final _strpbrk = _strpbrkPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strrchr(
    ffi.Pointer<ffi.Char> __s,
    int __c,
  ) {
    return _strrchr(
      __s,
      __c,
    );
  }

  late final _strrchrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('strrchr');
  late final _strrchr = _strrchrPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strspn(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.Char> __charset,
  ) {
    return _strspn(
      __s,
      __charset,
    );
  }

  late final _strspnPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strspn');
  late final _strspn = _strspnPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strstr(
      __big,
      __little,
    );
  }

  late final _strstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strstr');
  late final _strstr = _strstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strtok(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
  ) {
    return _strtok(
      __str,
      __sep,
    );
  }

  late final _strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strtok');
  late final _strtok = _strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strxfrm(
    ffi.Pointer<ffi.Char> __s1,
    ffi.Pointer<ffi.Char> __s2,
    int __n,
  ) {
    return _strxfrm(
      __s1,
      __s2,
      __n,
    );
  }

  late final _strxfrmPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strxfrm');
  late final _strxfrm = _strxfrmPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strtok_r(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Char> __sep,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __lasts,
  ) {
    return _strtok_r(
      __str,
      __sep,
      __lasts,
    );
  }

  late final _strtok_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtok_r');
  late final _strtok_r = _strtok_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strerror_r(
    int __errnum,
    ffi.Pointer<ffi.Char> __strerrbuf,
    int __buflen,
  ) {
    return _strerror_r(
      __errnum,
      __strerrbuf,
      __buflen,
    );
  }

  late final _strerror_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strerror_r');
  late final _strerror_r = _strerror_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strdup(
    ffi.Pointer<ffi.Char> __s1,
  ) {
    return _strdup(
      __s1,
    );
  }

  late final _strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('strdup');
  late final _strdup = _strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> memccpy(
    ffi.Pointer<ffi.Void> __dst,
    ffi.Pointer<ffi.Void> __src,
    int __c,
    int __n,
  ) {
    return _memccpy(
      __dst,
      __src,
      __c,
      __n,
    );
  }

  late final _memccpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Int, ffi.Size)>>('memccpy');
  late final _memccpy = _memccpyPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Char> stpcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
  ) {
    return _stpcpy(
      __dst,
      __src,
    );
  }

  late final _stpcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('stpcpy');
  late final _stpcpy = _stpcpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> stpncpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __src,
    int __n,
  ) {
    return _stpncpy(
      __dst,
      __src,
      __n,
    );
  }

  late final _stpncpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('stpncpy');
  late final _stpncpy = _stpncpyPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strndup(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strndup(
      __s1,
      __n,
    );
  }

  late final _strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strndup');
  late final _strndup = _strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int strnlen(
    ffi.Pointer<ffi.Char> __s1,
    int __n,
  ) {
    return _strnlen(
      __s1,
      __n,
    );
  }

  late final _strnlenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('strnlen');
  late final _strnlen =
      _strnlenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> strsignal(
    int __sig,
  ) {
    return _strsignal(
      __sig,
    );
  }

  late final _strsignalPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'strsignal');
  late final _strsignal =
      _strsignalPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int memset_s(
    ffi.Pointer<ffi.Void> __s,
    int __smax,
    int __c,
    int __n,
  ) {
    return _memset_s(
      __s,
      __smax,
      __c,
      __n,
    );
  }

  late final _memset_sPtr = _lookup<
      ffi.NativeFunction<
          errno_t Function(
              ffi.Pointer<ffi.Void>, rsize_t, ffi.Int, rsize_t)>>('memset_s');
  late final _memset_s = _memset_sPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int, int)>();

  ffi.Pointer<ffi.Void> memmem(
    ffi.Pointer<ffi.Void> __big,
    int __big_len,
    ffi.Pointer<ffi.Void> __little,
    int __little_len,
  ) {
    return _memmem(
      __big,
      __big_len,
      __little,
      __little_len,
    );
  }

  late final _memmemPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('memmem');
  late final _memmem = _memmemPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern4(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern4,
    int __len,
  ) {
    return _memset_pattern4(
      __b,
      __pattern4,
      __len,
    );
  }

  late final _memset_pattern4Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern4');
  late final _memset_pattern4 = _memset_pattern4Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern8(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern8,
    int __len,
  ) {
    return _memset_pattern8(
      __b,
      __pattern8,
      __len,
    );
  }

  late final _memset_pattern8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern8');
  late final _memset_pattern8 = _memset_pattern8Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void memset_pattern16(
    ffi.Pointer<ffi.Void> __b,
    ffi.Pointer<ffi.Void> __pattern16,
    int __len,
  ) {
    return _memset_pattern16(
      __b,
      __pattern16,
      __len,
    );
  }

  late final _memset_pattern16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('memset_pattern16');
  late final _memset_pattern16 = _memset_pattern16Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> strcasestr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
  ) {
    return _strcasestr(
      __big,
      __little,
    );
  }

  late final _strcasestrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasestr');
  late final _strcasestr = _strcasestrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strnstr(
    ffi.Pointer<ffi.Char> __big,
    ffi.Pointer<ffi.Char> __little,
    int __len,
  ) {
    return _strnstr(
      __big,
      __little,
      __len,
    );
  }

  late final _strnstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strnstr');
  late final _strnstr = _strnstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcat(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcat(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcat');
  late final _strlcat = _strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int strlcpy(
    ffi.Pointer<ffi.Char> __dst,
    ffi.Pointer<ffi.Char> __source,
    int __size,
  ) {
    return _strlcpy(
      __dst,
      __source,
      __size,
    );
  }

  late final _strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('strlcpy');
  late final _strlcpy = _strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void strmode(
    int __mode,
    ffi.Pointer<ffi.Char> __bp,
  ) {
    return _strmode(
      __mode,
      __bp,
    );
  }

  late final _strmodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('strmode');
  late final _strmode =
      _strmodePtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> strsep(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __stringp,
    ffi.Pointer<ffi.Char> __delim,
  ) {
    return _strsep(
      __stringp,
      __delim,
    );
  }

  late final _strsepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('strsep');
  late final _strsep = _strsepPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  void swab(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _swab(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _swabPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ssize_t)>>('swab');
  late final _swab = _swabPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int timingsafe_bcmp(
    ffi.Pointer<ffi.Void> __b1,
    ffi.Pointer<ffi.Void> __b2,
    int __len,
  ) {
    return _timingsafe_bcmp(
      __b1,
      __b2,
      __len,
    );
  }

  late final _timingsafe_bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('timingsafe_bcmp');
  late final _timingsafe_bcmp = _timingsafe_bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  int strsignal_r(
    int __sig,
    ffi.Pointer<ffi.Char> __strsignalbuf,
    int __buflen,
  ) {
    return _strsignal_r(
      __sig,
      __strsignalbuf,
      __buflen,
    );
  }

  late final _strsignal_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('strsignal_r');
  late final _strsignal_r = _strsignal_rPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int bcmp(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, ffi.Size)>>('bcmp');
  late final _bcmp = _bcmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bcopy(
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<ffi.Void> arg1,
    int arg2,
  ) {
    return _bcopy(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _bcopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('bcopy');
  late final _bcopy = _bcopyPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int)>();

  void bzero(
    ffi.Pointer<ffi.Void> arg0,
    int arg1,
  ) {
    return _bzero(
      arg0,
      arg1,
    );
  }

  late final _bzeroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('bzero');
  late final _bzero =
      _bzeroPtr.asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Char> index(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _index(
      arg0,
      arg1,
    );
  }

  late final _indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('index');
  late final _index = _indexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> rindex(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _rindex(
      arg0,
      arg1,
    );
  }

  late final _rindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('rindex');
  late final _rindex = _rindexPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  int ffs(
    int arg0,
  ) {
    return _ffs(
      arg0,
    );
  }

  late final _ffsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('ffs');
  late final _ffs = _ffsPtr.asFunction<int Function(int)>();

  int strcasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _strcasecmp(
      arg0,
      arg1,
    );
  }

  late final _strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('strcasecmp');
  late final _strcasecmp = _strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int strncasecmp(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _strncasecmp(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('strncasecmp');
  late final _strncasecmp = _strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int ffsl(
    int arg0,
  ) {
    return _ffsl(
      arg0,
    );
  }

  late final _ffslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('ffsl');
  late final _ffsl = _ffslPtr.asFunction<int Function(int)>();

  int ffsll(
    int arg0,
  ) {
    return _ffsll(
      arg0,
    );
  }

  late final _ffsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('ffsll');
  late final _ffsll = _ffsllPtr.asFunction<int Function(int)>();

  int fls(
    int arg0,
  ) {
    return _fls(
      arg0,
    );
  }

  late final _flsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('fls');
  late final _fls = _flsPtr.asFunction<int Function(int)>();

  int flsl(
    int arg0,
  ) {
    return _flsl(
      arg0,
    );
  }

  late final _flslPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Long)>>('flsl');
  late final _flsl = _flslPtr.asFunction<int Function(int)>();

  int flsll(
    int arg0,
  ) {
    return _flsll(
      arg0,
    );
  }

  late final _flsllPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.LongLong)>>('flsll');
  late final _flsll = _flsllPtr.asFunction<int Function(int)>();

  /// Put a description of the AVERROR code errnum in errbuf.
  /// In case of failure the global variable errno is set to indicate the
  /// error. Even in case of failure av_strerror() will print a generic
  /// error message indicating the errnum provided to errbuf.
  ///
  /// @param errnum      error code to describe
  /// @param errbuf      buffer to which description is written
  /// @param errbuf_size the size in bytes of errbuf
  /// @return 0 on success, a negative value if a description for errnum
  /// cannot be found
  int av_strerror(
    int errnum,
    ffi.Pointer<ffi.Char> errbuf,
    int errbuf_size,
  ) {
    return _av_strerror(
      errnum,
      errbuf,
      errbuf_size,
    );
  }

  late final _av_strerrorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('av_strerror');
  late final _av_strerror = _av_strerrorPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  /// Allocate a memory block with alignment suitable for all memory accesses
  /// (including vectors if available on the CPU).
  ///
  /// @param size Size in bytes for the memory block to be allocated
  /// @return Pointer to the allocated block, or `NULL` if the block cannot
  /// be allocated
  /// @see av_mallocz()
  ffi.Pointer<ffi.Void> av_malloc(
    int size,
  ) {
    return _av_malloc(
      size,
    );
  }

  late final _av_mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'av_malloc');
  late final _av_malloc =
      _av_mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Allocate a memory block with alignment suitable for all memory accesses
  /// (including vectors if available on the CPU) and zero all the bytes of the
  /// block.
  ///
  /// @param size Size in bytes for the memory block to be allocated
  /// @return Pointer to the allocated block, or `NULL` if it cannot be allocated
  /// @see av_malloc()
  ffi.Pointer<ffi.Void> av_mallocz(
    int size,
  ) {
    return _av_mallocz(
      size,
    );
  }

  late final _av_malloczPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'av_mallocz');
  late final _av_mallocz =
      _av_malloczPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  /// Allocate a memory block for an array with av_malloc().
  ///
  /// The allocated memory will have size `size * nmemb` bytes.
  ///
  /// @param nmemb Number of element
  /// @param size  Size of a single element
  /// @return Pointer to the allocated block, or `NULL` if the block cannot
  /// be allocated
  /// @see av_malloc()
  ffi.Pointer<ffi.Void> av_malloc_array(
    int nmemb,
    int size,
  ) {
    return _av_malloc_array(
      nmemb,
      size,
    );
  }

  late final _av_malloc_arrayPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>(
      'av_malloc_array');
  late final _av_malloc_array = _av_malloc_arrayPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// Allocate a memory block for an array with av_mallocz().
  ///
  /// The allocated memory will have size `size * nmemb` bytes.
  ///
  /// @param nmemb Number of elements
  /// @param size  Size of the single element
  /// @return Pointer to the allocated block, or `NULL` if the block cannot
  /// be allocated
  ///
  /// @see av_mallocz()
  /// @see av_malloc_array()
  ffi.Pointer<ffi.Void> av_calloc(
    int nmemb,
    int size,
  ) {
    return _av_calloc(
      nmemb,
      size,
    );
  }

  late final _av_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('av_calloc');
  late final _av_calloc =
      _av_callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  /// Allocate, reallocate, or free a block of memory.
  ///
  /// If `ptr` is `NULL` and `size` > 0, allocate a new block. Otherwise, expand or
  /// shrink that block of memory according to `size`.
  ///
  /// @param ptr  Pointer to a memory block already allocated with
  /// av_realloc() or `NULL`
  /// @param size Size in bytes of the memory block to be allocated or
  /// reallocated
  ///
  /// @return Pointer to a newly-reallocated block or `NULL` if the block
  /// cannot be reallocated
  ///
  /// @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
  /// correctly aligned. The returned pointer must be freed after even
  /// if size is zero.
  /// @see av_fast_realloc()
  /// @see av_reallocp()
  ffi.Pointer<ffi.Void> av_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
  ) {
    return _av_realloc(
      ptr,
      size,
    );
  }

  late final _av_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('av_realloc');
  late final _av_realloc = _av_reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Allocate, reallocate, or free a block of memory through a pointer to a
  /// pointer.
  ///
  /// If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
  /// zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
  /// shrink that block of memory according to `size`.
  ///
  /// @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
  /// with av_realloc(), or a pointer to `NULL`. The pointer
  /// is updated on success, or freed on failure.
  /// @param[in]     size Size in bytes for the memory block to be allocated or
  /// reallocated
  ///
  /// @return Zero on success, an AVERROR error code on failure
  ///
  /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
  /// correctly aligned.
  int av_reallocp(
    ffi.Pointer<ffi.Void> ptr,
    int size,
  ) {
    return _av_reallocp(
      ptr,
      size,
    );
  }

  late final _av_reallocpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Size)>>('av_reallocp');
  late final _av_reallocp =
      _av_reallocpPtr.asFunction<int Function(ffi.Pointer<ffi.Void>, int)>();

  /// Allocate, reallocate, or free a block of memory.
  ///
  /// This function does the same thing as av_realloc(), except:
  /// - It takes two size arguments and allocates `nelem * elsize` bytes,
  /// after checking the result of the multiplication for integer overflow.
  /// - It frees the input block in case of failure, thus avoiding the memory
  /// leak with the classic
  /// @code{.c}
  /// buf = realloc(buf);
  /// if (!buf)
  /// return -1;
  /// @endcode
  /// pattern.
  ffi.Pointer<ffi.Void> av_realloc_f(
    ffi.Pointer<ffi.Void> ptr,
    int nelem,
    int elsize,
  ) {
    return _av_realloc_f(
      ptr,
      nelem,
      elsize,
    );
  }

  late final _av_realloc_fPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('av_realloc_f');
  late final _av_realloc_f = _av_realloc_fPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// Allocate, reallocate, or free an array.
  ///
  /// If `ptr` is `NULL` and `nmemb` > 0, allocate a new block.
  ///
  /// @param ptr   Pointer to a memory block already allocated with
  /// av_realloc() or `NULL`
  /// @param nmemb Number of elements in the array
  /// @param size  Size of the single element of the array
  ///
  /// @return Pointer to a newly-reallocated block or NULL if the block
  /// cannot be reallocated
  ///
  /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
  /// correctly aligned. The returned pointer must be freed after even if
  /// nmemb is zero.
  /// @see av_reallocp_array()
  ffi.Pointer<ffi.Void> av_realloc_array(
    ffi.Pointer<ffi.Void> ptr,
    int nmemb,
    int size,
  ) {
    return _av_realloc_array(
      ptr,
      nmemb,
      size,
    );
  }

  late final _av_realloc_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('av_realloc_array');
  late final _av_realloc_array = _av_realloc_arrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// Allocate, reallocate an array through a pointer to a pointer.
  ///
  /// If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block.
  ///
  /// @param[in,out] ptr   Pointer to a pointer to a memory block already
  /// allocated with av_realloc(), or a pointer to `NULL`.
  /// The pointer is updated on success, or freed on failure.
  /// @param[in]     nmemb Number of elements
  /// @param[in]     size  Size of the single element
  ///
  /// @return Zero on success, an AVERROR error code on failure
  ///
  /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
  /// correctly aligned. *ptr must be freed after even if nmemb is zero.
  int av_reallocp_array(
    ffi.Pointer<ffi.Void> ptr,
    int nmemb,
    int size,
  ) {
    return _av_reallocp_array(
      ptr,
      nmemb,
      size,
    );
  }

  late final _av_reallocp_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('av_reallocp_array');
  late final _av_reallocp_array = _av_reallocp_arrayPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// Reallocate the given buffer if it is not large enough, otherwise do nothing.
  ///
  /// If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
  ///
  /// If the given buffer is not large enough, and reallocation fails, `NULL` is
  /// returned and `*size` is set to 0, but the original buffer is not changed or
  /// freed.
  ///
  /// A typical use pattern follows:
  ///
  /// @code{.c}
  /// uint8_t *buf = ...;
  /// uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
  /// if (!new_buf) {
  /// // Allocation failed; clean up original buffer
  /// av_freep(&buf);
  /// return AVERROR(ENOMEM);
  /// }
  /// @endcode
  ///
  /// @param[in,out] ptr      Already allocated buffer, or `NULL`
  /// @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is
  /// updated to the new allocated size, in particular 0
  /// in case of failure.
  /// @param[in]     min_size Desired minimal size of buffer `ptr`
  /// @return `ptr` if the buffer is large enough, a pointer to newly reallocated
  /// buffer if the buffer was not large enough, or `NULL` in case of
  /// error
  /// @see av_realloc()
  /// @see av_fast_malloc()
  ffi.Pointer<ffi.Void> av_fast_realloc(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.UnsignedInt> size,
    int min_size,
  ) {
    return _av_fast_realloc(
      ptr,
      size,
      min_size,
    );
  }

  late final _av_fast_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.UnsignedInt>, ffi.Size)>>('av_fast_realloc');
  late final _av_fast_realloc = _av_fast_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Allocate a buffer, reusing the given one if large enough.
  ///
  /// Contrary to av_fast_realloc(), the current buffer contents might not be
  /// preserved and on error the old buffer is freed, thus no special handling to
  /// avoid memleaks is necessary.
  ///
  /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
  /// `size_needed` is greater than 0.
  ///
  /// @code{.c}
  /// uint8_t *buf = ...;
  /// av_fast_malloc(&buf, &current_size, size_needed);
  /// if (!buf) {
  /// // Allocation failed; buf already freed
  /// return AVERROR(ENOMEM);
  /// }
  /// @endcode
  ///
  /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
  /// `*ptr` will be overwritten with pointer to new
  /// buffer on success or `NULL` on failure
  /// @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
  /// updated to the new allocated size, in particular 0
  /// in case of failure.
  /// @param[in]     min_size Desired minimal size of buffer `*ptr`
  /// @see av_realloc()
  /// @see av_fast_mallocz()
  void av_fast_malloc(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.UnsignedInt> size,
    int min_size,
  ) {
    return _av_fast_malloc(
      ptr,
      size,
      min_size,
    );
  }

  late final _av_fast_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Size)>>('av_fast_malloc');
  late final _av_fast_malloc = _av_fast_mallocPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Allocate and clear a buffer, reusing the given one if large enough.
  ///
  /// Like av_fast_malloc(), but all newly allocated space is initially cleared.
  /// Reused buffer is not cleared.
  ///
  /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
  /// `size_needed` is greater than 0.
  ///
  /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
  /// `*ptr` will be overwritten with pointer to new
  /// buffer on success or `NULL` on failure
  /// @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
  /// updated to the new allocated size, in particular 0
  /// in case of failure.
  /// @param[in]     min_size Desired minimal size of buffer `*ptr`
  /// @see av_fast_malloc()
  void av_fast_mallocz(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.UnsignedInt> size,
    int min_size,
  ) {
    return _av_fast_mallocz(
      ptr,
      size,
      min_size,
    );
  }

  late final _av_fast_malloczPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Size)>>('av_fast_mallocz');
  late final _av_fast_mallocz = _av_fast_malloczPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Free a memory block which has been allocated with a function of av_malloc()
  /// or av_realloc() family.
  ///
  /// @param ptr Pointer to the memory block which should be freed.
  ///
  /// @note `ptr = NULL` is explicitly allowed.
  /// @note It is recommended that you use av_freep() instead, to prevent leaving
  /// behind dangling pointers.
  /// @see av_freep()
  void av_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _av_free(
      ptr,
    );
  }

  late final _av_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'av_free');
  late final _av_free =
      _av_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Free a memory block which has been allocated with a function of av_malloc()
  /// or av_realloc() family, and set the pointer pointing to it to `NULL`.
  ///
  /// @code{.c}
  /// uint8_t *buf = av_malloc(16);
  /// av_free(buf);
  /// // buf now contains a dangling pointer to freed memory, and accidental
  /// // dereference of buf will result in a use-after-free, which may be a
  /// // security risk.
  ///
  /// uint8_t *buf = av_malloc(16);
  /// av_freep(&buf);
  /// // buf is now NULL, and accidental dereference will only result in a
  /// // NULL-pointer dereference.
  /// @endcode
  ///
  /// @param ptr Pointer to the pointer to the memory block which should be freed
  /// @note `*ptr = NULL` is safe and leads to no action.
  /// @see av_free()
  void av_freep(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return _av_freep(
      ptr,
    );
  }

  late final _av_freepPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'av_freep');
  late final _av_freep =
      _av_freepPtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Duplicate a string.
  ///
  /// @param s String to be duplicated
  /// @return Pointer to a newly-allocated string containing a
  /// copy of `s` or `NULL` if the string cannot be allocated
  /// @see av_strndup()
  ffi.Pointer<ffi.Char> av_strdup(
    ffi.Pointer<ffi.Char> s,
  ) {
    return _av_strdup(
      s,
    );
  }

  late final _av_strdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('av_strdup');
  late final _av_strdup = _av_strdupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Duplicate a substring of a string.
  ///
  /// @param s   String to be duplicated
  /// @param len Maximum length of the resulting string (not counting the
  /// terminating byte)
  /// @return Pointer to a newly-allocated string containing a
  /// substring of `s` or `NULL` if the string cannot be allocated
  ffi.Pointer<ffi.Char> av_strndup(
    ffi.Pointer<ffi.Char> s,
    int len,
  ) {
    return _av_strndup(
      s,
      len,
    );
  }

  late final _av_strndupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('av_strndup');
  late final _av_strndup = _av_strndupPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Duplicate a buffer with av_malloc().
  ///
  /// @param p    Buffer to be duplicated
  /// @param size Size in bytes of the buffer copied
  /// @return Pointer to a newly allocated buffer containing a
  /// copy of `p` or `NULL` if the buffer cannot be allocated
  ffi.Pointer<ffi.Void> av_memdup(
    ffi.Pointer<ffi.Void> p,
    int size,
  ) {
    return _av_memdup(
      p,
      size,
    );
  }

  late final _av_memdupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('av_memdup');
  late final _av_memdup = _av_memdupPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  /// Overlapping memcpy() implementation.
  ///
  /// @param dst  Destination buffer
  /// @param back Number of bytes back to start copying (i.e. the initial size of
  /// the overlapping window); must be > 0
  /// @param cnt  Number of bytes to copy; must be >= 0
  ///
  /// @note `cnt > back` is valid, this will copy the bytes we just copied,
  /// thus creating a repeating pattern with a period length of `back`.
  void av_memcpy_backptr(
    ffi.Pointer<ffi.Uint8> dst,
    int back,
    int cnt,
  ) {
    return _av_memcpy_backptr(
      dst,
      back,
      cnt,
    );
  }

  late final _av_memcpy_backptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int)>>('av_memcpy_backptr');
  late final _av_memcpy_backptr = _av_memcpy_backptrPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Add the pointer to an element to a dynamic array.
  ///
  /// The array to grow is supposed to be an array of pointers to
  /// structures, and the element to add must be a pointer to an already
  /// allocated structure.
  ///
  /// The array is reallocated when its size reaches powers of 2.
  /// Therefore, the amortized cost of adding an element is constant.
  ///
  /// In case of success, the pointer to the array is updated in order to
  /// point to the new grown array, and the number pointed to by `nb_ptr`
  /// is incremented.
  /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
  /// `*nb_ptr` is set to 0.
  ///
  /// @param[in,out] tab_ptr Pointer to the array to grow
  /// @param[in,out] nb_ptr  Pointer to the number of elements in the array
  /// @param[in]     elem    Element to add
  /// @see av_dynarray_add_nofree(), av_dynarray2_add()
  void av_dynarray_add(
    ffi.Pointer<ffi.Void> tab_ptr,
    ffi.Pointer<ffi.Int> nb_ptr,
    ffi.Pointer<ffi.Void> elem,
  ) {
    return _av_dynarray_add(
      tab_ptr,
      nb_ptr,
      elem,
    );
  }

  late final _av_dynarray_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Void>)>>('av_dynarray_add');
  late final _av_dynarray_add = _av_dynarray_addPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Void>)>();

  /// Add an element to a dynamic array.
  ///
  /// Function has the same functionality as av_dynarray_add(),
  /// but it doesn't free memory on fails. It returns error code
  /// instead and leave current buffer untouched.
  ///
  /// @return >=0 on success, negative otherwise
  /// @see av_dynarray_add(), av_dynarray2_add()
  int av_dynarray_add_nofree(
    ffi.Pointer<ffi.Void> tab_ptr,
    ffi.Pointer<ffi.Int> nb_ptr,
    ffi.Pointer<ffi.Void> elem,
  ) {
    return _av_dynarray_add_nofree(
      tab_ptr,
      nb_ptr,
      elem,
    );
  }

  late final _av_dynarray_add_nofreePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Void>)>>('av_dynarray_add_nofree');
  late final _av_dynarray_add_nofree = _av_dynarray_add_nofreePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Void>)>();

  /// Add an element of size `elem_size` to a dynamic array.
  ///
  /// The array is reallocated when its number of elements reaches powers of 2.
  /// Therefore, the amortized cost of adding an element is constant.
  ///
  /// In case of success, the pointer to the array is updated in order to
  /// point to the new grown array, and the number pointed to by `nb_ptr`
  /// is incremented.
  /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
  /// `*nb_ptr` is set to 0.
  ///
  /// @param[in,out] tab_ptr   Pointer to the array to grow
  /// @param[in,out] nb_ptr    Pointer to the number of elements in the array
  /// @param[in]     elem_size Size in bytes of an element in the array
  /// @param[in]     elem_data Pointer to the data of the element to add. If
  /// `NULL`, the space of the newly added element is
  /// allocated but left uninitialized.
  ///
  /// @return Pointer to the data of the element to copy in the newly allocated
  /// space
  /// @see av_dynarray_add(), av_dynarray_add_nofree()
  ffi.Pointer<ffi.Void> av_dynarray2_add(
    ffi.Pointer<ffi.Pointer<ffi.Void>> tab_ptr,
    ffi.Pointer<ffi.Int> nb_ptr,
    int elem_size,
    ffi.Pointer<ffi.Uint8> elem_data,
  ) {
    return _av_dynarray2_add(
      tab_ptr,
      nb_ptr,
      elem_size,
      elem_data,
    );
  }

  late final _av_dynarray2_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Int>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('av_dynarray2_add');
  late final _av_dynarray2_add = _av_dynarray2_addPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
          ffi.Pointer<ffi.Int>, int, ffi.Pointer<ffi.Uint8>)>();

  /// Multiply two `size_t` values checking for overflow.
  ///
  /// @param[in]  a   Operand of multiplication
  /// @param[in]  b   Operand of multiplication
  /// @param[out] r   Pointer to the result of the operation
  /// @return 0 on success, AVERROR(EINVAL) on overflow
  int av_size_mult(
    int a,
    int b,
    ffi.Pointer<ffi.Size> r,
  ) {
    return _av_size_mult(
      a,
      b,
      r,
    );
  }

  late final _av_size_multPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Size, ffi.Size, ffi.Pointer<ffi.Size>)>>('av_size_mult');
  late final _av_size_mult = _av_size_multPtr
      .asFunction<int Function(int, int, ffi.Pointer<ffi.Size>)>();

  /// Set the maximum size that may be allocated in one block.
  ///
  /// The value specified with this function is effective for all libavutil's @ref
  /// lavu_mem_funcs "heap management functions."
  ///
  /// By default, the max value is defined as `INT_MAX`.
  ///
  /// @param max Value to be set as the new maximum size
  ///
  /// @warning Exercise extreme caution when using this function. Don't touch
  /// this if you do not understand the full consequence of doing so.
  void av_max_alloc(
    int max,
  ) {
    return _av_max_alloc(
      max,
    );
  }

  late final _av_max_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Size)>>('av_max_alloc');
  late final _av_max_alloc = _av_max_allocPtr.asFunction<void Function(int)>();

  int av_log2(
    int v,
  ) {
    return _av_log2(
      v,
    );
  }

  late final _av_log2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>('av_log2');
  late final _av_log2 = _av_log2Ptr.asFunction<int Function(int)>();

  int av_log2_16bit(
    int v,
  ) {
    return _av_log2_16bit(
      v,
    );
  }

  late final _av_log2_16bitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'av_log2_16bit');
  late final _av_log2_16bit = _av_log2_16bitPtr.asFunction<int Function(int)>();

  /// Reduce a fraction.
  ///
  /// This is useful for framerate calculations.
  ///
  /// @param[out] dst_num Destination numerator
  /// @param[out] dst_den Destination denominator
  /// @param[in]      num Source numerator
  /// @param[in]      den Source denominator
  /// @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
  /// @return 1 if the operation is exact, 0 otherwise
  int av_reduce(
    ffi.Pointer<ffi.Int> dst_num,
    ffi.Pointer<ffi.Int> dst_den,
    int num,
    int den,
    int max,
  ) {
    return _av_reduce(
      dst_num,
      dst_den,
      num,
      den,
      max,
    );
  }

  late final _av_reducePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Int64, ffi.Int64, ffi.Int64)>>('av_reduce');
  late final _av_reduce = _av_reducePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, int, int, int)>();

  /// Multiply two rationals.
  /// @param b First rational
  /// @param c Second rational
  /// @return b*c
  AVRational av_mul_q(
    AVRational b,
    AVRational c,
  ) {
    return _av_mul_q(
      b,
      c,
    );
  }

  late final _av_mul_qPtr =
      _lookup<ffi.NativeFunction<AVRational Function(AVRational, AVRational)>>(
          'av_mul_q');
  late final _av_mul_q =
      _av_mul_qPtr.asFunction<AVRational Function(AVRational, AVRational)>();

  /// Divide one rational by another.
  /// @param b First rational
  /// @param c Second rational
  /// @return b/c
  AVRational av_div_q(
    AVRational b,
    AVRational c,
  ) {
    return _av_div_q(
      b,
      c,
    );
  }

  late final _av_div_qPtr =
      _lookup<ffi.NativeFunction<AVRational Function(AVRational, AVRational)>>(
          'av_div_q');
  late final _av_div_q =
      _av_div_qPtr.asFunction<AVRational Function(AVRational, AVRational)>();

  /// Add two rationals.
  /// @param b First rational
  /// @param c Second rational
  /// @return b+c
  AVRational av_add_q(
    AVRational b,
    AVRational c,
  ) {
    return _av_add_q(
      b,
      c,
    );
  }

  late final _av_add_qPtr =
      _lookup<ffi.NativeFunction<AVRational Function(AVRational, AVRational)>>(
          'av_add_q');
  late final _av_add_q =
      _av_add_qPtr.asFunction<AVRational Function(AVRational, AVRational)>();

  /// Subtract one rational from another.
  /// @param b First rational
  /// @param c Second rational
  /// @return b-c
  AVRational av_sub_q(
    AVRational b,
    AVRational c,
  ) {
    return _av_sub_q(
      b,
      c,
    );
  }

  late final _av_sub_qPtr =
      _lookup<ffi.NativeFunction<AVRational Function(AVRational, AVRational)>>(
          'av_sub_q');
  late final _av_sub_q =
      _av_sub_qPtr.asFunction<AVRational Function(AVRational, AVRational)>();

  /// Convert a double precision floating point number to a rational.
  ///
  /// In case of infinity, the returned value is expressed as `{1, 0}` or
  /// `{-1, 0}` depending on the sign.
  ///
  /// In general rational numbers with |num| <= 1<<26 && |den| <= 1<<26
  /// can be recovered exactly from their double representation.
  /// (no exceptions were found within 1B random ones)
  ///
  /// @param d   `double` to convert
  /// @param max Maximum allowed numerator and denominator
  /// @return `d` in AVRational form
  /// @see av_q2d()
  AVRational av_d2q(
    double d,
    int max,
  ) {
    return _av_d2q(
      d,
      max,
    );
  }

  late final _av_d2qPtr =
      _lookup<ffi.NativeFunction<AVRational Function(ffi.Double, ffi.Int)>>(
          'av_d2q');
  late final _av_d2q =
      _av_d2qPtr.asFunction<AVRational Function(double, int)>();

  /// Find which of the two rationals is closer to another rational.
  ///
  /// @param q     Rational to be compared against
  /// @param q1    Rational to be tested
  /// @param q2    Rational to be tested
  /// @return One of the following values:
  /// - 1 if `q1` is nearer to `q` than `q2`
  /// - -1 if `q2` is nearer to `q` than `q1`
  /// - 0 if they have the same distance
  int av_nearer_q(
    AVRational q,
    AVRational q1,
    AVRational q2,
  ) {
    return _av_nearer_q(
      q,
      q1,
      q2,
    );
  }

  late final _av_nearer_qPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(AVRational, AVRational, AVRational)>>('av_nearer_q');
  late final _av_nearer_q = _av_nearer_qPtr
      .asFunction<int Function(AVRational, AVRational, AVRational)>();

  /// Find the value in a list of rationals nearest a given reference rational.
  ///
  /// @param q      Reference rational
  /// @param q_list Array of rationals terminated by `{0, 0}`
  /// @return Index of the nearest value found in the array
  int av_find_nearest_q_idx(
    AVRational q,
    ffi.Pointer<AVRational> q_list,
  ) {
    return _av_find_nearest_q_idx(
      q,
      q_list,
    );
  }

  late final _av_find_nearest_q_idxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              AVRational, ffi.Pointer<AVRational>)>>('av_find_nearest_q_idx');
  late final _av_find_nearest_q_idx = _av_find_nearest_q_idxPtr
      .asFunction<int Function(AVRational, ffi.Pointer<AVRational>)>();

  /// Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point
  /// format.
  ///
  /// @param q Rational to be converted
  /// @return Equivalent floating-point value, expressed as an unsigned 32-bit
  /// integer.
  /// @note The returned value is platform-indepedant.
  int av_q2intfloat(
    AVRational q,
  ) {
    return _av_q2intfloat(
      q,
    );
  }

  late final _av_q2intfloatPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(AVRational)>>(
          'av_q2intfloat');
  late final _av_q2intfloat =
      _av_q2intfloatPtr.asFunction<int Function(AVRational)>();

  /// Return the best rational so that a and b are multiple of it.
  /// If the resulting denominator is larger than max_den, return def.
  AVRational av_gcd_q(
    AVRational a,
    AVRational b,
    int max_den,
    AVRational def,
  ) {
    return _av_gcd_q(
      a,
      b,
      max_den,
      def,
    );
  }

  late final _av_gcd_qPtr = _lookup<
      ffi.NativeFunction<
          AVRational Function(
              AVRational, AVRational, ffi.Int, AVRational)>>('av_gcd_q');
  late final _av_gcd_q = _av_gcd_qPtr.asFunction<
      AVRational Function(AVRational, AVRational, int, AVRational)>();

  /// Compute the greatest common divisor of two integer operands.
  ///
  /// @param a Operand
  /// @param b Operand
  /// @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
  /// if a == 0 and b == 0, returns 0.
  int av_gcd(
    int a,
    int b,
  ) {
    return _av_gcd(
      a,
      b,
    );
  }

  late final _av_gcdPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Int64, ffi.Int64)>>(
          'av_gcd');
  late final _av_gcd = _av_gcdPtr.asFunction<int Function(int, int)>();

  /// Rescale a 64-bit integer with rounding to nearest.
  ///
  /// The operation is mathematically equivalent to `a * b / c`, but writing that
  /// directly can overflow.
  ///
  /// This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
  ///
  /// @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
  int av_rescale(
    int a,
    int b,
    int c,
  ) {
    return _av_rescale(
      a,
      b,
      c,
    );
  }

  late final _av_rescalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Int64, ffi.Int64, ffi.Int64)>>('av_rescale');
  late final _av_rescale =
      _av_rescalePtr.asFunction<int Function(int, int, int)>();

  /// Rescale a 64-bit integer with specified rounding.
  ///
  /// The operation is mathematically equivalent to `a * b / c`, but writing that
  /// directly can overflow, and does not support different rounding methods.
  /// If the result is not representable then INT64_MIN is returned.
  ///
  /// @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
  int av_rescale_rnd(
    int a,
    int b,
    int c,
    AVRounding rnd,
  ) {
    return _av_rescale_rnd(
      a,
      b,
      c,
      rnd.value,
    );
  }

  late final _av_rescale_rndPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Int64, ffi.Int64, ffi.Int64,
              ffi.UnsignedInt)>>('av_rescale_rnd');
  late final _av_rescale_rnd =
      _av_rescale_rndPtr.asFunction<int Function(int, int, int, int)>();

  /// Rescale a 64-bit integer by 2 rational numbers.
  ///
  /// The operation is mathematically equivalent to `a * bq / cq`.
  ///
  /// This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.
  ///
  /// @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()
  int av_rescale_q(
    int a,
    AVRational bq,
    AVRational cq,
  ) {
    return _av_rescale_q(
      a,
      bq,
      cq,
    );
  }

  late final _av_rescale_qPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Int64, AVRational, AVRational)>>('av_rescale_q');
  late final _av_rescale_q =
      _av_rescale_qPtr.asFunction<int Function(int, AVRational, AVRational)>();

  /// Rescale a 64-bit integer by 2 rational numbers with specified rounding.
  ///
  /// The operation is mathematically equivalent to `a * bq / cq`.
  ///
  /// @see av_rescale(), av_rescale_rnd(), av_rescale_q()
  int av_rescale_q_rnd(
    int a,
    AVRational bq,
    AVRational cq,
    AVRounding rnd,
  ) {
    return _av_rescale_q_rnd(
      a,
      bq,
      cq,
      rnd.value,
    );
  }

  late final _av_rescale_q_rndPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Int64, AVRational, AVRational,
              ffi.UnsignedInt)>>('av_rescale_q_rnd');
  late final _av_rescale_q_rnd = _av_rescale_q_rndPtr
      .asFunction<int Function(int, AVRational, AVRational, int)>();

  /// Compare two timestamps each in its own time base.
  ///
  /// @return One of the following values:
  /// - -1 if `ts_a` is before `ts_b`
  /// - 1 if `ts_a` is after `ts_b`
  /// - 0 if they represent the same position
  ///
  /// @warning
  /// The result of the function is undefined if one of the timestamps is outside
  /// the `int64_t` range when represented in the other's timebase.
  int av_compare_ts(
    int ts_a,
    AVRational tb_a,
    int ts_b,
    AVRational tb_b,
  ) {
    return _av_compare_ts(
      ts_a,
      tb_a,
      ts_b,
      tb_b,
    );
  }

  late final _av_compare_tsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int64, AVRational, ffi.Int64, AVRational)>>('av_compare_ts');
  late final _av_compare_ts = _av_compare_tsPtr
      .asFunction<int Function(int, AVRational, int, AVRational)>();

  /// Compare the remainders of two integer operands divided by a common divisor.
  ///
  /// In other words, compare the least significant `log2(mod)` bits of integers
  /// `a` and `b`.
  ///
  /// @code{.c}
  /// av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
  /// av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
  /// @endcode
  ///
  /// @param a Operand
  /// @param b Operand
  /// @param mod Divisor; must be a power of 2
  /// @return
  /// - a negative value if `a % mod < b % mod`
  /// - a positive value if `a % mod > b % mod`
  /// - zero             if `a % mod == b % mod`
  int av_compare_mod(
    int a,
    int b,
    int mod,
  ) {
    return _av_compare_mod(
      a,
      b,
      mod,
    );
  }

  late final _av_compare_modPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Uint64, ffi.Uint64, ffi.Uint64)>>('av_compare_mod');
  late final _av_compare_mod =
      _av_compare_modPtr.asFunction<int Function(int, int, int)>();

  /// Rescale a timestamp while preserving known durations.
  ///
  /// This function is designed to be called per audio packet to scale the input
  /// timestamp to a different time base. Compared to a simple av_rescale_q()
  /// call, this function is robust against possible inconsistent frame durations.
  ///
  /// The `last` parameter is a state variable that must be preserved for all
  /// subsequent calls for the same stream. For the first call, `*last` should be
  /// initialized to #AV_NOPTS_VALUE.
  ///
  /// @param[in]     in_tb    Input time base
  /// @param[in]     in_ts    Input timestamp
  /// @param[in]     fs_tb    Duration time base; typically this is finer-grained
  /// (greater) than `in_tb` and `out_tb`
  /// @param[in]     duration Duration till the next call to this function (i.e.
  /// duration of the current packet/frame)
  /// @param[in,out] last     Pointer to a timestamp expressed in terms of
  /// `fs_tb`, acting as a state variable
  /// @param[in]     out_tb   Output timebase
  /// @return        Timestamp expressed in terms of `out_tb`
  ///
  /// @note In the context of this function, "duration" is in term of samples, not
  /// seconds.
  int av_rescale_delta(
    AVRational in_tb,
    int in_ts,
    AVRational fs_tb,
    int duration,
    ffi.Pointer<ffi.Int64> last,
    AVRational out_tb,
  ) {
    return _av_rescale_delta(
      in_tb,
      in_ts,
      fs_tb,
      duration,
      last,
      out_tb,
    );
  }

  late final _av_rescale_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(AVRational, ffi.Int64, AVRational, ffi.Int,
              ffi.Pointer<ffi.Int64>, AVRational)>>('av_rescale_delta');
  late final _av_rescale_delta = _av_rescale_deltaPtr.asFunction<
      int Function(AVRational, int, AVRational, int, ffi.Pointer<ffi.Int64>,
          AVRational)>();

  /// Add a value to a timestamp.
  ///
  /// This function guarantees that when the same value is repeatly added that
  /// no accumulation of rounding errors occurs.
  ///
  /// @param[in] ts     Input timestamp
  /// @param[in] ts_tb  Input timestamp time base
  /// @param[in] inc    Value to be added
  /// @param[in] inc_tb Time base of `inc`
  int av_add_stable(
    AVRational ts_tb,
    int ts,
    AVRational inc_tb,
    int inc,
  ) {
    return _av_add_stable(
      ts_tb,
      ts,
      inc_tb,
      inc,
    );
  }

  late final _av_add_stablePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              AVRational, ffi.Int64, AVRational, ffi.Int64)>>('av_add_stable');
  late final _av_add_stable = _av_add_stablePtr
      .asFunction<int Function(AVRational, int, AVRational, int)>();

  /// 0th order modified bessel function of the first kind.
  double av_bessel_i0(
    double x,
  ) {
    return _av_bessel_i0(
      x,
    );
  }

  late final _av_bessel_i0Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Double)>>(
          'av_bessel_i0');
  late final _av_bessel_i0 =
      _av_bessel_i0Ptr.asFunction<double Function(double)>();

  /// Send the specified message to the log if the level is less than or equal
  /// to the current av_log_level. By default, all logging messages are sent to
  /// stderr. This behavior can be altered by setting a different logging callback
  /// function.
  /// @see av_log_set_callback
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct or NULL if general log.
  /// @param level The importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant".
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  void av_log(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _av_log(
      avcl,
      level,
      fmt,
    );
  }

  late final _av_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('av_log');
  late final _av_log = _av_logPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  /// Send the specified message to the log once with the initial_level and then with
  /// the subsequent_level. By default, all logging messages are sent to
  /// stderr. This behavior can be altered by setting a different logging callback
  /// function.
  /// @see av_log
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct or NULL if general log.
  /// @param initial_level importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant" for the first occurance.
  /// @param subsequent_level importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant" after the first occurance.
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  /// @param state a variable to keep trak of if a message has already been printed
  /// this must be initialized to 0 before the first use. The same state
  /// must not be accessed by 2 Threads simultaneously.
  void av_log_once(
    ffi.Pointer<ffi.Void> avcl,
    int initial_level,
    int subsequent_level,
    ffi.Pointer<ffi.Int> state,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _av_log_once(
      avcl,
      initial_level,
      subsequent_level,
      state,
      fmt,
    );
  }

  late final _av_log_oncePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>>('av_log_once');
  late final _av_log_once = _av_log_oncePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, int, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>)>();

  /// Send the specified message to the log if the level is less than or equal
  /// to the current av_log_level. By default, all logging messages are sent to
  /// stderr. This behavior can be altered by setting a different logging callback
  /// function.
  /// @see av_log_set_callback
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant".
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  /// @param vl The arguments referenced by the format string.
  void av_vlog(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Char> fmt,
    va_list1 vl,
  ) {
    return _av_vlog(
      avcl,
      level,
      fmt,
      vl,
    );
  }

  late final _av_vlogPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Char>, va_list1)>>('av_vlog');
  late final _av_vlog = _av_vlogPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>, va_list1)>();

  /// Get the current log level
  ///
  /// @see lavu_log_constants
  ///
  /// @return Current log level
  int av_log_get_level() {
    return _av_log_get_level();
  }

  late final _av_log_get_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('av_log_get_level');
  late final _av_log_get_level =
      _av_log_get_levelPtr.asFunction<int Function()>();

  /// Set the log level
  ///
  /// @see lavu_log_constants
  ///
  /// @param level Logging level
  void av_log_set_level(
    int level,
  ) {
    return _av_log_set_level(
      level,
    );
  }

  late final _av_log_set_levelPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'av_log_set_level');
  late final _av_log_set_level =
      _av_log_set_levelPtr.asFunction<void Function(int)>();

  /// Set the logging callback
  ///
  /// @note The callback must be thread safe, even if the application does not use
  /// threads itself as some codecs are multithreaded.
  ///
  /// @see av_log_default_callback
  ///
  /// @param callback A logging function with a compatible signature.
  void av_log_set_callback(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                    ffi.Pointer<ffi.Char>, va_list1)>>
        callback,
  ) {
    return _av_log_set_callback(
      callback,
    );
  }

  late final _av_log_set_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Int,
                          ffi.Pointer<ffi.Char>,
                          va_list1)>>)>>('av_log_set_callback');
  late final _av_log_set_callback = _av_log_set_callbackPtr.asFunction<
      void Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
                      ffi.Pointer<ffi.Char>, va_list1)>>)>();

  /// Default logging callback
  ///
  /// It prints the message to stderr, optionally colorizing it.
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant".
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  /// @param vl The arguments referenced by the format string.
  void av_log_default_callback(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Char> fmt,
    va_list1 vl,
  ) {
    return _av_log_default_callback(
      avcl,
      level,
      fmt,
      vl,
    );
  }

  late final _av_log_default_callbackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Char>, va_list1)>>('av_log_default_callback');
  late final _av_log_default_callback = _av_log_default_callbackPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>, va_list1)>();

  /// Return the context name
  ///
  /// @param  ctx The AVClass context
  ///
  /// @return The AVClass class_name
  ffi.Pointer<ffi.Char> av_default_item_name(
    ffi.Pointer<ffi.Void> ctx,
  ) {
    return _av_default_item_name(
      ctx,
    );
  }

  late final _av_default_item_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Void>)>>('av_default_item_name');
  late final _av_default_item_name = _av_default_item_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Void>)>();

  AVClassCategory av_default_get_category(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    return AVClassCategory.fromValue(_av_default_get_category(
      ptr,
    ));
  }

  late final _av_default_get_categoryPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Void>)>>(
      'av_default_get_category');
  late final _av_default_get_category = _av_default_get_categoryPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// Format a line of log the same way as the default callback.
  /// @param line          buffer to receive the formatted line
  /// @param line_size     size of the buffer
  /// @param print_prefix  used to store whether the prefix must be printed;
  /// must point to a persistent integer initially set to 1
  void av_log_format_line(
    ffi.Pointer<ffi.Void> ptr,
    int level,
    ffi.Pointer<ffi.Char> fmt,
    va_list1 vl,
    ffi.Pointer<ffi.Char> line,
    int line_size,
    ffi.Pointer<ffi.Int> print_prefix,
  ) {
    return _av_log_format_line(
      ptr,
      level,
      fmt,
      vl,
      line,
      line_size,
      print_prefix,
    );
  }

  late final _av_log_format_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              va_list1,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>)>>('av_log_format_line');
  late final _av_log_format_line = _av_log_format_linePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>, va_list1,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Int>)>();

  /// Format a line of log the same way as the default callback.
  /// @param line          buffer to receive the formatted line;
  /// may be NULL if line_size is 0
  /// @param line_size     size of the buffer; at most line_size-1 characters will
  /// be written to the buffer, plus one null terminator
  /// @param print_prefix  used to store whether the prefix must be printed;
  /// must point to a persistent integer initially set to 1
  /// @return Returns a negative value if an error occurred, otherwise returns
  /// the number of characters that would have been written for a
  /// sufficiently large buffer, not including the terminating null
  /// character. If the return value is not less than line_size, it means
  /// that the log message was truncated to fit the buffer.
  int av_log_format_line2(
    ffi.Pointer<ffi.Void> ptr,
    int level,
    ffi.Pointer<ffi.Char> fmt,
    va_list1 vl,
    ffi.Pointer<ffi.Char> line,
    int line_size,
    ffi.Pointer<ffi.Int> print_prefix,
  ) {
    return _av_log_format_line2(
      ptr,
      level,
      fmt,
      vl,
      line,
      line_size,
      print_prefix,
    );
  }

  late final _av_log_format_line2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              va_list1,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>)>>('av_log_format_line2');
  late final _av_log_format_line2 = _av_log_format_line2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>, va_list1,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Int>)>();

  void av_log_set_flags(
    int arg,
  ) {
    return _av_log_set_flags(
      arg,
    );
  }

  late final _av_log_set_flagsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'av_log_set_flags');
  late final _av_log_set_flags =
      _av_log_set_flagsPtr.asFunction<void Function(int)>();

  int av_log_get_flags() {
    return _av_log_get_flags();
  }

  late final _av_log_get_flagsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('av_log_get_flags');
  late final _av_log_get_flags =
      _av_log_get_flagsPtr.asFunction<int Function()>();

  /// Compute the length of an integer list.
  ///
  /// @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
  /// @param term    list terminator (usually 0 or -1)
  /// @param list    pointer to the list
  /// @return  length of the list, in elements, not counting the terminator
  int av_int_list_length_for_size(
    int elsize,
    ffi.Pointer<ffi.Void> list,
    int term,
  ) {
    return _av_int_list_length_for_size(
      elsize,
      list,
      term,
    );
  }

  late final _av_int_list_length_for_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.UnsignedInt, ffi.Pointer<ffi.Void>,
              ffi.Uint64)>>('av_int_list_length_for_size');
  late final _av_int_list_length_for_size = _av_int_list_length_for_sizePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Void>, int)>();

  /// Return the fractional representation of the internal time base.
  AVRational av_get_time_base_q() {
    return _av_get_time_base_q();
  }

  late final _av_get_time_base_qPtr =
      _lookup<ffi.NativeFunction<AVRational Function()>>('av_get_time_base_q');
  late final _av_get_time_base_q =
      _av_get_time_base_qPtr.asFunction<AVRational Function()>();

  /// Fill the provided buffer with a string containing a FourCC (four-character
  /// code) representation.
  ///
  /// @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE
  /// @param fourcc the fourcc to represent
  /// @return the buffer in input
  ffi.Pointer<ffi.Char> av_fourcc_make_string(
    ffi.Pointer<ffi.Char> buf,
    int fourcc,
  ) {
    return _av_fourcc_make_string(
      buf,
      fourcc,
    );
  }

  late final _av_fourcc_make_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Uint32)>>('av_fourcc_make_string');
  late final _av_fourcc_make_string = _av_fourcc_make_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Allocate an AVBuffer of the given size using av_malloc().
  ///
  /// @return an AVBufferRef of given size or NULL when out of memory
  ffi.Pointer<AVBufferRef> av_buffer_alloc(
    int size,
  ) {
    return _av_buffer_alloc(
      size,
    );
  }

  late final _av_buffer_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVBufferRef> Function(ffi.Size)>>(
          'av_buffer_alloc');
  late final _av_buffer_alloc =
      _av_buffer_allocPtr.asFunction<ffi.Pointer<AVBufferRef> Function(int)>();

  /// Same as av_buffer_alloc(), except the returned buffer will be initialized
  /// to zero.
  ffi.Pointer<AVBufferRef> av_buffer_allocz(
    int size,
  ) {
    return _av_buffer_allocz(
      size,
    );
  }

  late final _av_buffer_alloczPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVBufferRef> Function(ffi.Size)>>(
          'av_buffer_allocz');
  late final _av_buffer_allocz =
      _av_buffer_alloczPtr.asFunction<ffi.Pointer<AVBufferRef> Function(int)>();

  /// Create an AVBuffer from an existing array.
  ///
  /// If this function is successful, data is owned by the AVBuffer. The caller may
  /// only access data through the returned AVBufferRef and references derived from
  /// it.
  /// If this function fails, data is left untouched.
  /// @param data   data array
  /// @param size   size of data in bytes
  /// @param free   a callback for freeing this buffer's data
  /// @param opaque parameter to be got for processing or passed to free
  /// @param flags  a combination of AV_BUFFER_FLAG_*
  ///
  /// @return an AVBufferRef referring to data on success, NULL on failure.
  ffi.Pointer<AVBufferRef> av_buffer_create(
    ffi.Pointer<ffi.Uint8> data,
    int size,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(
                    ffi.Pointer<ffi.Void> opaque, ffi.Pointer<ffi.Uint8> data)>>
        free,
    ffi.Pointer<ffi.Void> opaque,
    int flags,
  ) {
    return _av_buffer_create(
      data,
      size,
      free,
      opaque,
      flags,
    );
  }

  late final _av_buffer_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBufferRef> Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> opaque,
                          ffi.Pointer<ffi.Uint8> data)>>,
              ffi.Pointer<ffi.Void>,
              ffi.Int)>>('av_buffer_create');
  late final _av_buffer_create = _av_buffer_createPtr.asFunction<
      ffi.Pointer<AVBufferRef> Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void> opaque,
                      ffi.Pointer<ffi.Uint8> data)>>,
          ffi.Pointer<ffi.Void>,
          int)>();

  /// Default free callback, which calls av_free() on the buffer data.
  /// This function is meant to be passed to av_buffer_create(), not called
  /// directly.
  void av_buffer_default_free(
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.Uint8> data,
  ) {
    return _av_buffer_default_free(
      opaque,
      data,
    );
  }

  late final _av_buffer_default_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Uint8>)>>('av_buffer_default_free');
  late final _av_buffer_default_free = _av_buffer_default_freePtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Uint8>)>();

  /// Create a new reference to an AVBuffer.
  ///
  /// @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
  /// failure.
  ffi.Pointer<AVBufferRef> av_buffer_ref(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    return _av_buffer_ref(
      buf,
    );
  }

  late final _av_buffer_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBufferRef> Function(
              ffi.Pointer<AVBufferRef>)>>('av_buffer_ref');
  late final _av_buffer_ref = _av_buffer_refPtr.asFunction<
      ffi.Pointer<AVBufferRef> Function(ffi.Pointer<AVBufferRef>)>();

  /// Free a given reference and automatically free the buffer if there are no more
  /// references to it.
  ///
  /// @param buf the reference to be freed. The pointer is set to NULL on return.
  void av_buffer_unref(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
  ) {
    return _av_buffer_unref(
      buf,
    );
  }

  late final _av_buffer_unrefPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVBufferRef>>)>>('av_buffer_unref');
  late final _av_buffer_unref = _av_buffer_unrefPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>)>();

  /// @return 1 if the caller may write to the data referred to by buf (which is
  /// true if and only if buf is the only reference to the underlying AVBuffer).
  /// Return 0 otherwise.
  /// A positive answer is valid until av_buffer_ref() is called on buf.
  int av_buffer_is_writable(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    return _av_buffer_is_writable(
      buf,
    );
  }

  late final _av_buffer_is_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVBufferRef>)>>(
          'av_buffer_is_writable');
  late final _av_buffer_is_writable = _av_buffer_is_writablePtr
      .asFunction<int Function(ffi.Pointer<AVBufferRef>)>();

  /// @return the opaque parameter set by av_buffer_create.
  ffi.Pointer<ffi.Void> av_buffer_get_opaque(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    return _av_buffer_get_opaque(
      buf,
    );
  }

  late final _av_buffer_get_opaquePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<AVBufferRef>)>>('av_buffer_get_opaque');
  late final _av_buffer_get_opaque = _av_buffer_get_opaquePtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<AVBufferRef>)>();

  int av_buffer_get_ref_count(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    return _av_buffer_get_ref_count(
      buf,
    );
  }

  late final _av_buffer_get_ref_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVBufferRef>)>>(
          'av_buffer_get_ref_count');
  late final _av_buffer_get_ref_count = _av_buffer_get_ref_countPtr
      .asFunction<int Function(ffi.Pointer<AVBufferRef>)>();

  /// Create a writable reference from a given buffer reference, avoiding data copy
  /// if possible.
  ///
  /// @param buf buffer reference to make writable. On success, buf is either left
  /// untouched, or it is unreferenced and a new writable AVBufferRef is
  /// written in its place. On failure, buf is left untouched.
  /// @return 0 on success, a negative AVERROR on failure.
  int av_buffer_make_writable(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
  ) {
    return _av_buffer_make_writable(
      buf,
    );
  }

  late final _av_buffer_make_writablePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>)>>(
      'av_buffer_make_writable');
  late final _av_buffer_make_writable = _av_buffer_make_writablePtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>)>();

  /// Reallocate a given buffer.
  ///
  /// @param buf  a buffer reference to reallocate. On success, buf will be
  /// unreferenced and a new reference with the required size will be
  /// written in its place. On failure buf will be left untouched. *buf
  /// may be NULL, then a new buffer is allocated.
  /// @param size required new buffer size.
  /// @return 0 on success, a negative AVERROR on failure.
  ///
  /// @note the buffer is actually reallocated with av_realloc() only if it was
  /// initially allocated through av_buffer_realloc(NULL) and there is only one
  /// reference to it (i.e. the one passed to this function). In all other cases
  /// a new buffer is allocated and the data is copied.
  int av_buffer_realloc(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
    int size,
  ) {
    return _av_buffer_realloc(
      buf,
      size,
    );
  }

  late final _av_buffer_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.Size)>>('av_buffer_realloc');
  late final _av_buffer_realloc = _av_buffer_reallocPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>, int)>();

  /// Ensure dst refers to the same data as src.
  ///
  /// When *dst is already equivalent to src, do nothing. Otherwise unreference dst
  /// and replace it with a new reference to src.
  ///
  /// @param dst Pointer to either a valid buffer reference or NULL. On success,
  /// this will point to a buffer reference equivalent to src. On
  /// failure, dst will be left untouched.
  /// @param src A buffer reference to replace dst with. May be NULL, then this
  /// function is equivalent to av_buffer_unref(dst).
  /// @return 0 on success
  /// AVERROR(ENOMEM) on memory allocation failure.
  int av_buffer_replace(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> dst,
    ffi.Pointer<AVBufferRef> src,
  ) {
    return _av_buffer_replace(
      dst,
      src,
    );
  }

  late final _av_buffer_replacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.Pointer<AVBufferRef>)>>('av_buffer_replace');
  late final _av_buffer_replace = _av_buffer_replacePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVBufferRef>>, ffi.Pointer<AVBufferRef>)>();

  /// Allocate and initialize a buffer pool.
  ///
  /// @param size size of each buffer in this pool
  /// @param alloc a function that will be used to allocate new buffers when the
  /// pool is empty. May be NULL, then the default allocator will be used
  /// (av_buffer_alloc()).
  /// @return newly created buffer pool on success, NULL on error.
  ffi.Pointer<AVBufferPool> av_buffer_pool_init(
    int size,
    ffi.Pointer<
            ffi
            .NativeFunction<ffi.Pointer<AVBufferRef> Function(ffi.Size size)>>
        alloc,
  ) {
    return _av_buffer_pool_init(
      size,
      alloc,
    );
  }

  late final _av_buffer_pool_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBufferPool> Function(
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Pointer<AVBufferRef> Function(
                          ffi.Size size)>>)>>('av_buffer_pool_init');
  late final _av_buffer_pool_init = _av_buffer_pool_initPtr.asFunction<
      ffi.Pointer<AVBufferPool> Function(
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<AVBufferRef> Function(ffi.Size size)>>)>();

  /// Allocate and initialize a buffer pool with a more complex allocator.
  ///
  /// @param size size of each buffer in this pool
  /// @param opaque arbitrary user data used by the allocator
  /// @param alloc a function that will be used to allocate new buffers when the
  /// pool is empty. May be NULL, then the default allocator will be
  /// used (av_buffer_alloc()).
  /// @param pool_free a function that will be called immediately before the pool
  /// is freed. I.e. after av_buffer_pool_uninit() is called
  /// by the caller and all the frames are returned to the pool
  /// and freed. It is intended to uninitialize the user opaque
  /// data. May be NULL.
  /// @return newly created buffer pool on success, NULL on error.
  ffi.Pointer<AVBufferPool> av_buffer_pool_init2(
    int size,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Pointer<AVBufferRef> Function(
                    ffi.Pointer<ffi.Void> opaque, ffi.Size size)>>
        alloc,
    ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> opaque)>>
        pool_free,
  ) {
    return _av_buffer_pool_init2(
      size,
      opaque,
      alloc,
      pool_free,
    );
  }

  late final _av_buffer_pool_init2Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVBufferPool> Function(
                  ffi.Size,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Pointer<AVBufferRef> Function(
                              ffi.Pointer<ffi.Void> opaque, ffi.Size size)>>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> opaque)>>)>>(
      'av_buffer_pool_init2');
  late final _av_buffer_pool_init2 = _av_buffer_pool_init2Ptr.asFunction<
      ffi.Pointer<AVBufferPool> Function(
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Pointer<AVBufferRef> Function(
                      ffi.Pointer<ffi.Void> opaque, ffi.Size size)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Pointer<ffi.Void> opaque)>>)>();

  /// Mark the pool as being available for freeing. It will actually be freed only
  /// once all the allocated buffers associated with the pool are released. Thus it
  /// is safe to call this function while some of the allocated buffers are still
  /// in use.
  ///
  /// @param pool pointer to the pool to be freed. It will be set to NULL.
  void av_buffer_pool_uninit(
    ffi.Pointer<ffi.Pointer<AVBufferPool>> pool,
  ) {
    return _av_buffer_pool_uninit(
      pool,
    );
  }

  late final _av_buffer_pool_uninitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVBufferPool>>)>>(
      'av_buffer_pool_uninit');
  late final _av_buffer_pool_uninit = _av_buffer_pool_uninitPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVBufferPool>>)>();

  /// Allocate a new AVBuffer, reusing an old buffer from the pool when available.
  /// This function may be called simultaneously from multiple threads.
  ///
  /// @return a reference to the new buffer on success, NULL on error.
  ffi.Pointer<AVBufferRef> av_buffer_pool_get(
    ffi.Pointer<AVBufferPool> pool,
  ) {
    return _av_buffer_pool_get(
      pool,
    );
  }

  late final _av_buffer_pool_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBufferRef> Function(
              ffi.Pointer<AVBufferPool>)>>('av_buffer_pool_get');
  late final _av_buffer_pool_get = _av_buffer_pool_getPtr.asFunction<
      ffi.Pointer<AVBufferRef> Function(ffi.Pointer<AVBufferPool>)>();

  /// Query the original opaque parameter of an allocated buffer in the pool.
  ///
  /// @param ref a buffer reference to a buffer returned by av_buffer_pool_get.
  /// @return the opaque parameter set by the buffer allocator function of the
  /// buffer pool.
  ///
  /// @note the opaque parameter of ref is used by the buffer pool implementation,
  /// therefore you have to use this function to access the original opaque
  /// parameter of an allocated buffer.
  ffi.Pointer<ffi.Void> av_buffer_pool_buffer_get_opaque(
    ffi.Pointer<AVBufferRef> ref,
  ) {
    return _av_buffer_pool_buffer_get_opaque(
      ref,
    );
  }

  late final _av_buffer_pool_buffer_get_opaquePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<AVBufferRef>)>>('av_buffer_pool_buffer_get_opaque');
  late final _av_buffer_pool_buffer_get_opaque =
      _av_buffer_pool_buffer_get_opaquePtr.asFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<AVBufferRef>)>();

  /// Get a human readable string in an abbreviated form describing a given channel.
  /// This is the inverse function of @ref av_channel_from_string().
  ///
  /// @param buf pre-allocated buffer where to put the generated string
  /// @param buf_size size in bytes of the buffer.
  /// @param channel the AVChannel whose name to get
  /// @return amount of bytes needed to hold the output string, or a negative AVERROR
  /// on failure. If the returned value is bigger than buf_size, then the
  /// string was truncated.
  int av_channel_name(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    AVChannel channel,
  ) {
    return _av_channel_name(
      buf,
      buf_size,
      channel.value,
    );
  }

  late final _av_channel_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Size, ffi.Int)>>('av_channel_name');
  late final _av_channel_name = _av_channel_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// bprint variant of av_channel_name().
  ///
  /// @note the string will be appended to the bprint buffer.
  void av_channel_name_bprint(
    ffi.Pointer<AVBPrint> bp,
    AVChannel channel_id,
  ) {
    return _av_channel_name_bprint(
      bp,
      channel_id.value,
    );
  }

  late final _av_channel_name_bprintPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Int)>>(
      'av_channel_name_bprint');
  late final _av_channel_name_bprint = _av_channel_name_bprintPtr
      .asFunction<void Function(ffi.Pointer<AVBPrint>, int)>();

  /// Get a human readable string describing a given channel.
  ///
  /// @param buf pre-allocated buffer where to put the generated string
  /// @param buf_size size in bytes of the buffer.
  /// @param channel the AVChannel whose description to get
  /// @return amount of bytes needed to hold the output string, or a negative AVERROR
  /// on failure. If the returned value is bigger than buf_size, then the
  /// string was truncated.
  int av_channel_description(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    AVChannel channel,
  ) {
    return _av_channel_description(
      buf,
      buf_size,
      channel.value,
    );
  }

  late final _av_channel_descriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Int)>>('av_channel_description');
  late final _av_channel_description = _av_channel_descriptionPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// bprint variant of av_channel_description().
  ///
  /// @note the string will be appended to the bprint buffer.
  void av_channel_description_bprint(
    ffi.Pointer<AVBPrint> bp,
    AVChannel channel_id,
  ) {
    return _av_channel_description_bprint(
      bp,
      channel_id.value,
    );
  }

  late final _av_channel_description_bprintPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Int)>>(
      'av_channel_description_bprint');
  late final _av_channel_description_bprint = _av_channel_description_bprintPtr
      .asFunction<void Function(ffi.Pointer<AVBPrint>, int)>();

  /// This is the inverse function of @ref av_channel_name().
  ///
  /// @return the channel with the given name
  /// AV_CHAN_NONE when name does not identify a known channel
  AVChannel av_channel_from_string(
    ffi.Pointer<ffi.Char> name,
  ) {
    return AVChannel.fromValue(_av_channel_from_string(
      name,
    ));
  }

  late final _av_channel_from_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_channel_from_string');
  late final _av_channel_from_string = _av_channel_from_stringPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Initialize a custom channel layout with the specified number of channels.
  /// The channel map will be allocated and the designation of all channels will
  /// be set to AV_CHAN_UNKNOWN.
  ///
  /// This is only a convenience helper function, a custom channel layout can also
  /// be constructed without using this.
  ///
  /// @param channel_layout the layout structure to be initialized
  /// @param nb_channels the number of channels
  ///
  /// @return 0 on success
  /// AVERROR(EINVAL) if the number of channels <= 0
  /// AVERROR(ENOMEM) if the channel map could not be allocated
  int av_channel_layout_custom_init(
    ffi.Pointer<AVChannelLayout> channel_layout,
    int nb_channels,
  ) {
    return _av_channel_layout_custom_init(
      channel_layout,
      nb_channels,
    );
  }

  late final _av_channel_layout_custom_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Int)>>('av_channel_layout_custom_init');
  late final _av_channel_layout_custom_init = _av_channel_layout_custom_initPtr
      .asFunction<int Function(ffi.Pointer<AVChannelLayout>, int)>();

  /// Initialize a native channel layout from a bitmask indicating which channels
  /// are present.
  ///
  /// @param channel_layout the layout structure to be initialized
  /// @param mask bitmask describing the channel layout
  ///
  /// @return 0 on success
  /// AVERROR(EINVAL) for invalid mask values
  int av_channel_layout_from_mask(
    ffi.Pointer<AVChannelLayout> channel_layout,
    int mask,
  ) {
    return _av_channel_layout_from_mask(
      channel_layout,
      mask,
    );
  }

  late final _av_channel_layout_from_maskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Uint64)>>('av_channel_layout_from_mask');
  late final _av_channel_layout_from_mask = _av_channel_layout_from_maskPtr
      .asFunction<int Function(ffi.Pointer<AVChannelLayout>, int)>();

  /// Initialize a channel layout from a given string description.
  /// The input string can be represented by:
  /// - the formal channel layout name (returned by av_channel_layout_describe())
  /// - single or multiple channel names (returned by av_channel_name(), eg. "FL",
  /// or concatenated with "+", each optionally containing a custom name after
  /// a "@", eg. "FL@Left+FR@Right+LFE")
  /// - a decimal or hexadecimal value of a native channel layout (eg. "4" or "0x4")
  /// - the number of channels with default layout (eg. "4c")
  /// - the number of unordered channels (eg. "4C" or "4 channels")
  /// - the ambisonic order followed by optional non-diegetic channels (eg.
  /// "ambisonic 2+stereo")
  /// On error, the channel layout will remain uninitialized, but not necessarily
  /// untouched.
  ///
  /// @param channel_layout uninitialized channel layout for the result
  /// @param str string describing the channel layout
  /// @return 0 on success parsing the channel layout
  /// AVERROR(EINVAL) if an invalid channel layout string was provided
  /// AVERROR(ENOMEM) if there was not enough memory
  int av_channel_layout_from_string(
    ffi.Pointer<AVChannelLayout> channel_layout,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _av_channel_layout_from_string(
      channel_layout,
      str,
    );
  }

  late final _av_channel_layout_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<ffi.Char>)>>('av_channel_layout_from_string');
  late final _av_channel_layout_from_string =
      _av_channel_layout_from_stringPtr.asFunction<
          int Function(ffi.Pointer<AVChannelLayout>, ffi.Pointer<ffi.Char>)>();

  /// Get the default channel layout for a given number of channels.
  ///
  /// @param ch_layout the layout structure to be initialized
  /// @param nb_channels number of channels
  void av_channel_layout_default(
    ffi.Pointer<AVChannelLayout> ch_layout,
    int nb_channels,
  ) {
    return _av_channel_layout_default(
      ch_layout,
      nb_channels,
    );
  }

  late final _av_channel_layout_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVChannelLayout>,
              ffi.Int)>>('av_channel_layout_default');
  late final _av_channel_layout_default = _av_channel_layout_defaultPtr
      .asFunction<void Function(ffi.Pointer<AVChannelLayout>, int)>();

  /// Iterate over all standard channel layouts.
  ///
  /// @param opaque a pointer where libavutil will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the standard channel layout or NULL when the iteration is
  /// finished
  ffi.Pointer<AVChannelLayout> av_channel_layout_standard(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_channel_layout_standard(
      opaque,
    );
  }

  late final _av_channel_layout_standardPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVChannelLayout> Function(
                  ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'av_channel_layout_standard');
  late final _av_channel_layout_standard =
      _av_channel_layout_standardPtr.asFunction<
          ffi.Pointer<AVChannelLayout> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Free any allocated data in the channel layout and reset the channel
  /// count to 0.
  ///
  /// @param channel_layout the layout structure to be uninitialized
  void av_channel_layout_uninit(
    ffi.Pointer<AVChannelLayout> channel_layout,
  ) {
    return _av_channel_layout_uninit(
      channel_layout,
    );
  }

  late final _av_channel_layout_uninitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVChannelLayout>)>>(
      'av_channel_layout_uninit');
  late final _av_channel_layout_uninit = _av_channel_layout_uninitPtr
      .asFunction<void Function(ffi.Pointer<AVChannelLayout>)>();

  /// Make a copy of a channel layout. This differs from just assigning src to dst
  /// in that it allocates and copies the map for AV_CHANNEL_ORDER_CUSTOM.
  ///
  /// @note the destination channel_layout will be always uninitialized before copy.
  ///
  /// @param dst destination channel layout
  /// @param src source channel layout
  /// @return 0 on success, a negative AVERROR on error.
  int av_channel_layout_copy(
    ffi.Pointer<AVChannelLayout> dst,
    ffi.Pointer<AVChannelLayout> src,
  ) {
    return _av_channel_layout_copy(
      dst,
      src,
    );
  }

  late final _av_channel_layout_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<AVChannelLayout>)>>('av_channel_layout_copy');
  late final _av_channel_layout_copy = _av_channel_layout_copyPtr.asFunction<
      int Function(
          ffi.Pointer<AVChannelLayout>, ffi.Pointer<AVChannelLayout>)>();

  /// Get a human-readable string describing the channel layout properties.
  /// The string will be in the same format that is accepted by
  /// @ref av_channel_layout_from_string(), allowing to rebuild the same
  /// channel layout, except for opaque pointers.
  ///
  /// @param channel_layout channel layout to be described
  /// @param buf pre-allocated buffer where to put the generated string
  /// @param buf_size size in bytes of the buffer.
  /// @return amount of bytes needed to hold the output string, or a negative AVERROR
  /// on failure. If the returned value is bigger than buf_size, then the
  /// string was truncated.
  int av_channel_layout_describe(
    ffi.Pointer<AVChannelLayout> channel_layout,
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
  ) {
    return _av_channel_layout_describe(
      channel_layout,
      buf,
      buf_size,
    );
  }

  late final _av_channel_layout_describePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('av_channel_layout_describe');
  late final _av_channel_layout_describe =
      _av_channel_layout_describePtr.asFunction<
          int Function(
              ffi.Pointer<AVChannelLayout>, ffi.Pointer<ffi.Char>, int)>();

  /// bprint variant of av_channel_layout_describe().
  ///
  /// @note the string will be appended to the bprint buffer.
  /// @return 0 on success, or a negative AVERROR value on failure.
  int av_channel_layout_describe_bprint(
    ffi.Pointer<AVChannelLayout> channel_layout,
    ffi.Pointer<AVBPrint> bp,
  ) {
    return _av_channel_layout_describe_bprint(
      channel_layout,
      bp,
    );
  }

  late final _av_channel_layout_describe_bprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<AVBPrint>)>>('av_channel_layout_describe_bprint');
  late final _av_channel_layout_describe_bprint =
      _av_channel_layout_describe_bprintPtr.asFunction<
          int Function(ffi.Pointer<AVChannelLayout>, ffi.Pointer<AVBPrint>)>();

  /// Get the channel with the given index in a channel layout.
  ///
  /// @param channel_layout input channel layout
  /// @param idx index of the channel
  /// @return channel with the index idx in channel_layout on success or
  /// AV_CHAN_NONE on failure (if idx is not valid or the channel order is
  /// unspecified)
  AVChannel av_channel_layout_channel_from_index(
    ffi.Pointer<AVChannelLayout> channel_layout,
    int idx,
  ) {
    return AVChannel.fromValue(_av_channel_layout_channel_from_index(
      channel_layout,
      idx,
    ));
  }

  late final _av_channel_layout_channel_from_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.UnsignedInt)>>('av_channel_layout_channel_from_index');
  late final _av_channel_layout_channel_from_index =
      _av_channel_layout_channel_from_indexPtr
          .asFunction<int Function(ffi.Pointer<AVChannelLayout>, int)>();

  /// Get the index of a given channel in a channel layout. In case multiple
  /// channels are found, only the first match will be returned.
  ///
  /// @param channel_layout input channel layout
  /// @param channel the channel whose index to obtain
  /// @return index of channel in channel_layout on success or a negative number if
  /// channel is not present in channel_layout.
  int av_channel_layout_index_from_channel(
    ffi.Pointer<AVChannelLayout> channel_layout,
    AVChannel channel,
  ) {
    return _av_channel_layout_index_from_channel(
      channel_layout,
      channel.value,
    );
  }

  late final _av_channel_layout_index_from_channelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Int)>>('av_channel_layout_index_from_channel');
  late final _av_channel_layout_index_from_channel =
      _av_channel_layout_index_from_channelPtr
          .asFunction<int Function(ffi.Pointer<AVChannelLayout>, int)>();

  /// Get the index in a channel layout of a channel described by the given string.
  /// In case multiple channels are found, only the first match will be returned.
  ///
  /// This function accepts channel names in the same format as
  /// @ref av_channel_from_string().
  ///
  /// @param channel_layout input channel layout
  /// @param name string describing the channel whose index to obtain
  /// @return a channel index described by the given string, or a negative AVERROR
  /// value.
  int av_channel_layout_index_from_string(
    ffi.Pointer<AVChannelLayout> channel_layout,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_channel_layout_index_from_string(
      channel_layout,
      name,
    );
  }

  late final _av_channel_layout_index_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<ffi.Char>)>>('av_channel_layout_index_from_string');
  late final _av_channel_layout_index_from_string =
      _av_channel_layout_index_from_stringPtr.asFunction<
          int Function(ffi.Pointer<AVChannelLayout>, ffi.Pointer<ffi.Char>)>();

  /// Get a channel described by the given string.
  ///
  /// This function accepts channel names in the same format as
  /// @ref av_channel_from_string().
  ///
  /// @param channel_layout input channel layout
  /// @param name string describing the channel to obtain
  /// @return a channel described by the given string in channel_layout on success
  /// or AV_CHAN_NONE on failure (if the string is not valid or the channel
  /// order is unspecified)
  AVChannel av_channel_layout_channel_from_string(
    ffi.Pointer<AVChannelLayout> channel_layout,
    ffi.Pointer<ffi.Char> name,
  ) {
    return AVChannel.fromValue(_av_channel_layout_channel_from_string(
      channel_layout,
      name,
    ));
  }

  late final _av_channel_layout_channel_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<ffi.Char>)>>('av_channel_layout_channel_from_string');
  late final _av_channel_layout_channel_from_string =
      _av_channel_layout_channel_from_stringPtr.asFunction<
          int Function(ffi.Pointer<AVChannelLayout>, ffi.Pointer<ffi.Char>)>();

  /// Find out what channels from a given set are present in a channel layout,
  /// without regard for their positions.
  ///
  /// @param channel_layout input channel layout
  /// @param mask a combination of AV_CH_* representing a set of channels
  /// @return a bitfield representing all the channels from mask that are present
  /// in channel_layout
  int av_channel_layout_subset(
    ffi.Pointer<AVChannelLayout> channel_layout,
    int mask,
  ) {
    return _av_channel_layout_subset(
      channel_layout,
      mask,
    );
  }

  late final _av_channel_layout_subsetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<AVChannelLayout>,
              ffi.Uint64)>>('av_channel_layout_subset');
  late final _av_channel_layout_subset = _av_channel_layout_subsetPtr
      .asFunction<int Function(ffi.Pointer<AVChannelLayout>, int)>();

  /// Check whether a channel layout is valid, i.e. can possibly describe audio
  /// data.
  ///
  /// @param channel_layout input channel layout
  /// @return 1 if channel_layout is valid, 0 otherwise.
  int av_channel_layout_check(
    ffi.Pointer<AVChannelLayout> channel_layout,
  ) {
    return _av_channel_layout_check(
      channel_layout,
    );
  }

  late final _av_channel_layout_checkPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVChannelLayout>)>>(
      'av_channel_layout_check');
  late final _av_channel_layout_check = _av_channel_layout_checkPtr
      .asFunction<int Function(ffi.Pointer<AVChannelLayout>)>();

  /// Check whether two channel layouts are semantically the same, i.e. the same
  /// channels are present on the same positions in both.
  ///
  /// If one of the channel layouts is AV_CHANNEL_ORDER_UNSPEC, while the other is
  /// not, they are considered to be unequal. If both are AV_CHANNEL_ORDER_UNSPEC,
  /// they are considered equal iff the channel counts are the same in both.
  ///
  /// @param chl input channel layout
  /// @param chl1 input channel layout
  /// @return 0 if chl and chl1 are equal, 1 if they are not equal. A negative
  /// AVERROR code if one or both are invalid.
  int av_channel_layout_compare(
    ffi.Pointer<AVChannelLayout> chl,
    ffi.Pointer<AVChannelLayout> chl1,
  ) {
    return _av_channel_layout_compare(
      chl,
      chl1,
    );
  }

  late final _av_channel_layout_comparePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<AVChannelLayout>)>>('av_channel_layout_compare');
  late final _av_channel_layout_compare =
      _av_channel_layout_comparePtr.asFunction<
          int Function(
              ffi.Pointer<AVChannelLayout>, ffi.Pointer<AVChannelLayout>)>();

  /// Return the order if the layout is n-th order standard-order ambisonic.
  /// The presence of optional extra non-diegetic channels at the end is not taken
  /// into account.
  ///
  /// @param channel_layout input channel layout
  /// @return the order of the layout, a negative error code otherwise.
  int av_channel_layout_ambisonic_order(
    ffi.Pointer<AVChannelLayout> channel_layout,
  ) {
    return _av_channel_layout_ambisonic_order(
      channel_layout,
    );
  }

  late final _av_channel_layout_ambisonic_orderPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVChannelLayout>)>>(
      'av_channel_layout_ambisonic_order');
  late final _av_channel_layout_ambisonic_order =
      _av_channel_layout_ambisonic_orderPtr
          .asFunction<int Function(ffi.Pointer<AVChannelLayout>)>();

  /// Change the AVChannelOrder of a channel layout.
  ///
  /// Change of AVChannelOrder can be either lossless or lossy. In case of a
  /// lossless conversion all the channel designations and the associated channel
  /// names (if any) are kept. On a lossy conversion the channel names and channel
  /// designations might be lost depending on the capabilities of the desired
  /// AVChannelOrder. Note that some conversions are simply not possible in which
  /// case this function returns AVERROR(ENOSYS).
  ///
  /// The following conversions are supported:
  ///
  /// Any       -> Custom     : Always possible, always lossless.
  /// Any       -> Unspecified: Always possible, lossless if channel designations
  /// are all unknown and channel names are not used, lossy otherwise.
  /// Custom    -> Ambisonic  : Possible if it contains ambisonic channels with
  /// optional non-diegetic channels in the end. Lossy if the channels have
  /// custom names, lossless otherwise.
  /// Custom    -> Native     : Possible if it contains native channels in native
  /// order. Lossy if the channels have custom names, lossless otherwise.
  ///
  /// On error this function keeps the original channel layout untouched.
  ///
  /// @param channel_layout channel layout which will be changed
  /// @param order the desired channel layout order
  /// @param flags a combination of AV_CHANNEL_LAYOUT_RETYPE_FLAG_* constants
  /// @return 0 if the conversion was successful and lossless or if the channel
  /// layout was already in the desired order
  /// >0 if the conversion was successful but lossy
  /// AVERROR(ENOSYS) if the conversion was not possible (or would be
  /// lossy and AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS was specified)
  /// AVERROR(EINVAL), AVERROR(ENOMEM) on error
  int av_channel_layout_retype(
    ffi.Pointer<AVChannelLayout> channel_layout,
    AVChannelOrder order,
    int flags,
  ) {
    return _av_channel_layout_retype(
      channel_layout,
      order.value,
      flags,
    );
  }

  late final _av_channel_layout_retypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVChannelLayout>, ffi.UnsignedInt,
              ffi.Int)>>('av_channel_layout_retype');
  late final _av_channel_layout_retype = _av_channel_layout_retypePtr
      .asFunction<int Function(ffi.Pointer<AVChannelLayout>, int, int)>();

  /// Get a dictionary entry with matching key.
  ///
  /// The returned entry key or value must not be changed, or it will
  /// cause undefined behavior.
  ///
  /// @param prev  Set to the previous matching element to find the next.
  /// If set to NULL the first matching element is returned.
  /// @param key   Matching key
  /// @param flags A collection of AV_DICT_* flags controlling how the
  /// entry is retrieved
  ///
  /// @return      Found entry or NULL in case no matching entry was found in the dictionary
  ffi.Pointer<AVDictionaryEntry> av_dict_get(
    ffi.Pointer<AVDictionary> m,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<AVDictionaryEntry> prev,
    int flags,
  ) {
    return _av_dict_get(
      m,
      key,
      prev,
      flags,
    );
  }

  late final _av_dict_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDictionaryEntry> Function(
              ffi.Pointer<AVDictionary>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVDictionaryEntry>,
              ffi.Int)>>('av_dict_get');
  late final _av_dict_get = _av_dict_getPtr.asFunction<
      ffi.Pointer<AVDictionaryEntry> Function(ffi.Pointer<AVDictionary>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<AVDictionaryEntry>, int)>();

  /// Iterate over a dictionary
  ///
  /// Iterates through all entries in the dictionary.
  ///
  /// @warning The returned AVDictionaryEntry key/value must not be changed.
  ///
  /// @warning As av_dict_set() invalidates all previous entries returned
  /// by this function, it must not be called while iterating over the dict.
  ///
  /// Typical usage:
  /// @code
  /// const AVDictionaryEntry *e = NULL;
  /// while ((e = av_dict_iterate(m, e))) {
  /// // ...
  /// }
  /// @endcode
  ///
  /// @param m     The dictionary to iterate over
  /// @param prev  Pointer to the previous AVDictionaryEntry, NULL initially
  ///
  /// @retval AVDictionaryEntry* The next element in the dictionary
  /// @retval NULL               No more elements in the dictionary
  ffi.Pointer<AVDictionaryEntry> av_dict_iterate(
    ffi.Pointer<AVDictionary> m,
    ffi.Pointer<AVDictionaryEntry> prev,
  ) {
    return _av_dict_iterate(
      m,
      prev,
    );
  }

  late final _av_dict_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDictionaryEntry> Function(ffi.Pointer<AVDictionary>,
              ffi.Pointer<AVDictionaryEntry>)>>('av_dict_iterate');
  late final _av_dict_iterate = _av_dict_iteratePtr.asFunction<
      ffi.Pointer<AVDictionaryEntry> Function(
          ffi.Pointer<AVDictionary>, ffi.Pointer<AVDictionaryEntry>)>();

  /// Get number of entries in dictionary.
  ///
  /// @param m dictionary
  /// @return  number of entries in dictionary
  int av_dict_count(
    ffi.Pointer<AVDictionary> m,
  ) {
    return _av_dict_count(
      m,
    );
  }

  late final _av_dict_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVDictionary>)>>(
          'av_dict_count');
  late final _av_dict_count =
      _av_dict_countPtr.asFunction<int Function(ffi.Pointer<AVDictionary>)>();

  /// Set the given entry in *pm, overwriting an existing entry.
  ///
  /// Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
  /// these arguments will be freed on error.
  ///
  /// @warning Adding a new entry to a dictionary invalidates all existing entries
  /// previously returned with av_dict_get() or av_dict_iterate().
  ///
  /// @param pm        Pointer to a pointer to a dictionary struct. If *pm is NULL
  /// a dictionary struct is allocated and put in *pm.
  /// @param key       Entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
  /// @param value     Entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
  /// Passing a NULL value will cause an existing entry to be deleted.
  ///
  /// @return          >= 0 on success otherwise an error code <0
  int av_dict_set(
    ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
    ffi.Pointer<ffi.Char> key,
    ffi.Pointer<ffi.Char> value,
    int flags,
  ) {
    return _av_dict_set(
      pm,
      key,
      value,
      flags,
    );
  }

  late final _av_dict_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVDictionary>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_dict_set');
  late final _av_dict_set = _av_dict_setPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVDictionary>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Convenience wrapper for av_dict_set() that converts the value to a string
  /// and stores it.
  ///
  /// Note: If ::AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
  int av_dict_set_int(
    ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
    ffi.Pointer<ffi.Char> key,
    int value,
    int flags,
  ) {
    return _av_dict_set_int(
      pm,
      key,
      value,
      flags,
    );
  }

  late final _av_dict_set_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVDictionary>>,
              ffi.Pointer<ffi.Char>, ffi.Int64, ffi.Int)>>('av_dict_set_int');
  late final _av_dict_set_int = _av_dict_set_intPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVDictionary>>,
          ffi.Pointer<ffi.Char>, int, int)>();

  /// Parse the key/value pairs list and add the parsed entries to a dictionary.
  ///
  /// In case of failure, all the successfully set entries are stored in
  /// *pm. You may need to manually free the created dictionary.
  ///
  /// @param key_val_sep  A 0-terminated list of characters used to separate
  /// key from value
  /// @param pairs_sep    A 0-terminated list of characters used to separate
  /// two pairs from each other
  /// @param flags        Flags to use when adding to the dictionary.
  /// ::AV_DICT_DONT_STRDUP_KEY and ::AV_DICT_DONT_STRDUP_VAL
  /// are ignored since the key/value tokens will always
  /// be duplicated.
  ///
  /// @return             0 on success, negative AVERROR code on failure
  int av_dict_parse_string(
    ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> key_val_sep,
    ffi.Pointer<ffi.Char> pairs_sep,
    int flags,
  ) {
    return _av_dict_parse_string(
      pm,
      str,
      key_val_sep,
      pairs_sep,
      flags,
    );
  }

  late final _av_dict_parse_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVDictionary>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_dict_parse_string');
  late final _av_dict_parse_string = _av_dict_parse_stringPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVDictionary>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Copy entries from one AVDictionary struct into another.
  ///
  /// @note Metadata is read using the ::AV_DICT_IGNORE_SUFFIX flag
  ///
  /// @param dst   Pointer to a pointer to a AVDictionary struct to copy into. If *dst is NULL,
  /// this function will allocate a struct for you and put it in *dst
  /// @param src   Pointer to the source AVDictionary struct to copy items from.
  /// @param flags Flags to use when setting entries in *dst
  ///
  /// @return 0 on success, negative AVERROR code on failure. If dst was allocated
  /// by this function, callers should free the associated memory.
  int av_dict_copy(
    ffi.Pointer<ffi.Pointer<AVDictionary>> dst,
    ffi.Pointer<AVDictionary> src,
    int flags,
  ) {
    return _av_dict_copy(
      dst,
      src,
      flags,
    );
  }

  late final _av_dict_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVDictionary>>,
              ffi.Pointer<AVDictionary>, ffi.Int)>>('av_dict_copy');
  late final _av_dict_copy = _av_dict_copyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVDictionary>>,
          ffi.Pointer<AVDictionary>, int)>();

  /// Free all the memory allocated for an AVDictionary struct
  /// and all keys and values.
  void av_dict_free(
    ffi.Pointer<ffi.Pointer<AVDictionary>> m,
  ) {
    return _av_dict_free(
      m,
    );
  }

  late final _av_dict_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('av_dict_free');
  late final _av_dict_free = _av_dict_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Get dictionary entries as a string.
  ///
  /// Create a string containing dictionary's entries.
  /// Such string may be passed back to av_dict_parse_string().
  /// @note String is escaped with backslashes ('\').
  ///
  /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
  ///
  /// @param[in]  m             The dictionary
  /// @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.
  /// Buffer must be freed by the caller when is no longer needed.
  /// @param[in]  key_val_sep   Character used to separate key from value
  /// @param[in]  pairs_sep     Character used to separate two pairs from each other
  ///
  /// @return                   >= 0 on success, negative on error
  int av_dict_get_string(
    ffi.Pointer<AVDictionary> m,
    ffi.Pointer<ffi.Pointer<ffi.Char>> buffer,
    int key_val_sep,
    int pairs_sep,
  ) {
    return _av_dict_get_string(
      m,
      buffer,
      key_val_sep,
      pairs_sep,
    );
  }

  late final _av_dict_get_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVDictionary>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Char,
              ffi.Char)>>('av_dict_get_string');
  late final _av_dict_get_string = _av_dict_get_stringPtr.asFunction<
      int Function(ffi.Pointer<AVDictionary>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, int, int)>();

  /// Allocate an AVFrame and set its fields to default values.  The resulting
  /// struct must be freed using av_frame_free().
  ///
  /// @return An AVFrame filled with default values or NULL on failure.
  ///
  /// @note this only allocates the AVFrame itself, not the data buffers. Those
  /// must be allocated through other means, e.g. with av_frame_get_buffer() or
  /// manually.
  ffi.Pointer<AVFrame> av_frame_alloc() {
    return _av_frame_alloc();
  }

  late final _av_frame_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVFrame> Function()>>(
          'av_frame_alloc');
  late final _av_frame_alloc =
      _av_frame_allocPtr.asFunction<ffi.Pointer<AVFrame> Function()>();

  /// Free the frame and any dynamically allocated objects in it,
  /// e.g. extended_data. If the frame is reference counted, it will be
  /// unreferenced first.
  ///
  /// @param frame frame to be freed. The pointer will be set to NULL.
  void av_frame_free(
    ffi.Pointer<ffi.Pointer<AVFrame>> frame,
  ) {
    return _av_frame_free(
      frame,
    );
  }

  late final _av_frame_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVFrame>>)>>('av_frame_free');
  late final _av_frame_free = _av_frame_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVFrame>>)>();

  /// Set up a new reference to the data described by the source frame.
  ///
  /// Copy frame properties from src to dst and create a new reference for each
  /// AVBufferRef from src.
  ///
  /// If src is not reference counted, new buffers are allocated and the data is
  /// copied.
  ///
  /// @warning: dst MUST have been either unreferenced with av_frame_unref(dst),
  /// or newly allocated with av_frame_alloc() before calling this
  /// function, or undefined behavior will occur.
  ///
  /// @return 0 on success, a negative AVERROR on error
  int av_frame_ref(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _av_frame_ref(
      dst,
      src,
    );
  }

  late final _av_frame_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>>('av_frame_ref');
  late final _av_frame_ref = _av_frame_refPtr
      .asFunction<int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>();

  /// Ensure the destination frame refers to the same data described by the source
  /// frame, either by creating a new reference for each AVBufferRef from src if
  /// they differ from those in dst, by allocating new buffers and copying data if
  /// src is not reference counted, or by unrefencing it if src is empty.
  ///
  /// Frame properties on dst will be replaced by those from src.
  ///
  /// @return 0 on success, a negative AVERROR on error. On error, dst is
  /// unreferenced.
  int av_frame_replace(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _av_frame_replace(
      dst,
      src,
    );
  }

  late final _av_frame_replacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>>('av_frame_replace');
  late final _av_frame_replace = _av_frame_replacePtr
      .asFunction<int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>();

  /// Create a new frame that references the same data as src.
  ///
  /// This is a shortcut for av_frame_alloc()+av_frame_ref().
  ///
  /// @return newly created AVFrame on success, NULL on error.
  ffi.Pointer<AVFrame> av_frame_clone(
    ffi.Pointer<AVFrame> src,
  ) {
    return _av_frame_clone(
      src,
    );
  }

  late final _av_frame_clonePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<AVFrame> Function(ffi.Pointer<AVFrame>)>>(
      'av_frame_clone');
  late final _av_frame_clone = _av_frame_clonePtr
      .asFunction<ffi.Pointer<AVFrame> Function(ffi.Pointer<AVFrame>)>();

  /// Unreference all the buffers referenced by frame and reset the frame fields.
  void av_frame_unref(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_frame_unref(
      frame,
    );
  }

  late final _av_frame_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFrame>)>>(
          'av_frame_unref');
  late final _av_frame_unref =
      _av_frame_unrefPtr.asFunction<void Function(ffi.Pointer<AVFrame>)>();

  /// Move everything contained in src to dst and reset src.
  ///
  /// @warning: dst is not unreferenced, but directly overwritten without reading
  /// or deallocating its contents. Call av_frame_unref(dst) manually
  /// before calling this function to ensure that no memory is leaked.
  void av_frame_move_ref(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _av_frame_move_ref(
      dst,
      src,
    );
  }

  late final _av_frame_move_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVFrame>,
              ffi.Pointer<AVFrame>)>>('av_frame_move_ref');
  late final _av_frame_move_ref = _av_frame_move_refPtr
      .asFunction<void Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>();

  /// Allocate new buffer(s) for audio or video data.
  ///
  /// The following fields must be set on frame before calling this function:
  /// - format (pixel format for video, sample format for audio)
  /// - width and height for video
  /// - nb_samples and ch_layout for audio
  ///
  /// This function will fill AVFrame.data and AVFrame.buf arrays and, if
  /// necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
  /// For planar formats, one buffer will be allocated for each plane.
  ///
  /// @warning: if frame already has been allocated, calling this function will
  /// leak memory. In addition, undefined behavior can occur in certain
  /// cases.
  ///
  /// @param frame frame in which to store the new buffers.
  /// @param align Required buffer size alignment. If equal to 0, alignment will be
  /// chosen automatically for the current CPU. It is highly
  /// recommended to pass 0 here unless you know what you are doing.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  int av_frame_get_buffer(
    ffi.Pointer<AVFrame> frame,
    int align,
  ) {
    return _av_frame_get_buffer(
      frame,
      align,
    );
  }

  late final _av_frame_get_bufferPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFrame>, ffi.Int)>>(
      'av_frame_get_buffer');
  late final _av_frame_get_buffer = _av_frame_get_bufferPtr
      .asFunction<int Function(ffi.Pointer<AVFrame>, int)>();

  /// Check if the frame data is writable.
  ///
  /// @return A positive value if the frame data is writable (which is true if and
  /// only if each of the underlying buffers has only one reference, namely the one
  /// stored in this frame). Return 0 otherwise.
  ///
  /// If 1 is returned the answer is valid until av_buffer_ref() is called on any
  /// of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
  ///
  /// @see av_frame_make_writable(), av_buffer_is_writable()
  int av_frame_is_writable(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_frame_is_writable(
      frame,
    );
  }

  late final _av_frame_is_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFrame>)>>(
          'av_frame_is_writable');
  late final _av_frame_is_writable =
      _av_frame_is_writablePtr.asFunction<int Function(ffi.Pointer<AVFrame>)>();

  /// Ensure that the frame data is writable, avoiding data copy if possible.
  ///
  /// Do nothing if the frame is writable, allocate new buffers and copy the data
  /// if it is not. Non-refcounted frames behave as non-writable, i.e. a copy
  /// is always made.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  ///
  /// @see av_frame_is_writable(), av_buffer_is_writable(),
  /// av_buffer_make_writable()
  int av_frame_make_writable(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_frame_make_writable(
      frame,
    );
  }

  late final _av_frame_make_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFrame>)>>(
          'av_frame_make_writable');
  late final _av_frame_make_writable = _av_frame_make_writablePtr
      .asFunction<int Function(ffi.Pointer<AVFrame>)>();

  /// Copy the frame data from src to dst.
  ///
  /// This function does not allocate anything, dst must be already initialized and
  /// allocated with the same parameters as src.
  ///
  /// This function only copies the frame data (i.e. the contents of the data /
  /// extended data arrays), not any other properties.
  ///
  /// @return >= 0 on success, a negative AVERROR on error.
  int av_frame_copy(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _av_frame_copy(
      dst,
      src,
    );
  }

  late final _av_frame_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>>('av_frame_copy');
  late final _av_frame_copy = _av_frame_copyPtr
      .asFunction<int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>();

  /// Copy only "metadata" fields from src to dst.
  ///
  /// Metadata for the purpose of this function are those fields that do not affect
  /// the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
  /// aspect ratio (for video), but not width/height or channel layout.
  /// Side data is also copied.
  int av_frame_copy_props(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _av_frame_copy_props(
      dst,
      src,
    );
  }

  late final _av_frame_copy_propsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFrame>,
              ffi.Pointer<AVFrame>)>>('av_frame_copy_props');
  late final _av_frame_copy_props = _av_frame_copy_propsPtr
      .asFunction<int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>)>();

  /// Get the buffer reference a given data plane is stored in.
  ///
  /// @param frame the frame to get the plane's buffer from
  /// @param plane index of the data plane of interest in frame->extended_data.
  ///
  /// @return the buffer reference that contains the plane or NULL if the input
  /// frame is not valid.
  ffi.Pointer<AVBufferRef> av_frame_get_plane_buffer(
    ffi.Pointer<AVFrame> frame,
    int plane,
  ) {
    return _av_frame_get_plane_buffer(
      frame,
      plane,
    );
  }

  late final _av_frame_get_plane_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBufferRef> Function(
              ffi.Pointer<AVFrame>, ffi.Int)>>('av_frame_get_plane_buffer');
  late final _av_frame_get_plane_buffer =
      _av_frame_get_plane_bufferPtr.asFunction<
          ffi.Pointer<AVBufferRef> Function(ffi.Pointer<AVFrame>, int)>();

  /// Add a new side data to a frame.
  ///
  /// @param frame a frame to which the side data should be added
  /// @param type type of the added side data
  /// @param size size of the side data
  ///
  /// @return newly added side data on success, NULL on error
  ffi.Pointer<AVFrameSideData> av_frame_new_side_data(
    ffi.Pointer<AVFrame> frame,
    AVFrameSideDataType type,
    int size,
  ) {
    return _av_frame_new_side_data(
      frame,
      type.value,
      size,
    );
  }

  late final _av_frame_new_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFrameSideData> Function(ffi.Pointer<AVFrame>,
              ffi.UnsignedInt, ffi.Size)>>('av_frame_new_side_data');
  late final _av_frame_new_side_data = _av_frame_new_side_dataPtr.asFunction<
      ffi.Pointer<AVFrameSideData> Function(ffi.Pointer<AVFrame>, int, int)>();

  /// Add a new side data to a frame from an existing AVBufferRef
  ///
  /// @param frame a frame to which the side data should be added
  /// @param type  the type of the added side data
  /// @param buf   an AVBufferRef to add as side data. The ownership of
  /// the reference is transferred to the frame.
  ///
  /// @return newly added side data on success, NULL on error. On failure
  /// the frame is unchanged and the AVBufferRef remains owned by
  /// the caller.
  ffi.Pointer<AVFrameSideData> av_frame_new_side_data_from_buf(
    ffi.Pointer<AVFrame> frame,
    AVFrameSideDataType type,
    ffi.Pointer<AVBufferRef> buf,
  ) {
    return _av_frame_new_side_data_from_buf(
      frame,
      type.value,
      buf,
    );
  }

  late final _av_frame_new_side_data_from_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFrameSideData> Function(
              ffi.Pointer<AVFrame>,
              ffi.UnsignedInt,
              ffi.Pointer<AVBufferRef>)>>('av_frame_new_side_data_from_buf');
  late final _av_frame_new_side_data_from_buf =
      _av_frame_new_side_data_from_bufPtr.asFunction<
          ffi.Pointer<AVFrameSideData> Function(
              ffi.Pointer<AVFrame>, int, ffi.Pointer<AVBufferRef>)>();

  /// @return a pointer to the side data of a given type on success, NULL if there
  /// is no side data with such type in this frame.
  ffi.Pointer<AVFrameSideData> av_frame_get_side_data(
    ffi.Pointer<AVFrame> frame,
    AVFrameSideDataType type,
  ) {
    return _av_frame_get_side_data(
      frame,
      type.value,
    );
  }

  late final _av_frame_get_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFrameSideData> Function(ffi.Pointer<AVFrame>,
              ffi.UnsignedInt)>>('av_frame_get_side_data');
  late final _av_frame_get_side_data = _av_frame_get_side_dataPtr.asFunction<
      ffi.Pointer<AVFrameSideData> Function(ffi.Pointer<AVFrame>, int)>();

  /// Remove and free all side data instances of the given type.
  void av_frame_remove_side_data(
    ffi.Pointer<AVFrame> frame,
    AVFrameSideDataType type,
  ) {
    return _av_frame_remove_side_data(
      frame,
      type.value,
    );
  }

  late final _av_frame_remove_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVFrame>,
              ffi.UnsignedInt)>>('av_frame_remove_side_data');
  late final _av_frame_remove_side_data = _av_frame_remove_side_dataPtr
      .asFunction<void Function(ffi.Pointer<AVFrame>, int)>();

  /// Crop the given video AVFrame according to its crop_left/crop_top/crop_right/
  /// crop_bottom fields. If cropping is successful, the function will adjust the
  /// data pointers and the width/height fields, and set the crop fields to 0.
  ///
  /// In all cases, the cropping boundaries will be rounded to the inherent
  /// alignment of the pixel format. In some cases, such as for opaque hwaccel
  /// formats, the left/top cropping is ignored. The crop fields are set to 0 even
  /// if the cropping was rounded or ignored.
  ///
  /// @param frame the frame which should be cropped
  /// @param flags Some combination of AV_FRAME_CROP_* flags, or 0.
  ///
  /// @return >= 0 on success, a negative AVERROR on error. If the cropping fields
  /// were invalid, AVERROR(ERANGE) is returned, and nothing is changed.
  int av_frame_apply_cropping(
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    return _av_frame_apply_cropping(
      frame,
      flags,
    );
  }

  late final _av_frame_apply_croppingPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFrame>, ffi.Int)>>(
      'av_frame_apply_cropping');
  late final _av_frame_apply_cropping = _av_frame_apply_croppingPtr
      .asFunction<int Function(ffi.Pointer<AVFrame>, int)>();

  /// @return a string identifying the side data type
  ffi.Pointer<ffi.Char> av_frame_side_data_name(
    AVFrameSideDataType type,
  ) {
    return _av_frame_side_data_name(
      type.value,
    );
  }

  late final _av_frame_side_data_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_frame_side_data_name');
  late final _av_frame_side_data_name = _av_frame_side_data_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @return side data descriptor corresponding to a given side data type, NULL
  /// when not available.
  ffi.Pointer<AVSideDataDescriptor> av_frame_side_data_desc(
    AVFrameSideDataType type,
  ) {
    return _av_frame_side_data_desc(
      type.value,
    );
  }

  late final _av_frame_side_data_descPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVSideDataDescriptor> Function(
              ffi.UnsignedInt)>>('av_frame_side_data_desc');
  late final _av_frame_side_data_desc = _av_frame_side_data_descPtr
      .asFunction<ffi.Pointer<AVSideDataDescriptor> Function(int)>();

  /// Free all side data entries and their contents, then zeroes out the
  /// values which the pointers are pointing to.
  ///
  /// @param sd    pointer to array of side data to free. Will be set to NULL
  /// upon return.
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array. Will be set to 0 upon return.
  void av_frame_side_data_free(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
  ) {
    return _av_frame_side_data_free(
      sd,
      nb_sd,
    );
  }

  late final _av_frame_side_data_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>)>>('av_frame_side_data_free');
  late final _av_frame_side_data_free = _av_frame_side_data_freePtr.asFunction<
      void Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
          ffi.Pointer<ffi.Int>)>();

  /// Add new side data entry to an array.
  ///
  /// @param sd    pointer to array of side data to which to add another entry,
  /// or to NULL in order to start a new array.
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array.
  /// @param type  type of the added side data
  /// @param size  size of the side data
  /// @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.
  ///
  /// @return newly added side data on success, NULL on error.
  /// @note In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of
  /// matching AVFrameSideDataType will be removed before the addition
  /// is attempted.
  /// @note In case of AV_FRAME_SIDE_DATA_FLAG_REPLACE being set, if an
  /// entry of the same type already exists, it will be replaced instead.
  ffi.Pointer<AVFrameSideData> av_frame_side_data_new(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
    AVFrameSideDataType type,
    int size,
    int flags,
  ) {
    return _av_frame_side_data_new(
      sd,
      nb_sd,
      type.value,
      size,
      flags,
    );
  }

  late final _av_frame_side_data_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFrameSideData> Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt,
              ffi.Size,
              ffi.UnsignedInt)>>('av_frame_side_data_new');
  late final _av_frame_side_data_new = _av_frame_side_data_newPtr.asFunction<
      ffi.Pointer<AVFrameSideData> Function(
          ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          int)>();

  /// Add a new side data entry to an array from an existing AVBufferRef.
  ///
  /// @param sd    pointer to array of side data to which to add another entry,
  /// or to NULL in order to start a new array.
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array.
  /// @param type  type of the added side data
  /// @param buf   Pointer to AVBufferRef to add to the array. On success,
  /// the function takes ownership of the AVBufferRef and *buf is
  /// set to NULL, unless AV_FRAME_SIDE_DATA_FLAG_NEW_REF is set
  /// in which case the ownership will remain with the caller.
  /// @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.
  ///
  /// @return newly added side data on success, NULL on error.
  /// @note In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of
  /// matching AVFrameSideDataType will be removed before the addition
  /// is attempted.
  /// @note In case of AV_FRAME_SIDE_DATA_FLAG_REPLACE being set, if an
  /// entry of the same type already exists, it will be replaced instead.
  ffi.Pointer<AVFrameSideData> av_frame_side_data_add(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
    AVFrameSideDataType type,
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
    int flags,
  ) {
    return _av_frame_side_data_add(
      sd,
      nb_sd,
      type.value,
      buf,
      flags,
    );
  }

  late final _av_frame_side_data_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFrameSideData> Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.UnsignedInt)>>('av_frame_side_data_add');
  late final _av_frame_side_data_add = _av_frame_side_data_addPtr.asFunction<
      ffi.Pointer<AVFrameSideData> Function(
          ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Pointer<AVBufferRef>>,
          int)>();

  /// Add a new side data entry to an array based on existing side data, taking
  /// a reference towards the contained AVBufferRef.
  ///
  /// @param sd    pointer to array of side data to which to add another entry,
  /// or to NULL in order to start a new array.
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array.
  /// @param src   side data to be cloned, with a new reference utilized
  /// for the buffer.
  /// @param flags Some combination of AV_FRAME_SIDE_DATA_FLAG_* flags, or 0.
  ///
  /// @return negative error code on failure, >=0 on success.
  /// @note In case of AV_FRAME_SIDE_DATA_FLAG_UNIQUE being set, entries of
  /// matching AVFrameSideDataType will be removed before the addition
  /// is attempted.
  /// @note In case of AV_FRAME_SIDE_DATA_FLAG_REPLACE being set, if an
  /// entry of the same type already exists, it will be replaced instead.
  int av_frame_side_data_clone(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
    ffi.Pointer<AVFrameSideData> src,
    int flags,
  ) {
    return _av_frame_side_data_clone(
      sd,
      nb_sd,
      src,
      flags,
    );
  }

  late final _av_frame_side_data_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVFrameSideData>,
              ffi.UnsignedInt)>>('av_frame_side_data_clone');
  late final _av_frame_side_data_clone =
      _av_frame_side_data_clonePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>, ffi.Pointer<AVFrameSideData>, int)>();

  /// Get a side data entry of a specific type from an array.
  ///
  /// @param sd    array of side data.
  /// @param nb_sd integer containing the number of entries in the array.
  /// @param type  type of side data to be queried
  ///
  /// @return a pointer to the side data of a given type on success, NULL if there
  /// is no side data with such type in this set.
  ffi.Pointer<AVFrameSideData> av_frame_side_data_get_c(
    ffi.Pointer<ffi.Pointer<AVFrameSideData>> sd,
    int nb_sd,
    AVFrameSideDataType type,
  ) {
    return _av_frame_side_data_get_c(
      sd,
      nb_sd,
      type.value,
    );
  }

  late final _av_frame_side_data_get_cPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFrameSideData> Function(
              ffi.Pointer<ffi.Pointer<AVFrameSideData>>,
              ffi.Int,
              ffi.UnsignedInt)>>('av_frame_side_data_get_c');
  late final _av_frame_side_data_get_c =
      _av_frame_side_data_get_cPtr.asFunction<
          ffi.Pointer<AVFrameSideData> Function(
              ffi.Pointer<ffi.Pointer<AVFrameSideData>>, int, int)>();

  /// Remove and free all side data instances of the given type from an array.
  void av_frame_side_data_remove(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
    AVFrameSideDataType type,
  ) {
    return _av_frame_side_data_remove(
      sd,
      nb_sd,
      type.value,
    );
  }

  late final _av_frame_side_data_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt)>>('av_frame_side_data_remove');
  late final _av_frame_side_data_remove =
      _av_frame_side_data_removePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<AVFrameSideData>>>,
              ffi.Pointer<ffi.Int>, int)>();

  /// Look up an AVHWDeviceType by name.
  ///
  /// @param name String name of the device type (case-insensitive).
  /// @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if
  /// not found.
  AVHWDeviceType av_hwdevice_find_type_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return AVHWDeviceType.fromValue(_av_hwdevice_find_type_by_name(
      name,
    ));
  }

  late final _av_hwdevice_find_type_by_namePtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Char>)>>(
      'av_hwdevice_find_type_by_name');
  late final _av_hwdevice_find_type_by_name = _av_hwdevice_find_type_by_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get the string name of an AVHWDeviceType.
  ///
  /// @param type Type from enum AVHWDeviceType.
  /// @return Pointer to a static string containing the name, or NULL if the type
  /// is not valid.
  ffi.Pointer<ffi.Char> av_hwdevice_get_type_name(
    AVHWDeviceType type,
  ) {
    return _av_hwdevice_get_type_name(
      type.value,
    );
  }

  late final _av_hwdevice_get_type_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_hwdevice_get_type_name');
  late final _av_hwdevice_get_type_name = _av_hwdevice_get_type_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Iterate over supported device types.
  ///
  /// @param prev AV_HWDEVICE_TYPE_NONE initially, then the previous type
  /// returned by this function in subsequent iterations.
  /// @return The next usable device type from enum AVHWDeviceType, or
  /// AV_HWDEVICE_TYPE_NONE if there are no more.
  AVHWDeviceType av_hwdevice_iterate_types(
    AVHWDeviceType prev,
  ) {
    return AVHWDeviceType.fromValue(_av_hwdevice_iterate_types(
      prev.value,
    ));
  }

  late final _av_hwdevice_iterate_typesPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.UnsignedInt)>>(
          'av_hwdevice_iterate_types');
  late final _av_hwdevice_iterate_types =
      _av_hwdevice_iterate_typesPtr.asFunction<int Function(int)>();

  /// Allocate an AVHWDeviceContext for a given hardware type.
  ///
  /// @param type the type of the hardware device to allocate.
  /// @return a reference to the newly created AVHWDeviceContext on success or NULL
  /// on failure.
  ffi.Pointer<AVBufferRef> av_hwdevice_ctx_alloc(
    AVHWDeviceType type,
  ) {
    return _av_hwdevice_ctx_alloc(
      type.value,
    );
  }

  late final _av_hwdevice_ctx_allocPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<AVBufferRef> Function(ffi.UnsignedInt)>>(
      'av_hwdevice_ctx_alloc');
  late final _av_hwdevice_ctx_alloc = _av_hwdevice_ctx_allocPtr
      .asFunction<ffi.Pointer<AVBufferRef> Function(int)>();

  /// Finalize the device context before use. This function must be called after
  /// the context is filled with all the required information and before it is
  /// used in any way.
  ///
  /// @param ref a reference to the AVHWDeviceContext
  /// @return 0 on success, a negative AVERROR code on failure
  int av_hwdevice_ctx_init(
    ffi.Pointer<AVBufferRef> ref,
  ) {
    return _av_hwdevice_ctx_init(
      ref,
    );
  }

  late final _av_hwdevice_ctx_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVBufferRef>)>>(
          'av_hwdevice_ctx_init');
  late final _av_hwdevice_ctx_init = _av_hwdevice_ctx_initPtr
      .asFunction<int Function(ffi.Pointer<AVBufferRef>)>();

  /// Open a device of the specified type and create an AVHWDeviceContext for it.
  ///
  /// This is a convenience function intended to cover the simple cases. Callers
  /// who need to fine-tune device creation/management should open the device
  /// manually and then wrap it in an AVHWDeviceContext using
  /// av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().
  ///
  /// The returned context is already initialized and ready for use, the caller
  /// should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of
  /// the created AVHWDeviceContext are set by this function and should not be
  /// touched by the caller.
  ///
  /// @param device_ctx On success, a reference to the newly-created device context
  /// will be written here. The reference is owned by the caller
  /// and must be released with av_buffer_unref() when no longer
  /// needed. On failure, NULL will be written to this pointer.
  /// @param type The type of the device to create.
  /// @param device A type-specific string identifying the device to open.
  /// @param opts A dictionary of additional (type-specific) options to use in
  /// opening the device. The dictionary remains owned by the caller.
  /// @param flags currently unused
  ///
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_hwdevice_ctx_create(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> device_ctx,
    AVHWDeviceType type,
    ffi.Pointer<ffi.Char> device,
    ffi.Pointer<AVDictionary> opts,
    int flags,
  ) {
    return _av_hwdevice_ctx_create(
      device_ctx,
      type.value,
      device,
      opts,
      flags,
    );
  }

  late final _av_hwdevice_ctx_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVDictionary>,
              ffi.Int)>>('av_hwdevice_ctx_create');
  late final _av_hwdevice_ctx_create = _av_hwdevice_ctx_createPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>, int,
          ffi.Pointer<ffi.Char>, ffi.Pointer<AVDictionary>, int)>();

  /// Create a new device of the specified type from an existing device.
  ///
  /// If the source device is a device of the target type or was originally
  /// derived from such a device (possibly through one or more intermediate
  /// devices of other types), then this will return a reference to the
  /// existing device of the same type as is requested.
  ///
  /// Otherwise, it will attempt to derive a new device from the given source
  /// device.  If direct derivation to the new type is not implemented, it will
  /// attempt the same derivation from each ancestor of the source device in
  /// turn looking for an implemented derivation method.
  ///
  /// @param dst_ctx On success, a reference to the newly-created
  /// AVHWDeviceContext.
  /// @param type    The type of the new device to create.
  /// @param src_ctx A reference to an existing AVHWDeviceContext which will be
  /// used to create the new device.
  /// @param flags   Currently unused; should be set to zero.
  /// @return        Zero on success, a negative AVERROR code on failure.
  int av_hwdevice_ctx_create_derived(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
    AVHWDeviceType type,
    ffi.Pointer<AVBufferRef> src_ctx,
    int flags,
  ) {
    return _av_hwdevice_ctx_create_derived(
      dst_ctx,
      type.value,
      src_ctx,
      flags,
    );
  }

  late final _av_hwdevice_ctx_create_derivedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.UnsignedInt,
              ffi.Pointer<AVBufferRef>,
              ffi.Int)>>('av_hwdevice_ctx_create_derived');
  late final _av_hwdevice_ctx_create_derived =
      _av_hwdevice_ctx_create_derivedPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>, int,
              ffi.Pointer<AVBufferRef>, int)>();

  /// Create a new device of the specified type from an existing device.
  ///
  /// This function performs the same action as av_hwdevice_ctx_create_derived,
  /// however, it is able to set options for the new device to be derived.
  ///
  /// @param dst_ctx On success, a reference to the newly-created
  /// AVHWDeviceContext.
  /// @param type    The type of the new device to create.
  /// @param src_ctx A reference to an existing AVHWDeviceContext which will be
  /// used to create the new device.
  /// @param options Options for the new device to create, same format as in
  /// av_hwdevice_ctx_create.
  /// @param flags   Currently unused; should be set to zero.
  /// @return        Zero on success, a negative AVERROR code on failure.
  int av_hwdevice_ctx_create_derived_opts(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
    AVHWDeviceType type,
    ffi.Pointer<AVBufferRef> src_ctx,
    ffi.Pointer<AVDictionary> options,
    int flags,
  ) {
    return _av_hwdevice_ctx_create_derived_opts(
      dst_ctx,
      type.value,
      src_ctx,
      options,
      flags,
    );
  }

  late final _av_hwdevice_ctx_create_derived_optsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.UnsignedInt,
              ffi.Pointer<AVBufferRef>,
              ffi.Pointer<AVDictionary>,
              ffi.Int)>>('av_hwdevice_ctx_create_derived_opts');
  late final _av_hwdevice_ctx_create_derived_opts =
      _av_hwdevice_ctx_create_derived_optsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>, int,
              ffi.Pointer<AVBufferRef>, ffi.Pointer<AVDictionary>, int)>();

  /// Allocate an AVHWFramesContext tied to a given device context.
  ///
  /// @param device_ctx a reference to a AVHWDeviceContext. This function will make
  /// a new reference for internal use, the one passed to the
  /// function remains owned by the caller.
  /// @return a reference to the newly created AVHWFramesContext on success or NULL
  /// on failure.
  ffi.Pointer<AVBufferRef> av_hwframe_ctx_alloc(
    ffi.Pointer<AVBufferRef> device_ctx,
  ) {
    return _av_hwframe_ctx_alloc(
      device_ctx,
    );
  }

  late final _av_hwframe_ctx_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBufferRef> Function(
              ffi.Pointer<AVBufferRef>)>>('av_hwframe_ctx_alloc');
  late final _av_hwframe_ctx_alloc = _av_hwframe_ctx_allocPtr.asFunction<
      ffi.Pointer<AVBufferRef> Function(ffi.Pointer<AVBufferRef>)>();

  /// Finalize the context before use. This function must be called after the
  /// context is filled with all the required information and before it is attached
  /// to any frames.
  ///
  /// @param ref a reference to the AVHWFramesContext
  /// @return 0 on success, a negative AVERROR code on failure
  int av_hwframe_ctx_init(
    ffi.Pointer<AVBufferRef> ref,
  ) {
    return _av_hwframe_ctx_init(
      ref,
    );
  }

  late final _av_hwframe_ctx_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVBufferRef>)>>(
          'av_hwframe_ctx_init');
  late final _av_hwframe_ctx_init = _av_hwframe_ctx_initPtr
      .asFunction<int Function(ffi.Pointer<AVBufferRef>)>();

  /// Allocate a new frame attached to the given AVHWFramesContext.
  ///
  /// @param hwframe_ctx a reference to an AVHWFramesContext
  /// @param frame an empty (freshly allocated or unreffed) frame to be filled with
  /// newly allocated buffers.
  /// @param flags currently unused, should be set to zero
  /// @return 0 on success, a negative AVERROR code on failure
  int av_hwframe_get_buffer(
    ffi.Pointer<AVBufferRef> hwframe_ctx,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    return _av_hwframe_get_buffer(
      hwframe_ctx,
      frame,
      flags,
    );
  }

  late final _av_hwframe_get_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBufferRef>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('av_hwframe_get_buffer');
  late final _av_hwframe_get_buffer = _av_hwframe_get_bufferPtr.asFunction<
      int Function(ffi.Pointer<AVBufferRef>, ffi.Pointer<AVFrame>, int)>();

  /// Copy data to or from a hw surface. At least one of dst/src must have an
  /// AVHWFramesContext attached.
  ///
  /// If src has an AVHWFramesContext attached, then the format of dst (if set)
  /// must use one of the formats returned by av_hwframe_transfer_get_formats(src,
  /// AV_HWFRAME_TRANSFER_DIRECTION_FROM).
  /// If dst has an AVHWFramesContext attached, then the format of src must use one
  /// of the formats returned by av_hwframe_transfer_get_formats(dst,
  /// AV_HWFRAME_TRANSFER_DIRECTION_TO)
  ///
  /// dst may be "clean" (i.e. with data/buf pointers unset), in which case the
  /// data buffers will be allocated by this function using av_frame_get_buffer().
  /// If dst->format is set, then this format will be used, otherwise (when
  /// dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.
  ///
  /// The two frames must have matching allocated dimensions (i.e. equal to
  /// AVHWFramesContext.width/height), since not all device types support
  /// transferring a sub-rectangle of the whole surface. The display dimensions
  /// (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but
  /// also have to be equal for both frames. When the display dimensions are
  /// smaller than the allocated dimensions, the content of the padding in the
  /// destination frame is unspecified.
  ///
  /// @param dst the destination frame. dst is not touched on failure.
  /// @param src the source frame.
  /// @param flags currently unused, should be set to zero
  /// @return 0 on success, a negative AVERROR error code on failure.
  int av_hwframe_transfer_data(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
    int flags,
  ) {
    return _av_hwframe_transfer_data(
      dst,
      src,
      flags,
    );
  }

  late final _av_hwframe_transfer_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('av_hwframe_transfer_data');
  late final _av_hwframe_transfer_data =
      _av_hwframe_transfer_dataPtr.asFunction<
          int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>, int)>();

  /// Get a list of possible source or target formats usable in
  /// av_hwframe_transfer_data().
  ///
  /// @param hwframe_ctx the frame context to obtain the information for
  /// @param dir the direction of the transfer
  /// @param formats the pointer to the output format list will be written here.
  /// The list is terminated with AV_PIX_FMT_NONE and must be freed
  /// by the caller when no longer needed using av_free().
  /// If this function returns successfully, the format list will
  /// have at least one item (not counting the terminator).
  /// On failure, the contents of this pointer are unspecified.
  /// @param flags currently unused, should be set to zero
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_hwframe_transfer_get_formats(
    ffi.Pointer<AVBufferRef> hwframe_ctx,
    AVHWFrameTransferDirection dir,
    ffi.Pointer<ffi.Pointer<ffi.Int>> formats,
    int flags,
  ) {
    return _av_hwframe_transfer_get_formats(
      hwframe_ctx,
      dir.value,
      formats,
      flags,
    );
  }

  late final _av_hwframe_transfer_get_formatsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVBufferRef>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Int)>>('av_hwframe_transfer_get_formats');
  late final _av_hwframe_transfer_get_formats =
      _av_hwframe_transfer_get_formatsPtr.asFunction<
          int Function(ffi.Pointer<AVBufferRef>, int,
              ffi.Pointer<ffi.Pointer<ffi.Int>>, int)>();

  /// Allocate a HW-specific configuration structure for a given HW device.
  /// After use, the user must free all members as required by the specific
  /// hardware structure being used, then free the structure itself with
  /// av_free().
  ///
  /// @param device_ctx a reference to the associated AVHWDeviceContext.
  /// @return The newly created HW-specific configuration structure on
  /// success or NULL on failure.
  ffi.Pointer<ffi.Void> av_hwdevice_hwconfig_alloc(
    ffi.Pointer<AVBufferRef> device_ctx,
  ) {
    return _av_hwdevice_hwconfig_alloc(
      device_ctx,
    );
  }

  late final _av_hwdevice_hwconfig_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<AVBufferRef>)>>('av_hwdevice_hwconfig_alloc');
  late final _av_hwdevice_hwconfig_alloc = _av_hwdevice_hwconfig_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<AVBufferRef>)>();

  /// Get the constraints on HW frames given a device and the HW-specific
  /// configuration to be used with that device.  If no HW-specific
  /// configuration is provided, returns the maximum possible capabilities
  /// of the device.
  ///
  /// @param ref a reference to the associated AVHWDeviceContext.
  /// @param hwconfig a filled HW-specific configuration structure, or NULL
  /// to return the maximum possible capabilities of the device.
  /// @return AVHWFramesConstraints structure describing the constraints
  /// on the device, or NULL if not available.
  ffi.Pointer<AVHWFramesConstraints> av_hwdevice_get_hwframe_constraints(
    ffi.Pointer<AVBufferRef> ref,
    ffi.Pointer<ffi.Void> hwconfig,
  ) {
    return _av_hwdevice_get_hwframe_constraints(
      ref,
      hwconfig,
    );
  }

  late final _av_hwdevice_get_hwframe_constraintsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVHWFramesConstraints> Function(ffi.Pointer<AVBufferRef>,
              ffi.Pointer<ffi.Void>)>>('av_hwdevice_get_hwframe_constraints');
  late final _av_hwdevice_get_hwframe_constraints =
      _av_hwdevice_get_hwframe_constraintsPtr.asFunction<
          ffi.Pointer<AVHWFramesConstraints> Function(
              ffi.Pointer<AVBufferRef>, ffi.Pointer<ffi.Void>)>();

  /// Free an AVHWFrameConstraints structure.
  ///
  /// @param constraints The (filled or unfilled) AVHWFrameConstraints structure.
  void av_hwframe_constraints_free(
    ffi.Pointer<ffi.Pointer<AVHWFramesConstraints>> constraints,
  ) {
    return _av_hwframe_constraints_free(
      constraints,
    );
  }

  late final _av_hwframe_constraints_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Pointer<AVHWFramesConstraints>>)>>(
      'av_hwframe_constraints_free');
  late final _av_hwframe_constraints_free =
      _av_hwframe_constraints_freePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<AVHWFramesConstraints>>)>();

  /// Map a hardware frame.
  ///
  /// This has a number of different possible effects, depending on the format
  /// and origin of the src and dst frames.  On input, src should be a usable
  /// frame with valid buffers and dst should be blank (typically as just created
  /// by av_frame_alloc()).  src should have an associated hwframe context, and
  /// dst may optionally have a format and associated hwframe context.
  ///
  /// If src was created by mapping a frame from the hwframe context of dst,
  /// then this function undoes the mapping - dst is replaced by a reference to
  /// the frame that src was originally mapped from.
  ///
  /// If both src and dst have an associated hwframe context, then this function
  /// attempts to map the src frame from its hardware context to that of dst and
  /// then fill dst with appropriate data to be usable there.  This will only be
  /// possible if the hwframe contexts and associated devices are compatible -
  /// given compatible devices, av_hwframe_ctx_create_derived() can be used to
  /// create a hwframe context for dst in which mapping should be possible.
  ///
  /// If src has a hwframe context but dst does not, then the src frame is
  /// mapped to normal memory and should thereafter be usable as a normal frame.
  /// If the format is set on dst, then the mapping will attempt to create dst
  /// with that format and fail if it is not possible.  If format is unset (is
  /// AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate
  /// format to use is (probably the sw_format of the src hwframe context).
  ///
  /// A return value of AVERROR(ENOSYS) indicates that the mapping is not
  /// possible with the given arguments and hwframe setup, while other return
  /// values indicate that it failed somehow.
  ///
  /// On failure, the destination frame will be left blank, except for the
  /// hw_frames_ctx/format fields thay may have been set by the caller - those will
  /// be preserved as they were.
  ///
  /// @param dst Destination frame, to contain the mapping.
  /// @param src Source frame, to be mapped.
  /// @param flags Some combination of AV_HWFRAME_MAP_* flags.
  /// @return Zero on success, negative AVERROR code on failure.
  int av_hwframe_map(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
    int flags,
  ) {
    return _av_hwframe_map(
      dst,
      src,
      flags,
    );
  }

  late final _av_hwframe_mapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('av_hwframe_map');
  late final _av_hwframe_map = _av_hwframe_mapPtr.asFunction<
      int Function(ffi.Pointer<AVFrame>, ffi.Pointer<AVFrame>, int)>();

  /// Create and initialise an AVHWFramesContext as a mapping of another existing
  /// AVHWFramesContext on a different device.
  ///
  /// av_hwframe_ctx_init() should not be called after this.
  ///
  /// @param derived_frame_ctx  On success, a reference to the newly created
  /// AVHWFramesContext.
  /// @param format             The AVPixelFormat for the derived context.
  /// @param derived_device_ctx A reference to the device to create the new
  /// AVHWFramesContext on.
  /// @param source_frame_ctx   A reference to an existing AVHWFramesContext
  /// which will be mapped to the derived context.
  /// @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the
  /// mapping parameters to apply to frames which are allocated
  /// in the derived device.
  /// @return       Zero on success, negative AVERROR code on failure.
  int av_hwframe_ctx_create_derived(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> derived_frame_ctx,
    AVPixelFormat format,
    ffi.Pointer<AVBufferRef> derived_device_ctx,
    ffi.Pointer<AVBufferRef> source_frame_ctx,
    int flags,
  ) {
    return _av_hwframe_ctx_create_derived(
      derived_frame_ctx,
      format.value,
      derived_device_ctx,
      source_frame_ctx,
      flags,
    );
  }

  late final _av_hwframe_ctx_create_derivedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVBufferRef>>,
              ffi.Int,
              ffi.Pointer<AVBufferRef>,
              ffi.Pointer<AVBufferRef>,
              ffi.Int)>>('av_hwframe_ctx_create_derived');
  late final _av_hwframe_ctx_create_derived =
      _av_hwframe_ctx_create_derivedPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<AVBufferRef>>, int,
              ffi.Pointer<AVBufferRef>, ffi.Pointer<AVBufferRef>, int)>();

  /// Get the type of the given codec.
  AVMediaType avcodec_get_type(
    AVCodecID codec_id,
  ) {
    return AVMediaType.fromValue(_avcodec_get_type(
      codec_id.value,
    ));
  }

  late final _avcodec_get_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'avcodec_get_type');
  late final _avcodec_get_type =
      _avcodec_get_typePtr.asFunction<int Function(int)>();

  /// Get the name of a codec.
  /// @return  a static string identifying the codec; never NULL
  ffi.Pointer<ffi.Char> avcodec_get_name(
    AVCodecID id,
  ) {
    return _avcodec_get_name(
      id.value,
    );
  }

  late final _avcodec_get_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'avcodec_get_name');
  late final _avcodec_get_name =
      _avcodec_get_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Return codec bits per sample.
  ///
  /// @param[in] codec_id the codec
  /// @return Number of bits per sample or zero if unknown for the given codec.
  int av_get_bits_per_sample(
    AVCodecID codec_id,
  ) {
    return _av_get_bits_per_sample(
      codec_id.value,
    );
  }

  late final _av_get_bits_per_samplePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'av_get_bits_per_sample');
  late final _av_get_bits_per_sample =
      _av_get_bits_per_samplePtr.asFunction<int Function(int)>();

  /// Return codec bits per sample.
  /// Only return non-zero if the bits per sample is exactly correct, not an
  /// approximation.
  ///
  /// @param[in] codec_id the codec
  /// @return Number of bits per sample or zero if unknown for the given codec.
  int av_get_exact_bits_per_sample(
    AVCodecID codec_id,
  ) {
    return _av_get_exact_bits_per_sample(
      codec_id.value,
    );
  }

  late final _av_get_exact_bits_per_samplePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'av_get_exact_bits_per_sample');
  late final _av_get_exact_bits_per_sample =
      _av_get_exact_bits_per_samplePtr.asFunction<int Function(int)>();

  /// Return a name for the specified profile, if available.
  ///
  /// @param codec_id the ID of the codec to which the requested profile belongs
  /// @param profile the profile value for which a name is requested
  /// @return A name for the profile if found, NULL otherwise.
  ///
  /// @note unlike av_get_profile_name(), which searches a list of profiles
  /// supported by a specific decoder or encoder implementation, this
  /// function searches the list of profiles from the AVCodecDescriptor
  ffi.Pointer<ffi.Char> avcodec_profile_name(
    AVCodecID codec_id,
    int profile,
  ) {
    return _avcodec_profile_name(
      codec_id.value,
      profile,
    );
  }

  late final _avcodec_profile_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Int)>>('avcodec_profile_name');
  late final _avcodec_profile_name = _avcodec_profile_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  /// Return the PCM codec associated with a sample format.
  /// @param be  endianness, 0 for little, 1 for big,
  /// -1 (or anything else) for native
  /// @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
  AVCodecID av_get_pcm_codec(
    AVSampleFormat fmt,
    int be,
  ) {
    return AVCodecID.fromValue(_av_get_pcm_codec(
      fmt.value,
      be,
    ));
  }

  late final _av_get_pcm_codecPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int, ffi.Int)>>(
          'av_get_pcm_codec');
  late final _av_get_pcm_codec =
      _av_get_pcm_codecPtr.asFunction<int Function(int, int)>();

  /// Iterate over all registered codecs.
  ///
  /// @param opaque a pointer where libavcodec will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered codec or NULL when the iteration is
  /// finished
  ffi.Pointer<AVCodec> av_codec_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_codec_iterate(
      opaque,
    );
  }

  late final _av_codec_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodec> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_codec_iterate');
  late final _av_codec_iterate = _av_codec_iteratePtr.asFunction<
      ffi.Pointer<AVCodec> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Find a registered decoder with a matching codec ID.
  ///
  /// @param id AVCodecID of the requested decoder
  /// @return A decoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_decoder(
    AVCodecID id,
  ) {
    return _avcodec_find_decoder(
      id.value,
    );
  }

  late final _avcodec_find_decoderPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<AVCodec> Function(ffi.UnsignedInt)>>(
      'avcodec_find_decoder');
  late final _avcodec_find_decoder =
      _avcodec_find_decoderPtr.asFunction<ffi.Pointer<AVCodec> Function(int)>();

  /// Find a registered decoder with the specified name.
  ///
  /// @param name name of the requested decoder
  /// @return A decoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_decoder_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avcodec_find_decoder_by_name(
      name,
    );
  }

  late final _avcodec_find_decoder_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodec> Function(
              ffi.Pointer<ffi.Char>)>>('avcodec_find_decoder_by_name');
  late final _avcodec_find_decoder_by_name = _avcodec_find_decoder_by_namePtr
      .asFunction<ffi.Pointer<AVCodec> Function(ffi.Pointer<ffi.Char>)>();

  /// Find a registered encoder with a matching codec ID.
  ///
  /// @param id AVCodecID of the requested encoder
  /// @return An encoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_encoder(
    AVCodecID id,
  ) {
    return _avcodec_find_encoder(
      id.value,
    );
  }

  late final _avcodec_find_encoderPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<AVCodec> Function(ffi.UnsignedInt)>>(
      'avcodec_find_encoder');
  late final _avcodec_find_encoder =
      _avcodec_find_encoderPtr.asFunction<ffi.Pointer<AVCodec> Function(int)>();

  /// Find a registered encoder with the specified name.
  ///
  /// @param name name of the requested encoder
  /// @return An encoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_encoder_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avcodec_find_encoder_by_name(
      name,
    );
  }

  late final _avcodec_find_encoder_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodec> Function(
              ffi.Pointer<ffi.Char>)>>('avcodec_find_encoder_by_name');
  late final _avcodec_find_encoder_by_name = _avcodec_find_encoder_by_namePtr
      .asFunction<ffi.Pointer<AVCodec> Function(ffi.Pointer<ffi.Char>)>();

  /// @return a non-zero number if codec is an encoder, zero otherwise
  int av_codec_is_encoder(
    ffi.Pointer<AVCodec> codec,
  ) {
    return _av_codec_is_encoder(
      codec,
    );
  }

  late final _av_codec_is_encoderPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVCodec>)>>(
          'av_codec_is_encoder');
  late final _av_codec_is_encoder =
      _av_codec_is_encoderPtr.asFunction<int Function(ffi.Pointer<AVCodec>)>();

  /// @return a non-zero number if codec is a decoder, zero otherwise
  int av_codec_is_decoder(
    ffi.Pointer<AVCodec> codec,
  ) {
    return _av_codec_is_decoder(
      codec,
    );
  }

  late final _av_codec_is_decoderPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVCodec>)>>(
          'av_codec_is_decoder');
  late final _av_codec_is_decoder =
      _av_codec_is_decoderPtr.asFunction<int Function(ffi.Pointer<AVCodec>)>();

  /// Return a name for the specified profile, if available.
  ///
  /// @param codec the codec that is searched for the given profile
  /// @param profile the profile value for which a name is requested
  /// @return A name for the profile if found, NULL otherwise.
  ffi.Pointer<ffi.Char> av_get_profile_name(
    ffi.Pointer<AVCodec> codec,
    int profile,
  ) {
    return _av_get_profile_name(
      codec,
      profile,
    );
  }

  late final _av_get_profile_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<AVCodec>, ffi.Int)>>('av_get_profile_name');
  late final _av_get_profile_name = _av_get_profile_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<AVCodec>, int)>();

  /// Retrieve supported hardware configurations for a codec.
  ///
  /// Values of index from zero to some maximum return the indexed configuration
  /// descriptor; all other values return NULL.  If the codec does not support
  /// any hardware configurations then it will always return NULL.
  ffi.Pointer<AVCodecHWConfig> avcodec_get_hw_config(
    ffi.Pointer<AVCodec> codec,
    int index,
  ) {
    return _avcodec_get_hw_config(
      codec,
      index,
    );
  }

  late final _avcodec_get_hw_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecHWConfig> Function(
              ffi.Pointer<AVCodec>, ffi.Int)>>('avcodec_get_hw_config');
  late final _avcodec_get_hw_config = _avcodec_get_hw_configPtr.asFunction<
      ffi.Pointer<AVCodecHWConfig> Function(ffi.Pointer<AVCodec>, int)>();

  /// Allocate a CPB properties structure and initialize its fields to default
  /// values.
  ///
  /// @param size if non-NULL, the size of the allocated struct will be written
  /// here. This is useful for embedding it in side data.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVCPBProperties> av_cpb_properties_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_cpb_properties_alloc(
      size,
    );
  }

  late final _av_cpb_properties_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCPBProperties> Function(
              ffi.Pointer<ffi.Size>)>>('av_cpb_properties_alloc');
  late final _av_cpb_properties_alloc = _av_cpb_properties_allocPtr.asFunction<
      ffi.Pointer<AVCPBProperties> Function(ffi.Pointer<ffi.Size>)>();

  /// Encode extradata length to a buffer. Used by xiph codecs.
  ///
  /// @param s buffer to write to; must be at least (v/255+1) bytes long
  /// @param v size of extradata in bytes
  /// @return number of bytes written to the buffer.
  int av_xiphlacing(
    ffi.Pointer<ffi.UnsignedChar> s,
    int v,
  ) {
    return _av_xiphlacing(
      s,
      v,
    );
  }

  late final _av_xiphlacingPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ffi.UnsignedChar>,
              ffi.UnsignedInt)>>('av_xiphlacing');
  late final _av_xiphlacing = _av_xiphlacingPtr
      .asFunction<int Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Allocate a new packet side data.
  ///
  /// @param sd    pointer to an array of side data to which the side data should
  /// be added. *sd may be NULL, in which case the array will be
  /// initialized.
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array. The integer value will be increased by 1 on success.
  /// @param type  side data type
  /// @param size  desired side data size
  /// @param flags currently unused. Must be zero
  ///
  /// @return pointer to freshly allocated side data on success, or NULL otherwise.
  ffi.Pointer<AVPacketSideData> av_packet_side_data_new(
    ffi.Pointer<ffi.Pointer<AVPacketSideData>> psd,
    ffi.Pointer<ffi.Int> pnb_sd,
    AVPacketSideDataType type,
    int size,
    int flags,
  ) {
    return _av_packet_side_data_new(
      psd,
      pnb_sd,
      type.value,
      size,
      flags,
    );
  }

  late final _av_packet_side_data_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVPacketSideData> Function(
              ffi.Pointer<ffi.Pointer<AVPacketSideData>>,
              ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt,
              ffi.Size,
              ffi.Int)>>('av_packet_side_data_new');
  late final _av_packet_side_data_new = _av_packet_side_data_newPtr.asFunction<
      ffi.Pointer<AVPacketSideData> Function(
          ffi.Pointer<ffi.Pointer<AVPacketSideData>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          int)>();

  /// Wrap existing data as packet side data.
  ///
  /// @param sd    pointer to an array of side data to which the side data should
  /// be added. *sd may be NULL, in which case the array will be
  /// initialized
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array. The integer value will be increased by 1 on success.
  /// @param type  side data type
  /// @param data  a data array. It must be allocated with the av_malloc() family
  /// of functions. The ownership of the data is transferred to the
  /// side data array on success
  /// @param size  size of the data array
  /// @param flags currently unused. Must be zero
  ///
  /// @return pointer to freshly allocated side data on success, or NULL otherwise
  /// On failure, the side data array is unchanged and the data remains
  /// owned by the caller.
  ffi.Pointer<AVPacketSideData> av_packet_side_data_add(
    ffi.Pointer<ffi.Pointer<AVPacketSideData>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
    AVPacketSideDataType type,
    ffi.Pointer<ffi.Void> data,
    int size,
    int flags,
  ) {
    return _av_packet_side_data_add(
      sd,
      nb_sd,
      type.value,
      data,
      size,
      flags,
    );
  }

  late final _av_packet_side_data_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVPacketSideData> Function(
              ffi.Pointer<ffi.Pointer<AVPacketSideData>>,
              ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Int)>>('av_packet_side_data_add');
  late final _av_packet_side_data_add = _av_packet_side_data_addPtr.asFunction<
      ffi.Pointer<AVPacketSideData> Function(
          ffi.Pointer<ffi.Pointer<AVPacketSideData>>,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Get side information from a side data array.
  ///
  /// @param sd    the array from which the side data should be fetched
  /// @param nb_sd value containing the number of entries in the array.
  /// @param type  desired side information type
  ///
  /// @return pointer to side data if present or NULL otherwise
  ffi.Pointer<AVPacketSideData> av_packet_side_data_get(
    ffi.Pointer<AVPacketSideData> sd,
    int nb_sd,
    AVPacketSideDataType type,
  ) {
    return _av_packet_side_data_get(
      sd,
      nb_sd,
      type.value,
    );
  }

  late final _av_packet_side_data_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVPacketSideData> Function(ffi.Pointer<AVPacketSideData>,
              ffi.Int, ffi.UnsignedInt)>>('av_packet_side_data_get');
  late final _av_packet_side_data_get = _av_packet_side_data_getPtr.asFunction<
      ffi.Pointer<AVPacketSideData> Function(
          ffi.Pointer<AVPacketSideData>, int, int)>();

  /// Remove side data of the given type from a side data array.
  ///
  /// @param sd    the array from which the side data should be removed
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array. Will be reduced by the amount of entries removed
  /// upon return
  /// @param type  side information type
  void av_packet_side_data_remove(
    ffi.Pointer<AVPacketSideData> sd,
    ffi.Pointer<ffi.Int> nb_sd,
    AVPacketSideDataType type,
  ) {
    return _av_packet_side_data_remove(
      sd,
      nb_sd,
      type.value,
    );
  }

  late final _av_packet_side_data_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVPacketSideData>, ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt)>>('av_packet_side_data_remove');
  late final _av_packet_side_data_remove =
      _av_packet_side_data_removePtr.asFunction<
          void Function(
              ffi.Pointer<AVPacketSideData>, ffi.Pointer<ffi.Int>, int)>();

  /// Convenience function to free all the side data stored in an array, and
  /// the array itself.
  ///
  /// @param sd    pointer to array of side data to free. Will be set to NULL
  /// upon return.
  /// @param nb_sd pointer to an integer containing the number of entries in
  /// the array. Will be set to 0 upon return.
  void av_packet_side_data_free(
    ffi.Pointer<ffi.Pointer<AVPacketSideData>> sd,
    ffi.Pointer<ffi.Int> nb_sd,
  ) {
    return _av_packet_side_data_free(
      sd,
      nb_sd,
    );
  }

  late final _av_packet_side_data_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Pointer<AVPacketSideData>>,
              ffi.Pointer<ffi.Int>)>>('av_packet_side_data_free');
  late final _av_packet_side_data_free =
      _av_packet_side_data_freePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<AVPacketSideData>>,
              ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> av_packet_side_data_name(
    AVPacketSideDataType type,
  ) {
    return _av_packet_side_data_name(
      type.value,
    );
  }

  late final _av_packet_side_data_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_packet_side_data_name');
  late final _av_packet_side_data_name = _av_packet_side_data_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Allocate an AVPacket and set its fields to default values.  The resulting
  /// struct must be freed using av_packet_free().
  ///
  /// @return An AVPacket filled with default values or NULL on failure.
  ///
  /// @note this only allocates the AVPacket itself, not the data buffers. Those
  /// must be allocated through other means such as av_new_packet.
  ///
  /// @see av_new_packet
  ffi.Pointer<AVPacket> av_packet_alloc() {
    return _av_packet_alloc();
  }

  late final _av_packet_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVPacket> Function()>>(
          'av_packet_alloc');
  late final _av_packet_alloc =
      _av_packet_allocPtr.asFunction<ffi.Pointer<AVPacket> Function()>();

  /// Create a new packet that references the same data as src.
  ///
  /// This is a shortcut for av_packet_alloc()+av_packet_ref().
  ///
  /// @return newly created AVPacket on success, NULL on error.
  ///
  /// @see av_packet_alloc
  /// @see av_packet_ref
  ffi.Pointer<AVPacket> av_packet_clone(
    ffi.Pointer<AVPacket> src,
  ) {
    return _av_packet_clone(
      src,
    );
  }

  late final _av_packet_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVPacket> Function(
              ffi.Pointer<AVPacket>)>>('av_packet_clone');
  late final _av_packet_clone = _av_packet_clonePtr
      .asFunction<ffi.Pointer<AVPacket> Function(ffi.Pointer<AVPacket>)>();

  /// Free the packet, if the packet is reference counted, it will be
  /// unreferenced first.
  ///
  /// @param pkt packet to be freed. The pointer will be set to NULL.
  /// @note passing NULL is a no-op.
  void av_packet_free(
    ffi.Pointer<ffi.Pointer<AVPacket>> pkt,
  ) {
    return _av_packet_free(
      pkt,
    );
  }

  late final _av_packet_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVPacket>>)>>('av_packet_free');
  late final _av_packet_free = _av_packet_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVPacket>>)>();

  /// Initialize optional fields of a packet with default values.
  ///
  /// Note, this does not touch the data and size members, which have to be
  /// initialized separately.
  ///
  /// @param pkt packet
  ///
  /// @see av_packet_alloc
  /// @see av_packet_unref
  ///
  /// @deprecated This function is deprecated. Once it's removed,
  /// sizeof(AVPacket) will not be a part of the ABI anymore.
  void av_init_packet(
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_init_packet(
      pkt,
    );
  }

  late final _av_init_packetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVPacket>)>>(
          'av_init_packet');
  late final _av_init_packet =
      _av_init_packetPtr.asFunction<void Function(ffi.Pointer<AVPacket>)>();

  /// Allocate the payload of a packet and initialize its fields with
  /// default values.
  ///
  /// @param pkt packet
  /// @param size wanted payload size
  /// @return 0 if OK, AVERROR_xxx otherwise
  int av_new_packet(
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    return _av_new_packet(
      pkt,
      size,
    );
  }

  late final _av_new_packetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVPacket>, ffi.Int)>>(
      'av_new_packet');
  late final _av_new_packet =
      _av_new_packetPtr.asFunction<int Function(ffi.Pointer<AVPacket>, int)>();

  /// Reduce packet size, correctly zeroing padding
  ///
  /// @param pkt packet
  /// @param size new size
  void av_shrink_packet(
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    return _av_shrink_packet(
      pkt,
      size,
    );
  }

  late final _av_shrink_packetPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<AVPacket>, ffi.Int)>>(
      'av_shrink_packet');
  late final _av_shrink_packet = _av_shrink_packetPtr
      .asFunction<void Function(ffi.Pointer<AVPacket>, int)>();

  /// Increase packet size, correctly zeroing padding
  ///
  /// @param pkt packet
  /// @param grow_by number of bytes by which to increase the size of the packet
  int av_grow_packet(
    ffi.Pointer<AVPacket> pkt,
    int grow_by,
  ) {
    return _av_grow_packet(
      pkt,
      grow_by,
    );
  }

  late final _av_grow_packetPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVPacket>, ffi.Int)>>(
      'av_grow_packet');
  late final _av_grow_packet =
      _av_grow_packetPtr.asFunction<int Function(ffi.Pointer<AVPacket>, int)>();

  /// Initialize a reference-counted packet from av_malloc()ed data.
  ///
  /// @param pkt packet to be initialized. This function will set the data, size,
  /// and buf fields, all others are left untouched.
  /// @param data Data allocated by av_malloc() to be used as packet data. If this
  /// function returns successfully, the data is owned by the underlying AVBuffer.
  /// The caller may not access the data through other means.
  /// @param size size of data in bytes, without the padding. I.e. the full buffer
  /// size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
  ///
  /// @return 0 on success, a negative AVERROR on error
  int av_packet_from_data(
    ffi.Pointer<AVPacket> pkt,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _av_packet_from_data(
      pkt,
      data,
      size,
    );
  }

  late final _av_packet_from_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVPacket>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_packet_from_data');
  late final _av_packet_from_data = _av_packet_from_dataPtr.asFunction<
      int Function(ffi.Pointer<AVPacket>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate new information of a packet.
  ///
  /// @param pkt packet
  /// @param type side information type
  /// @param size side information size
  /// @return pointer to fresh allocated data or NULL otherwise
  ffi.Pointer<ffi.Uint8> av_packet_new_side_data(
    ffi.Pointer<AVPacket> pkt,
    AVPacketSideDataType type,
    int size,
  ) {
    return _av_packet_new_side_data(
      pkt,
      type.value,
      size,
    );
  }

  late final _av_packet_new_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVPacket>,
              ffi.UnsignedInt, ffi.Size)>>('av_packet_new_side_data');
  late final _av_packet_new_side_data = _av_packet_new_side_dataPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVPacket>, int, int)>();

  /// Wrap an existing array as a packet side data.
  ///
  /// @param pkt packet
  /// @param type side information type
  /// @param data the side data array. It must be allocated with the av_malloc()
  /// family of functions. The ownership of the data is transferred to
  /// pkt.
  /// @param size side information size
  /// @return a non-negative number on success, a negative AVERROR code on
  /// failure. On failure, the packet is unchanged and the data remains
  /// owned by the caller.
  int av_packet_add_side_data(
    ffi.Pointer<AVPacket> pkt,
    AVPacketSideDataType type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _av_packet_add_side_data(
      pkt,
      type.value,
      data,
      size,
    );
  }

  late final _av_packet_add_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVPacket>, ffi.UnsignedInt,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('av_packet_add_side_data');
  late final _av_packet_add_side_data = _av_packet_add_side_dataPtr.asFunction<
      int Function(ffi.Pointer<AVPacket>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Shrink the already allocated side data buffer
  ///
  /// @param pkt packet
  /// @param type side information type
  /// @param size new side information size
  /// @return 0 on success, < 0 on failure
  int av_packet_shrink_side_data(
    ffi.Pointer<AVPacket> pkt,
    AVPacketSideDataType type,
    int size,
  ) {
    return _av_packet_shrink_side_data(
      pkt,
      type.value,
      size,
    );
  }

  late final _av_packet_shrink_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVPacket>, ffi.UnsignedInt,
              ffi.Size)>>('av_packet_shrink_side_data');
  late final _av_packet_shrink_side_data = _av_packet_shrink_side_dataPtr
      .asFunction<int Function(ffi.Pointer<AVPacket>, int, int)>();

  /// Get side information from packet.
  ///
  /// @param pkt packet
  /// @param type desired side information type
  /// @param size If supplied, *size will be set to the size of the side data
  /// or to zero if the desired side data is not present.
  /// @return pointer to data if present or NULL otherwise
  ffi.Pointer<ffi.Uint8> av_packet_get_side_data(
    ffi.Pointer<AVPacket> pkt,
    AVPacketSideDataType type,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_packet_get_side_data(
      pkt,
      type.value,
      size,
    );
  }

  late final _av_packet_get_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<AVPacket>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Size>)>>('av_packet_get_side_data');
  late final _av_packet_get_side_data = _av_packet_get_side_dataPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<AVPacket>, int, ffi.Pointer<ffi.Size>)>();

  /// Pack a dictionary for use in side_data.
  ///
  /// @param dict The dictionary to pack.
  /// @param size pointer to store the size of the returned data
  /// @return pointer to data if successful, NULL otherwise
  ffi.Pointer<ffi.Uint8> av_packet_pack_dictionary(
    ffi.Pointer<AVDictionary> dict,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_packet_pack_dictionary(
      dict,
      size,
    );
  }

  late final _av_packet_pack_dictionaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVDictionary>,
              ffi.Pointer<ffi.Size>)>>('av_packet_pack_dictionary');
  late final _av_packet_pack_dictionary =
      _av_packet_pack_dictionaryPtr.asFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<AVDictionary>, ffi.Pointer<ffi.Size>)>();

  /// Unpack a dictionary from side_data.
  ///
  /// @param data data from side_data
  /// @param size size of the data
  /// @param dict the metadata storage dictionary
  /// @return 0 on success, < 0 on failure
  int av_packet_unpack_dictionary(
    ffi.Pointer<ffi.Uint8> data,
    int size,
    ffi.Pointer<ffi.Pointer<AVDictionary>> dict,
  ) {
    return _av_packet_unpack_dictionary(
      data,
      size,
      dict,
    );
  }

  late final _av_packet_unpack_dictionaryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Uint8>, ffi.Size,
                  ffi.Pointer<ffi.Pointer<AVDictionary>>)>>(
      'av_packet_unpack_dictionary');
  late final _av_packet_unpack_dictionary =
      _av_packet_unpack_dictionaryPtr.asFunction<
          int Function(ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Convenience function to free all the side data stored.
  /// All the other fields stay untouched.
  ///
  /// @param pkt packet
  void av_packet_free_side_data(
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_packet_free_side_data(
      pkt,
    );
  }

  late final _av_packet_free_side_dataPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVPacket>)>>(
          'av_packet_free_side_data');
  late final _av_packet_free_side_data = _av_packet_free_side_dataPtr
      .asFunction<void Function(ffi.Pointer<AVPacket>)>();

  /// Setup a new reference to the data described by a given packet
  ///
  /// If src is reference-counted, setup dst as a new reference to the
  /// buffer in src. Otherwise allocate a new buffer in dst and copy the
  /// data from src into it.
  ///
  /// All the other fields are copied from src.
  ///
  /// @see av_packet_unref
  ///
  /// @param dst Destination packet. Will be completely overwritten.
  /// @param src Source packet
  ///
  /// @return 0 on success, a negative AVERROR on error. On error, dst
  /// will be blank (as if returned by av_packet_alloc()).
  int av_packet_ref(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    return _av_packet_ref(
      dst,
      src,
    );
  }

  late final _av_packet_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVPacket>, ffi.Pointer<AVPacket>)>>('av_packet_ref');
  late final _av_packet_ref = _av_packet_refPtr
      .asFunction<int Function(ffi.Pointer<AVPacket>, ffi.Pointer<AVPacket>)>();

  /// Wipe the packet.
  ///
  /// Unreference the buffer referenced by the packet and reset the
  /// remaining packet fields to their default values.
  ///
  /// @param pkt The packet to be unreferenced.
  void av_packet_unref(
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_packet_unref(
      pkt,
    );
  }

  late final _av_packet_unrefPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVPacket>)>>(
          'av_packet_unref');
  late final _av_packet_unref =
      _av_packet_unrefPtr.asFunction<void Function(ffi.Pointer<AVPacket>)>();

  /// Move every field in src to dst and reset src.
  ///
  /// @see av_packet_unref
  ///
  /// @param src Source packet, will be reset
  /// @param dst Destination packet
  void av_packet_move_ref(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    return _av_packet_move_ref(
      dst,
      src,
    );
  }

  late final _av_packet_move_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVPacket>,
              ffi.Pointer<AVPacket>)>>('av_packet_move_ref');
  late final _av_packet_move_ref = _av_packet_move_refPtr.asFunction<
      void Function(ffi.Pointer<AVPacket>, ffi.Pointer<AVPacket>)>();

  /// Copy only "properties" fields from src to dst.
  ///
  /// Properties for the purpose of this function are all the fields
  /// beside those related to the packet data (buf, data, size)
  ///
  /// @param dst Destination packet
  /// @param src Source packet
  ///
  /// @return 0 on success AVERROR on failure.
  int av_packet_copy_props(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    return _av_packet_copy_props(
      dst,
      src,
    );
  }

  late final _av_packet_copy_propsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVPacket>,
              ffi.Pointer<AVPacket>)>>('av_packet_copy_props');
  late final _av_packet_copy_props = _av_packet_copy_propsPtr
      .asFunction<int Function(ffi.Pointer<AVPacket>, ffi.Pointer<AVPacket>)>();

  /// Ensure the data described by a given packet is reference counted.
  ///
  /// @note This function does not ensure that the reference will be writable.
  /// Use av_packet_make_writable instead for that purpose.
  ///
  /// @see av_packet_ref
  /// @see av_packet_make_writable
  ///
  /// @param pkt packet whose data should be made reference counted.
  ///
  /// @return 0 on success, a negative AVERROR on error. On failure, the
  /// packet is unchanged.
  int av_packet_make_refcounted(
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_packet_make_refcounted(
      pkt,
    );
  }

  late final _av_packet_make_refcountedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVPacket>)>>(
          'av_packet_make_refcounted');
  late final _av_packet_make_refcounted = _av_packet_make_refcountedPtr
      .asFunction<int Function(ffi.Pointer<AVPacket>)>();

  /// Create a writable reference for the data described by a given packet,
  /// avoiding data copy if possible.
  ///
  /// @param pkt Packet whose data should be made writable.
  ///
  /// @return 0 on success, a negative AVERROR on failure. On failure, the
  /// packet is unchanged.
  int av_packet_make_writable(
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_packet_make_writable(
      pkt,
    );
  }

  late final _av_packet_make_writablePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVPacket>)>>(
          'av_packet_make_writable');
  late final _av_packet_make_writable = _av_packet_make_writablePtr
      .asFunction<int Function(ffi.Pointer<AVPacket>)>();

  /// Convert valid timing fields (timestamps / durations) in a packet from one
  /// timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
  /// ignored.
  ///
  /// @param pkt packet on which the conversion will be performed
  /// @param tb_src source timebase, in which the timing fields in pkt are
  /// expressed
  /// @param tb_dst destination timebase, to which the timing fields will be
  /// converted
  void av_packet_rescale_ts(
    ffi.Pointer<AVPacket> pkt,
    AVRational tb_src,
    AVRational tb_dst,
  ) {
    return _av_packet_rescale_ts(
      pkt,
      tb_src,
      tb_dst,
    );
  }

  late final _av_packet_rescale_tsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVPacket>, AVRational,
              AVRational)>>('av_packet_rescale_ts');
  late final _av_packet_rescale_ts = _av_packet_rescale_tsPtr.asFunction<
      void Function(ffi.Pointer<AVPacket>, AVRational, AVRational)>();

  /// @return descriptor for given codec ID or NULL if no descriptor exists.
  ffi.Pointer<AVCodecDescriptor> avcodec_descriptor_get(
    AVCodecID id,
  ) {
    return _avcodec_descriptor_get(
      id.value,
    );
  }

  late final _avcodec_descriptor_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecDescriptor> Function(
              ffi.UnsignedInt)>>('avcodec_descriptor_get');
  late final _avcodec_descriptor_get = _avcodec_descriptor_getPtr
      .asFunction<ffi.Pointer<AVCodecDescriptor> Function(int)>();

  /// Iterate over all codec descriptors known to libavcodec.
  ///
  /// @param prev previous descriptor. NULL to get the first descriptor.
  ///
  /// @return next descriptor or NULL after the last descriptor
  ffi.Pointer<AVCodecDescriptor> avcodec_descriptor_next(
    ffi.Pointer<AVCodecDescriptor> prev,
  ) {
    return _avcodec_descriptor_next(
      prev,
    );
  }

  late final _avcodec_descriptor_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecDescriptor> Function(
              ffi.Pointer<AVCodecDescriptor>)>>('avcodec_descriptor_next');
  late final _avcodec_descriptor_next = _avcodec_descriptor_nextPtr.asFunction<
      ffi.Pointer<AVCodecDescriptor> Function(
          ffi.Pointer<AVCodecDescriptor>)>();

  /// @return codec descriptor with the given name or NULL if no such descriptor
  /// exists.
  ffi.Pointer<AVCodecDescriptor> avcodec_descriptor_get_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avcodec_descriptor_get_by_name(
      name,
    );
  }

  late final _avcodec_descriptor_get_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecDescriptor> Function(
              ffi.Pointer<ffi.Char>)>>('avcodec_descriptor_get_by_name');
  late final _avcodec_descriptor_get_by_name =
      _avcodec_descriptor_get_by_namePtr.asFunction<
          ffi.Pointer<AVCodecDescriptor> Function(ffi.Pointer<ffi.Char>)>();

  /// Allocate a new AVCodecParameters and set its fields to default values
  /// (unknown/invalid/0). The returned struct must be freed with
  /// avcodec_parameters_free().
  ffi.Pointer<AVCodecParameters> avcodec_parameters_alloc() {
    return _avcodec_parameters_alloc();
  }

  late final _avcodec_parameters_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCodecParameters> Function()>>(
          'avcodec_parameters_alloc');
  late final _avcodec_parameters_alloc = _avcodec_parameters_allocPtr
      .asFunction<ffi.Pointer<AVCodecParameters> Function()>();

  /// Free an AVCodecParameters instance and everything associated with it and
  /// write NULL to the supplied pointer.
  void avcodec_parameters_free(
    ffi.Pointer<ffi.Pointer<AVCodecParameters>> par,
  ) {
    return _avcodec_parameters_free(
      par,
    );
  }

  late final _avcodec_parameters_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVCodecParameters>>)>>(
      'avcodec_parameters_free');
  late final _avcodec_parameters_free = _avcodec_parameters_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVCodecParameters>>)>();

  /// Copy the contents of src to dst. Any allocated fields in dst are freed and
  /// replaced with newly allocated duplicates of the corresponding fields in src.
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure.
  int avcodec_parameters_copy(
    ffi.Pointer<AVCodecParameters> dst,
    ffi.Pointer<AVCodecParameters> src,
  ) {
    return _avcodec_parameters_copy(
      dst,
      src,
    );
  }

  late final _avcodec_parameters_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecParameters>,
              ffi.Pointer<AVCodecParameters>)>>('avcodec_parameters_copy');
  late final _avcodec_parameters_copy = _avcodec_parameters_copyPtr.asFunction<
      int Function(
          ffi.Pointer<AVCodecParameters>, ffi.Pointer<AVCodecParameters>)>();

  /// This function is the same as av_get_audio_frame_duration(), except it works
  /// with AVCodecParameters instead of an AVCodecContext.
  int av_get_audio_frame_duration2(
    ffi.Pointer<AVCodecParameters> par,
    int frame_bytes,
  ) {
    return _av_get_audio_frame_duration2(
      par,
      frame_bytes,
    );
  }

  late final _av_get_audio_frame_duration2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecParameters>,
              ffi.Int)>>('av_get_audio_frame_duration2');
  late final _av_get_audio_frame_duration2 = _av_get_audio_frame_duration2Ptr
      .asFunction<int Function(ffi.Pointer<AVCodecParameters>, int)>();

  /// Return the LIBAVCODEC_VERSION_INT constant.
  int avcodec_version() {
    return _avcodec_version();
  }

  late final _avcodec_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'avcodec_version');
  late final _avcodec_version =
      _avcodec_versionPtr.asFunction<int Function()>();

  /// Return the libavcodec build-time configuration.
  ffi.Pointer<ffi.Char> avcodec_configuration() {
    return _avcodec_configuration();
  }

  late final _avcodec_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avcodec_configuration');
  late final _avcodec_configuration =
      _avcodec_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libavcodec license.
  ffi.Pointer<ffi.Char> avcodec_license() {
    return _avcodec_license();
  }

  late final _avcodec_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avcodec_license');
  late final _avcodec_license =
      _avcodec_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Allocate an AVCodecContext and set its fields to default values. The
  /// resulting struct should be freed with avcodec_free_context().
  ///
  /// @param codec if non-NULL, allocate private data and initialize defaults
  /// for the given codec. It is illegal to then call avcodec_open2()
  /// with a different codec.
  /// If NULL, then the codec-specific defaults won't be initialized,
  /// which may result in suboptimal default settings (this is
  /// important mainly for encoders, e.g. libx264).
  ///
  /// @return An AVCodecContext filled with default values or NULL on failure.
  ffi.Pointer<AVCodecContext> avcodec_alloc_context3(
    ffi.Pointer<AVCodec> codec,
  ) {
    return _avcodec_alloc_context3(
      codec,
    );
  }

  late final _avcodec_alloc_context3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecContext> Function(
              ffi.Pointer<AVCodec>)>>('avcodec_alloc_context3');
  late final _avcodec_alloc_context3 = _avcodec_alloc_context3Ptr
      .asFunction<ffi.Pointer<AVCodecContext> Function(ffi.Pointer<AVCodec>)>();

  /// Free the codec context and everything associated with it and write NULL to
  /// the provided pointer.
  void avcodec_free_context(
    ffi.Pointer<ffi.Pointer<AVCodecContext>> avctx,
  ) {
    return _avcodec_free_context(
      avctx,
    );
  }

  late final _avcodec_free_contextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVCodecContext>>)>>(
      'avcodec_free_context');
  late final _avcodec_free_context = _avcodec_free_contextPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVCodecContext>>)>();

  /// Get the AVClass for AVCodecContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avcodec_get_class() {
    return _avcodec_get_class();
  }

  late final _avcodec_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'avcodec_get_class');
  late final _avcodec_get_class =
      _avcodec_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Get the AVClass for AVSubtitleRect. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avcodec_get_subtitle_rect_class() {
    return _avcodec_get_subtitle_rect_class();
  }

  late final _avcodec_get_subtitle_rect_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'avcodec_get_subtitle_rect_class');
  late final _avcodec_get_subtitle_rect_class =
      _avcodec_get_subtitle_rect_classPtr
          .asFunction<ffi.Pointer<AVClass> Function()>();

  /// Fill the parameters struct based on the values from the supplied codec
  /// context. Any allocated fields in par are freed and replaced with duplicates
  /// of the corresponding fields in codec.
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure
  int avcodec_parameters_from_context(
    ffi.Pointer<AVCodecParameters> par,
    ffi.Pointer<AVCodecContext> codec,
  ) {
    return _avcodec_parameters_from_context(
      par,
      codec,
    );
  }

  late final _avcodec_parameters_from_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecParameters>,
              ffi.Pointer<AVCodecContext>)>>('avcodec_parameters_from_context');
  late final _avcodec_parameters_from_context =
      _avcodec_parameters_from_contextPtr.asFunction<
          int Function(
              ffi.Pointer<AVCodecParameters>, ffi.Pointer<AVCodecContext>)>();

  /// Fill the codec context based on the values from the supplied codec
  /// parameters. Any allocated fields in codec that have a corresponding field in
  /// par are freed and replaced with duplicates of the corresponding field in par.
  /// Fields in codec that do not have a counterpart in par are not touched.
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure.
  int avcodec_parameters_to_context(
    ffi.Pointer<AVCodecContext> codec,
    ffi.Pointer<AVCodecParameters> par,
  ) {
    return _avcodec_parameters_to_context(
      codec,
      par,
    );
  }

  late final _avcodec_parameters_to_contextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<AVCodecContext>,
                  ffi.Pointer<AVCodecParameters>)>>(
      'avcodec_parameters_to_context');
  late final _avcodec_parameters_to_context =
      _avcodec_parameters_to_contextPtr.asFunction<
          int Function(
              ffi.Pointer<AVCodecContext>, ffi.Pointer<AVCodecParameters>)>();

  /// Initialize the AVCodecContext to use the given AVCodec. Prior to using this
  /// function the context has to be allocated with avcodec_alloc_context3().
  ///
  /// The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
  /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
  /// retrieving a codec.
  ///
  /// Depending on the codec, you might need to set options in the codec context
  /// also for decoding (e.g. width, height, or the pixel or audio sample format in
  /// the case the information is not available in the bitstream, as when decoding
  /// raw audio or video).
  ///
  /// Options in the codec context can be set either by setting them in the options
  /// AVDictionary, or by setting the values in the context itself, directly or by
  /// using the av_opt_set() API before calling this function.
  ///
  /// Example:
  /// @code
  /// av_dict_set(&opts, "b", "2.5M", 0);
  /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
  /// if (!codec)
  /// exit(1);
  ///
  /// context = avcodec_alloc_context3(codec);
  ///
  /// if (avcodec_open2(context, codec, opts) < 0)
  /// exit(1);
  /// @endcode
  ///
  /// In the case AVCodecParameters are available (e.g. when demuxing a stream
  /// using libavformat, and accessing the AVStream contained in the demuxer), the
  /// codec parameters can be copied to the codec context using
  /// avcodec_parameters_to_context(), as in the following example:
  ///
  /// @code
  /// AVStream *stream = ...;
  /// context = avcodec_alloc_context3(codec);
  /// if (avcodec_parameters_to_context(context, stream->codecpar) < 0)
  /// exit(1);
  /// if (avcodec_open2(context, codec, NULL) < 0)
  /// exit(1);
  /// @endcode
  ///
  /// @note Always call this function before using decoding routines (such as
  /// @ref avcodec_receive_frame()).
  ///
  /// @param avctx The context to initialize.
  /// @param codec The codec to open this context for. If a non-NULL codec has been
  /// previously passed to avcodec_alloc_context3() or
  /// for this context, then this parameter MUST be either NULL or
  /// equal to the previously passed codec.
  /// @param options A dictionary filled with AVCodecContext and codec-private
  /// options, which are set on top of the options already set in
  /// avctx, can be NULL. On return this object will be filled with
  /// options that were not found in the avctx codec context.
  ///
  /// @return zero on success, a negative value on error
  /// @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
  /// av_dict_set(), av_opt_set(), av_opt_find(), avcodec_parameters_to_context()
  int avcodec_open2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVCodec> codec,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avcodec_open2(
      avctx,
      codec,
      options,
    );
  }

  late final _avcodec_open2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVCodec>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('avcodec_open2');
  late final _avcodec_open2 = _avcodec_open2Ptr.asFunction<
      int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVCodec>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Close a given AVCodecContext and free all the data associated with it
  /// (but not the AVCodecContext itself).
  ///
  /// Calling this function on an AVCodecContext that hasn't been opened will free
  /// the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
  /// codec. Subsequent calls will do nothing.
  ///
  /// @deprecated Do not use this function. Use avcodec_free_context() to destroy a
  /// codec context (either open or closed). Opening and closing a codec context
  /// multiple times is not supported anymore -- use multiple codec contexts
  /// instead.
  int avcodec_close(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    return _avcodec_close(
      avctx,
    );
  }

  late final _avcodec_closePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVCodecContext>)>>(
      'avcodec_close');
  late final _avcodec_close =
      _avcodec_closePtr.asFunction<int Function(ffi.Pointer<AVCodecContext>)>();

  /// Free all allocated data in the given subtitle struct.
  ///
  /// @param sub AVSubtitle to free.
  void avsubtitle_free(
    ffi.Pointer<AVSubtitle> sub,
  ) {
    return _avsubtitle_free(
      sub,
    );
  }

  late final _avsubtitle_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVSubtitle>)>>(
          'avsubtitle_free');
  late final _avsubtitle_free =
      _avsubtitle_freePtr.asFunction<void Function(ffi.Pointer<AVSubtitle>)>();

  /// The default callback for AVCodecContext.get_buffer2(). It is made public so
  /// it can be called by custom get_buffer2() implementations for decoders without
  /// AV_CODEC_CAP_DR1 set.
  int avcodec_default_get_buffer2(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    return _avcodec_default_get_buffer2(
      s,
      frame,
      flags,
    );
  }

  late final _avcodec_default_get_buffer2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('avcodec_default_get_buffer2');
  late final _avcodec_default_get_buffer2 =
      _avcodec_default_get_buffer2Ptr.asFunction<
          int Function(
              ffi.Pointer<AVCodecContext>, ffi.Pointer<AVFrame>, int)>();

  /// The default callback for AVCodecContext.get_encode_buffer(). It is made public so
  /// it can be called by custom get_encode_buffer() implementations for encoders without
  /// AV_CODEC_CAP_DR1 set.
  int avcodec_default_get_encode_buffer(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<AVPacket> pkt,
    int flags,
  ) {
    return _avcodec_default_get_encode_buffer(
      s,
      pkt,
      flags,
    );
  }

  late final _avcodec_default_get_encode_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVPacket>,
              ffi.Int)>>('avcodec_default_get_encode_buffer');
  late final _avcodec_default_get_encode_buffer =
      _avcodec_default_get_encode_bufferPtr.asFunction<
          int Function(
              ffi.Pointer<AVCodecContext>, ffi.Pointer<AVPacket>, int)>();

  /// Modify width and height values so that they will result in a memory
  /// buffer that is acceptable for the codec if you do not use any horizontal
  /// padding.
  ///
  /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
  void avcodec_align_dimensions(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
  ) {
    return _avcodec_align_dimensions(
      s,
      width,
      height,
    );
  }

  late final _avcodec_align_dimensionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('avcodec_align_dimensions');
  late final _avcodec_align_dimensions =
      _avcodec_align_dimensionsPtr.asFunction<
          void Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Modify width and height values so that they will result in a memory
  /// buffer that is acceptable for the codec if you also ensure that all
  /// line sizes are a multiple of the respective linesize_align[i].
  ///
  /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
  void avcodec_align_dimensions2(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<ffi.Int> width,
    ffi.Pointer<ffi.Int> height,
    ffi.Pointer<ffi.Int> linesize_align,
  ) {
    return _avcodec_align_dimensions2(
      s,
      width,
      height,
      linesize_align,
    );
  }

  late final _avcodec_align_dimensions2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('avcodec_align_dimensions2');
  late final _avcodec_align_dimensions2 =
      _avcodec_align_dimensions2Ptr.asFunction<
          void Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Decode a subtitle message.
  /// Return a negative value on error, otherwise return the number of bytes used.
  /// If no subtitle could be decompressed, got_sub_ptr is zero.
  /// Otherwise, the subtitle is stored in *sub.
  /// Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
  /// simplicity, because the performance difference is expected to be negligible
  /// and reusing a get_buffer written for video codecs would probably perform badly
  /// due to a potentially very different allocation pattern.
  ///
  /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
  /// and output. This means that for some packets they will not immediately
  /// produce decoded output and need to be flushed at the end of decoding to get
  /// all the decoded data. Flushing is done by calling this function with packets
  /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
  /// returning subtitles. It is safe to flush even those decoders that are not
  /// marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
  ///
  /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  /// before packets may be fed to the decoder.
  ///
  /// @param avctx the codec context
  /// @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,
  /// must be freed with avsubtitle_free if *got_sub_ptr is set.
  /// @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
  /// @param[in] avpkt The input AVPacket containing the input buffer.
  int avcodec_decode_subtitle2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVSubtitle> sub,
    ffi.Pointer<ffi.Int> got_sub_ptr,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    return _avcodec_decode_subtitle2(
      avctx,
      sub,
      got_sub_ptr,
      avpkt,
    );
  }

  late final _avcodec_decode_subtitle2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVSubtitle>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPacket>)>>('avcodec_decode_subtitle2');
  late final _avcodec_decode_subtitle2 =
      _avcodec_decode_subtitle2Ptr.asFunction<
          int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVSubtitle>,
              ffi.Pointer<ffi.Int>, ffi.Pointer<AVPacket>)>();

  /// Supply raw packet data as input to a decoder.
  ///
  /// Internally, this call will copy relevant AVCodecContext fields, which can
  /// influence decoding per-packet, and apply them when the packet is actually
  /// decoded. (For example AVCodecContext.skip_frame, which might direct the
  /// decoder to drop the frame contained by the packet sent with this function.)
  ///
  /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
  /// larger than the actual read bytes because some optimized bitstream
  /// readers read 32 or 64 bits at once and could read over the end.
  ///
  /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  /// before packets may be fed to the decoder.
  ///
  /// @param avctx codec context
  /// @param[in] avpkt The input AVPacket. Usually, this will be a single video
  /// frame, or several complete audio frames.
  /// Ownership of the packet remains with the caller, and the
  /// decoder will not write to the packet. The decoder may create
  /// a reference to the packet data (or copy it if the packet is
  /// not reference-counted).
  /// Unlike with older APIs, the packet is always fully consumed,
  /// and if it contains multiple frames (e.g. some audio codecs),
  /// will require you to call avcodec_receive_frame() multiple
  /// times afterwards before you can send a new packet.
  /// It can be NULL (or an AVPacket with data set to NULL and
  /// size set to 0); in this case, it is considered a flush
  /// packet, which signals the end of the stream. Sending the
  /// first flush packet will return success. Subsequent ones are
  /// unnecessary and will return AVERROR_EOF. If the decoder
  /// still has frames buffered, it will return them after sending
  /// a flush packet.
  ///
  /// @retval 0                 success
  /// @retval AVERROR(EAGAIN)   input is not accepted in the current state - user
  /// must read output with avcodec_receive_frame() (once
  /// all output is read, the packet should be resent,
  /// and the call will not fail with EAGAIN).
  /// @retval AVERROR_EOF       the decoder has been flushed, and no new packets can be
  /// sent to it (also returned if more than 1 flush
  /// packet is sent)
  /// @retval AVERROR(EINVAL)   codec not opened, it is an encoder, or requires flush
  /// @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
  /// @retval "another negative error code" legitimate decoding errors
  int avcodec_send_packet(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    return _avcodec_send_packet(
      avctx,
      avpkt,
    );
  }

  late final _avcodec_send_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVPacket>)>>('avcodec_send_packet');
  late final _avcodec_send_packet = _avcodec_send_packetPtr.asFunction<
      int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVPacket>)>();

  /// Return decoded output data from a decoder or encoder (when the
  /// @ref AV_CODEC_FLAG_RECON_FRAME flag is used).
  ///
  /// @param avctx codec context
  /// @param frame This will be set to a reference-counted video or audio
  /// frame (depending on the decoder type) allocated by the
  /// codec. Note that the function will always call
  /// av_frame_unref(frame) before doing anything else.
  ///
  /// @retval 0                success, a frame was returned
  /// @retval AVERROR(EAGAIN)  output is not available in this state - user must
  /// try to send new input
  /// @retval AVERROR_EOF      the codec has been fully flushed, and there will be
  /// no more output frames
  /// @retval AVERROR(EINVAL)  codec not opened, or it is an encoder without the
  /// @ref AV_CODEC_FLAG_RECON_FRAME flag enabled
  /// @retval "other negative error code" legitimate decoding errors
  int avcodec_receive_frame(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _avcodec_receive_frame(
      avctx,
      frame,
    );
  }

  late final _avcodec_receive_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVFrame>)>>('avcodec_receive_frame');
  late final _avcodec_receive_frame = _avcodec_receive_framePtr.asFunction<
      int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVFrame>)>();

  /// Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
  /// to retrieve buffered output packets.
  ///
  /// @param avctx     codec context
  /// @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
  /// Ownership of the frame remains with the caller, and the
  /// encoder will not write to the frame. The encoder may create
  /// a reference to the frame data (or copy it if the frame is
  /// not reference-counted).
  /// It can be NULL, in which case it is considered a flush
  /// packet.  This signals the end of the stream. If the encoder
  /// still has packets buffered, it will return them after this
  /// call. Once flushing mode has been entered, additional flush
  /// packets are ignored, and sending frames will return
  /// AVERROR_EOF.
  ///
  /// For audio:
  /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
  /// can have any number of samples.
  /// If it is not set, frame->nb_samples must be equal to
  /// avctx->frame_size for all frames except the last.
  /// The final frame may be smaller than avctx->frame_size.
  /// @retval 0                 success
  /// @retval AVERROR(EAGAIN)   input is not accepted in the current state - user must
  /// read output with avcodec_receive_packet() (once all
  /// output is read, the packet should be resent, and the
  /// call will not fail with EAGAIN).
  /// @retval AVERROR_EOF       the encoder has been flushed, and no new frames can
  /// be sent to it
  /// @retval AVERROR(EINVAL)   codec not opened, it is a decoder, or requires flush
  /// @retval AVERROR(ENOMEM)   failed to add packet to internal queue, or similar
  /// @retval "another negative error code" legitimate encoding errors
  int avcodec_send_frame(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _avcodec_send_frame(
      avctx,
      frame,
    );
  }

  late final _avcodec_send_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVFrame>)>>('avcodec_send_frame');
  late final _avcodec_send_frame = _avcodec_send_framePtr.asFunction<
      int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVFrame>)>();

  /// Read encoded data from the encoder.
  ///
  /// @param avctx codec context
  /// @param avpkt This will be set to a reference-counted packet allocated by the
  /// encoder. Note that the function will always call
  /// av_packet_unref(avpkt) before doing anything else.
  /// @retval 0               success
  /// @retval AVERROR(EAGAIN) output is not available in the current state - user must
  /// try to send input
  /// @retval AVERROR_EOF     the encoder has been fully flushed, and there will be no
  /// more output packets
  /// @retval AVERROR(EINVAL) codec not opened, or it is a decoder
  /// @retval "another negative error code" legitimate encoding errors
  int avcodec_receive_packet(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    return _avcodec_receive_packet(
      avctx,
      avpkt,
    );
  }

  late final _avcodec_receive_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVPacket>)>>('avcodec_receive_packet');
  late final _avcodec_receive_packet = _avcodec_receive_packetPtr.asFunction<
      int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVPacket>)>();

  /// Create and return a AVHWFramesContext with values adequate for hardware
  /// decoding. This is meant to get called from the get_format callback, and is
  /// a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
  /// This API is for decoding with certain hardware acceleration modes/APIs only.
  ///
  /// The returned AVHWFramesContext is not initialized. The caller must do this
  /// with av_hwframe_ctx_init().
  ///
  /// Calling this function is not a requirement, but makes it simpler to avoid
  /// codec or hardware API specific details when manually allocating frames.
  ///
  /// Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
  /// which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
  /// it unnecessary to call this function or having to care about
  /// AVHWFramesContext initialization at all.
  ///
  /// There are a number of requirements for calling this function:
  ///
  /// - It must be called from get_format with the same avctx parameter that was
  /// passed to get_format. Calling it outside of get_format is not allowed, and
  /// can trigger undefined behavior.
  /// - The function is not always supported (see description of return values).
  /// Even if this function returns successfully, hwaccel initialization could
  /// fail later. (The degree to which implementations check whether the stream
  /// is actually supported varies. Some do this check only after the user's
  /// get_format callback returns.)
  /// - The hw_pix_fmt must be one of the choices suggested by get_format. If the
  /// user decides to use a AVHWFramesContext prepared with this API function,
  /// the user must return the same hw_pix_fmt from get_format.
  /// - The device_ref passed to this function must support the given hw_pix_fmt.
  /// - After calling this API function, it is the user's responsibility to
  /// initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
  /// and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
  /// before returning from get_format (this is implied by the normal
  /// AVCodecContext.hw_frames_ctx API rules).
  /// - The AVHWFramesContext parameters may change every time time get_format is
  /// called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
  /// you are inherently required to go through this process again on every
  /// get_format call.
  /// - It is perfectly possible to call this function without actually using
  /// the resulting AVHWFramesContext. One use-case might be trying to reuse a
  /// previously initialized AVHWFramesContext, and calling this API function
  /// only to test whether the required frame parameters have changed.
  /// - Fields that use dynamically allocated values of any kind must not be set
  /// by the user unless setting them is explicitly allowed by the documentation.
  /// If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
  /// the new free callback must call the potentially set previous free callback.
  /// This API call may set any dynamically allocated fields, including the free
  /// callback.
  ///
  /// The function will set at least the following fields on AVHWFramesContext
  /// (potentially more, depending on hwaccel API):
  ///
  /// - All fields set by av_hwframe_ctx_alloc().
  /// - Set the format field to hw_pix_fmt.
  /// - Set the sw_format field to the most suited and most versatile format. (An
  /// implication is that this will prefer generic formats over opaque formats
  /// with arbitrary restrictions, if possible.)
  /// - Set the width/height fields to the coded frame size, rounded up to the
  /// API-specific minimum alignment.
  /// - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
  /// field to the number of maximum reference surfaces possible with the codec,
  /// plus 1 surface for the user to work (meaning the user can safely reference
  /// at most 1 decoded surface at a time), plus additional buffering introduced
  /// by frame threading. If the hwaccel does not require pre-allocation, the
  /// field is left to 0, and the decoder will allocate new surfaces on demand
  /// during decoding.
  /// - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
  /// hardware API.
  ///
  /// Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
  /// with basic frame parameters set.
  ///
  /// The function is stateless, and does not change the AVCodecContext or the
  /// device_ref AVHWDeviceContext.
  ///
  /// @param avctx The context which is currently calling get_format, and which
  /// implicitly contains all state needed for filling the returned
  /// AVHWFramesContext properly.
  /// @param device_ref A reference to the AVHWDeviceContext describing the device
  /// which will be used by the hardware decoder.
  /// @param hw_pix_fmt The hwaccel format you are going to return from get_format.
  /// @param out_frames_ref On success, set to a reference to an _uninitialized_
  /// AVHWFramesContext, created from the given device_ref.
  /// Fields will be set to values required for decoding.
  /// Not changed if an error is returned.
  /// @return zero on success, a negative value on error. The following error codes
  /// have special semantics:
  /// AVERROR(ENOENT): the decoder does not support this functionality. Setup
  /// is always manual, or it is a decoder which does not
  /// support setting AVCodecContext.hw_frames_ctx at all,
  /// or it is a software format.
  /// AVERROR(EINVAL): it is known that hardware decoding is not supported for
  /// this configuration, or the device_ref is not supported
  /// for the hwaccel referenced by hw_pix_fmt.
  int avcodec_get_hw_frames_parameters(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVBufferRef> device_ref,
    AVPixelFormat hw_pix_fmt,
    ffi.Pointer<ffi.Pointer<AVBufferRef>> out_frames_ref,
  ) {
    return _avcodec_get_hw_frames_parameters(
      avctx,
      device_ref,
      hw_pix_fmt.value,
      out_frames_ref,
    );
  }

  late final _avcodec_get_hw_frames_parametersPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVCodecContext>,
                  ffi.Pointer<AVBufferRef>,
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<AVBufferRef>>)>>(
      'avcodec_get_hw_frames_parameters');
  late final _avcodec_get_hw_frames_parameters =
      _avcodec_get_hw_frames_parametersPtr.asFunction<
          int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVBufferRef>,
              int, ffi.Pointer<ffi.Pointer<AVBufferRef>>)>();

  /// Retrieve a list of all supported values for a given configuration type.
  ///
  /// @param avctx An optional context to use. Values such as
  /// `strict_std_compliance` may affect the result. If NULL,
  /// default values are used.
  /// @param codec The codec to query, or NULL to use avctx->codec.
  /// @param config The configuration to query.
  /// @param flags Currently unused; should be set to zero.
  /// @param out_configs On success, set to a list of configurations, terminated
  /// by a config-specific terminator, or NULL if all
  /// possible values are supported.
  /// @param out_num_configs On success, set to the number of elements in
  /// out_configs, excluding the terminator. Optional.
  int avcodec_get_supported_config(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVCodec> codec,
    AVCodecConfig config,
    int flags,
    ffi.Pointer<ffi.Pointer<ffi.Void>> out_configs,
    ffi.Pointer<ffi.Int> out_num_configs,
  ) {
    return _avcodec_get_supported_config(
      avctx,
      codec,
      config.value,
      flags,
      out_configs,
      out_num_configs,
    );
  }

  late final _avcodec_get_supported_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVCodec>,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<ffi.Int>)>>('avcodec_get_supported_config');
  late final _avcodec_get_supported_config =
      _avcodec_get_supported_configPtr.asFunction<
          int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<AVCodec>, int,
              int, ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Pointer<ffi.Int>)>();

  /// Iterate over all registered codec parsers.
  ///
  /// @param opaque a pointer where libavcodec will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered codec parser or NULL when the iteration is
  /// finished
  ffi.Pointer<AVCodecParser> av_parser_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_parser_iterate(
      opaque,
    );
  }

  late final _av_parser_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecParser> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_parser_iterate');
  late final _av_parser_iterate = _av_parser_iteratePtr.asFunction<
      ffi.Pointer<AVCodecParser> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  ffi.Pointer<AVCodecParserContext> av_parser_init(
    int codec_id,
  ) {
    return _av_parser_init(
      codec_id,
    );
  }

  late final _av_parser_initPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<AVCodecParserContext> Function(ffi.Int)>>(
      'av_parser_init');
  late final _av_parser_init = _av_parser_initPtr
      .asFunction<ffi.Pointer<AVCodecParserContext> Function(int)>();

  /// Parse a packet.
  ///
  /// @param s             parser context.
  /// @param avctx         codec context.
  /// @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
  /// @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
  /// @param buf           input buffer.
  /// @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
  /// size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
  /// To signal EOF, this should be 0 (so that the last frame
  /// can be output).
  /// @param pts           input presentation timestamp.
  /// @param dts           input decoding timestamp.
  /// @param pos           input byte position in stream.
  /// @return the number of bytes of the input bitstream used.
  ///
  /// Example:
  /// @code
  /// while(in_len){
  /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
  /// in_data, in_len,
  /// pts, dts, pos);
  /// in_data += len;
  /// in_len  -= len;
  ///
  /// if(size)
  /// decode_frame(data, size);
  /// }
  /// @endcode
  int av_parser_parse2(
    ffi.Pointer<AVCodecParserContext> s,
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
    ffi.Pointer<ffi.Int> poutbuf_size,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    int pts,
    int dts,
    int pos,
  ) {
    return _av_parser_parse2(
      s,
      avctx,
      poutbuf,
      poutbuf_size,
      buf,
      buf_size,
      pts,
      dts,
      pos,
    );
  }

  late final _av_parser_parse2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecParserContext>,
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int64,
              ffi.Int64,
              ffi.Int64)>>('av_parser_parse2');
  late final _av_parser_parse2 = _av_parser_parse2Ptr.asFunction<
      int Function(
          ffi.Pointer<AVCodecParserContext>,
          ffi.Pointer<AVCodecContext>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Uint8>,
          int,
          int,
          int,
          int)>();

  void av_parser_close(
    ffi.Pointer<AVCodecParserContext> s,
  ) {
    return _av_parser_close(
      s,
    );
  }

  late final _av_parser_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVCodecParserContext>)>>('av_parser_close');
  late final _av_parser_close = _av_parser_closePtr
      .asFunction<void Function(ffi.Pointer<AVCodecParserContext>)>();

  /// @addtogroup lavc_encoding
  /// @{
  int avcodec_encode_subtitle(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    ffi.Pointer<AVSubtitle> sub,
  ) {
    return _avcodec_encode_subtitle(
      avctx,
      buf,
      buf_size,
      sub,
    );
  }

  late final _avcodec_encode_subtitlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<ffi.Uint8>,
              ffi.Int, ffi.Pointer<AVSubtitle>)>>('avcodec_encode_subtitle');
  late final _avcodec_encode_subtitle = _avcodec_encode_subtitlePtr.asFunction<
      int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<AVSubtitle>)>();

  /// Return a value representing the fourCC code associated to the
  /// pixel format pix_fmt, or 0 if no associated fourCC code can be
  /// found.
  int avcodec_pix_fmt_to_codec_tag(
    AVPixelFormat pix_fmt,
  ) {
    return _avcodec_pix_fmt_to_codec_tag(
      pix_fmt.value,
    );
  }

  late final _avcodec_pix_fmt_to_codec_tagPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int)>>(
          'avcodec_pix_fmt_to_codec_tag');
  late final _avcodec_pix_fmt_to_codec_tag =
      _avcodec_pix_fmt_to_codec_tagPtr.asFunction<int Function(int)>();

  /// Find the best pixel format to convert to given a certain source pixel
  /// format.  When converting from one pixel format to another, information loss
  /// may occur.  For example, when converting from RGB24 to GRAY, the color
  /// information will be lost. Similarly, other losses occur when converting from
  /// some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
  /// the given pixel formats should be used to suffer the least amount of loss.
  /// The pixel formats from which it chooses one, are determined by the
  /// pix_fmt_list parameter.
  ///
  ///
  /// @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
  /// @param[in] src_pix_fmt source pixel format
  /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
  /// @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
  /// @return The best pixel format to convert to or -1 if none was found.
  AVPixelFormat avcodec_find_best_pix_fmt_of_list(
    ffi.Pointer<ffi.Int> pix_fmt_list,
    AVPixelFormat src_pix_fmt,
    int has_alpha,
    ffi.Pointer<ffi.Int> loss_ptr,
  ) {
    return AVPixelFormat.fromValue(_avcodec_find_best_pix_fmt_of_list(
      pix_fmt_list,
      src_pix_fmt.value,
      has_alpha,
      loss_ptr,
    ));
  }

  late final _avcodec_find_best_pix_fmt_of_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('avcodec_find_best_pix_fmt_of_list');
  late final _avcodec_find_best_pix_fmt_of_list =
      _avcodec_find_best_pix_fmt_of_listPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, int, int, ffi.Pointer<ffi.Int>)>();

  AVPixelFormat avcodec_default_get_format(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<ffi.Int> fmt,
  ) {
    return AVPixelFormat.fromValue(_avcodec_default_get_format(
      s,
      fmt,
    ));
  }

  late final _avcodec_default_get_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>,
              ffi.Pointer<ffi.Int>)>>('avcodec_default_get_format');
  late final _avcodec_default_get_format =
      _avcodec_default_get_formatPtr.asFunction<
          int Function(ffi.Pointer<AVCodecContext>, ffi.Pointer<ffi.Int>)>();

  /// @}
  void avcodec_string(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    ffi.Pointer<AVCodecContext> enc,
    int encode,
  ) {
    return _avcodec_string(
      buf,
      buf_size,
      enc,
      encode,
    );
  }

  late final _avcodec_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<AVCodecContext>, ffi.Int)>>('avcodec_string');
  late final _avcodec_string = _avcodec_stringPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<AVCodecContext>, int)>();

  int avcodec_default_execute(
    ffi.Pointer<AVCodecContext> c,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<AVCodecContext> c2,
                    ffi.Pointer<ffi.Void> arg2)>>
        func,
    ffi.Pointer<ffi.Void> arg,
    ffi.Pointer<ffi.Int> ret,
    int count,
    int size,
  ) {
    return _avcodec_default_execute(
      c,
      func,
      arg,
      ret,
      count,
      size,
    );
  }

  late final _avcodec_default_executePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<AVCodecContext> c2,
                          ffi.Pointer<ffi.Void> arg2)>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int)>>('avcodec_default_execute');
  late final _avcodec_default_execute = _avcodec_default_executePtr.asFunction<
      int Function(
          ffi.Pointer<AVCodecContext>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<AVCodecContext> c2,
                      ffi.Pointer<ffi.Void> arg2)>>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Int>,
          int,
          int)>();

  int avcodec_default_execute2(
    ffi.Pointer<AVCodecContext> c,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<AVCodecContext>,
                    ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>
        func,
    ffi.Pointer<ffi.Void> arg,
    ffi.Pointer<ffi.Int> ret,
    int count,
  ) {
    return _avcodec_default_execute2(
      c,
      func,
      arg,
      ret,
      count,
    );
  }

  late final _avcodec_default_execute2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<AVCodecContext>,
                          ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int>,
              ffi.Int)>>('avcodec_default_execute2');
  late final _avcodec_default_execute2 =
      _avcodec_default_execute2Ptr.asFunction<
          int Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<AVCodecContext>,
                          ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int)>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int>,
              int)>();

  /// Fill AVFrame audio data and linesize pointers.
  ///
  /// The buffer buf must be a preallocated buffer with a size big enough
  /// to contain the specified samples amount. The filled AVFrame data
  /// pointers will point to this buffer.
  ///
  /// AVFrame extended_data channel pointers are allocated if necessary for
  /// planar audio.
  ///
  /// @param frame       the AVFrame
  /// frame->nb_samples must be set prior to calling the
  /// function. This function fills in frame->data,
  /// frame->extended_data, frame->linesize[0].
  /// @param nb_channels channel count
  /// @param sample_fmt  sample format
  /// @param buf         buffer to use for frame data
  /// @param buf_size    size of buffer
  /// @param align       plane size sample alignment (0 = default)
  /// @return            >=0 on success, negative error code on failure
  /// @todo return the size in bytes required to store the samples in
  /// case of success, at the next libavutil bump
  int avcodec_fill_audio_frame(
    ffi.Pointer<AVFrame> frame,
    int nb_channels,
    AVSampleFormat sample_fmt,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    int align,
  ) {
    return _avcodec_fill_audio_frame(
      frame,
      nb_channels,
      sample_fmt.value,
      buf,
      buf_size,
      align,
    );
  }

  late final _avcodec_fill_audio_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFrame>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int)>>('avcodec_fill_audio_frame');
  late final _avcodec_fill_audio_frame =
      _avcodec_fill_audio_framePtr.asFunction<
          int Function(ffi.Pointer<AVFrame>, int, int, ffi.Pointer<ffi.Uint8>,
              int, int)>();

  /// Reset the internal codec state / flush internal buffers. Should be called
  /// e.g. when seeking or when switching to a different stream.
  ///
  /// @note for decoders, this function just releases any references the decoder
  /// might keep internally, but the caller's references remain valid.
  ///
  /// @note for encoders, this function will only do something if the encoder
  /// declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder
  /// will drain any remaining packets, and can then be re-used for a different
  /// stream (as opposed to sending a null frame which will leave the encoder
  /// in a permanent EOF state after draining). This can be desirable if the
  /// cost of tearing down and replacing the encoder instance is high.
  void avcodec_flush_buffers(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    return _avcodec_flush_buffers(
      avctx,
    );
  }

  late final _avcodec_flush_buffersPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVCodecContext>)>>(
      'avcodec_flush_buffers');
  late final _avcodec_flush_buffers = _avcodec_flush_buffersPtr
      .asFunction<void Function(ffi.Pointer<AVCodecContext>)>();

  /// Return audio frame duration.
  ///
  /// @param avctx        codec context
  /// @param frame_bytes  size of the frame, or 0 if unknown
  /// @return             frame duration, in samples, if known. 0 if not able to
  /// determine.
  int av_get_audio_frame_duration(
    ffi.Pointer<AVCodecContext> avctx,
    int frame_bytes,
  ) {
    return _av_get_audio_frame_duration(
      avctx,
      frame_bytes,
    );
  }

  late final _av_get_audio_frame_durationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext>,
              ffi.Int)>>('av_get_audio_frame_duration');
  late final _av_get_audio_frame_duration = _av_get_audio_frame_durationPtr
      .asFunction<int Function(ffi.Pointer<AVCodecContext>, int)>();

  /// Same behaviour av_fast_malloc but the buffer has additional
  /// AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
  ///
  /// In addition the whole buffer will initially and after resizes
  /// be 0-initialized so that no uninitialized data will ever appear.
  void av_fast_padded_malloc(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.UnsignedInt> size,
    int min_size,
  ) {
    return _av_fast_padded_malloc(
      ptr,
      size,
      min_size,
    );
  }

  late final _av_fast_padded_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Size)>>('av_fast_padded_malloc');
  late final _av_fast_padded_malloc = _av_fast_padded_mallocPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Same behaviour av_fast_padded_malloc except that buffer will always
  /// be 0-initialized after call.
  void av_fast_padded_mallocz(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.UnsignedInt> size,
    int min_size,
  ) {
    return _av_fast_padded_mallocz(
      ptr,
      size,
      min_size,
    );
  }

  late final _av_fast_padded_malloczPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Size)>>('av_fast_padded_mallocz');
  late final _av_fast_padded_mallocz = _av_fast_padded_malloczPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// @return a positive value if s is open (i.e. avcodec_open2() was called on it
  /// with no corresponding avcodec_close()), 0 otherwise.
  int avcodec_is_open(
    ffi.Pointer<AVCodecContext> s,
  ) {
    return _avcodec_is_open(
      s,
    );
  }

  late final _avcodec_is_openPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVCodecContext>)>>(
      'avcodec_is_open');
  late final _avcodec_is_open = _avcodec_is_openPtr
      .asFunction<int Function(ffi.Pointer<AVCodecContext>)>();

  /// Allocate and initialize a MediaCodec context.
  ///
  /// When decoding with MediaCodec is finished, the caller must free the
  /// MediaCodec context with av_mediacodec_default_free.
  ///
  /// @return a pointer to a newly allocated AVMediaCodecContext on success, NULL otherwise
  ffi.Pointer<AVMediaCodecContext> av_mediacodec_alloc_context() {
    return _av_mediacodec_alloc_context();
  }

  late final _av_mediacodec_alloc_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVMediaCodecContext> Function()>>(
          'av_mediacodec_alloc_context');
  late final _av_mediacodec_alloc_context = _av_mediacodec_alloc_contextPtr
      .asFunction<ffi.Pointer<AVMediaCodecContext> Function()>();

  /// Convenience function that sets up the MediaCodec context.
  ///
  /// @param avctx codec context
  /// @param ctx MediaCodec context to initialize
  /// @param surface reference to an android/view/Surface
  /// @return 0 on success, < 0 otherwise
  int av_mediacodec_default_init(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVMediaCodecContext> ctx,
    ffi.Pointer<ffi.Void> surface,
  ) {
    return _av_mediacodec_default_init(
      avctx,
      ctx,
      surface,
    );
  }

  late final _av_mediacodec_default_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVMediaCodecContext>,
              ffi.Pointer<ffi.Void>)>>('av_mediacodec_default_init');
  late final _av_mediacodec_default_init =
      _av_mediacodec_default_initPtr.asFunction<
          int Function(ffi.Pointer<AVCodecContext>,
              ffi.Pointer<AVMediaCodecContext>, ffi.Pointer<ffi.Void>)>();

  /// This function must be called to free the MediaCodec context initialized with
  /// av_mediacodec_default_init().
  ///
  /// @param avctx codec context
  void av_mediacodec_default_free(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    return _av_mediacodec_default_free(
      avctx,
    );
  }

  late final _av_mediacodec_default_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVCodecContext>)>>(
      'av_mediacodec_default_free');
  late final _av_mediacodec_default_free = _av_mediacodec_default_freePtr
      .asFunction<void Function(ffi.Pointer<AVCodecContext>)>();

  /// Release a MediaCodec buffer and render it to the surface that is associated
  /// with the decoder. This function should only be called once on a given
  /// buffer, once released the underlying buffer returns to the codec, thus
  /// subsequent calls to this function will have no effect.
  ///
  /// @param buffer the buffer to render
  /// @param render 1 to release and render the buffer to the surface or 0 to
  /// discard the buffer
  /// @return 0 on success, < 0 otherwise
  int av_mediacodec_release_buffer(
    ffi.Pointer<AVMediaCodecBuffer> buffer,
    int render,
  ) {
    return _av_mediacodec_release_buffer(
      buffer,
      render,
    );
  }

  late final _av_mediacodec_release_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVMediaCodecBuffer>,
              ffi.Int)>>('av_mediacodec_release_buffer');
  late final _av_mediacodec_release_buffer = _av_mediacodec_release_bufferPtr
      .asFunction<int Function(ffi.Pointer<AVMediaCodecBuffer>, int)>();

  /// Release a MediaCodec buffer and render it at the given time to the surface
  /// that is associated with the decoder. The timestamp must be within one second
  /// of the current `java/lang/System#nanoTime()` (which is implemented using
  /// `CLOCK_MONOTONIC` on Android). See the Android MediaCodec documentation
  /// of [`android/media/MediaCodec#releaseOutputBuffer(int,long)`][0] for more details.
  ///
  /// @param buffer the buffer to render
  /// @param time timestamp in nanoseconds of when to render the buffer
  /// @return 0 on success, < 0 otherwise
  ///
  /// [0]: https://developer.android.com/reference/android/media/MediaCodec#releaseOutputBuffer(int,%20long)
  int av_mediacodec_render_buffer_at_time(
    ffi.Pointer<AVMediaCodecBuffer> buffer,
    int time,
  ) {
    return _av_mediacodec_render_buffer_at_time(
      buffer,
      time,
    );
  }

  late final _av_mediacodec_render_buffer_at_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVMediaCodecBuffer>,
              ffi.Int64)>>('av_mediacodec_render_buffer_at_time');
  late final _av_mediacodec_render_buffer_at_time =
      _av_mediacodec_render_buffer_at_timePtr
          .asFunction<int Function(ffi.Pointer<AVMediaCodecBuffer>, int)>();

  /// Set up a complex FFT.
  /// @param nbits           log2 of the length of the input array
  /// @param inverse         if 0 perform the forward transform, if 1 perform the inverse
  /// @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_FFT
  ffi.Pointer<FFTContext> av_fft_init(
    int nbits,
    int inverse,
  ) {
    return _av_fft_init(
      nbits,
      inverse,
    );
  }

  late final _av_fft_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FFTContext> Function(ffi.Int, ffi.Int)>>('av_fft_init');
  late final _av_fft_init =
      _av_fft_initPtr.asFunction<ffi.Pointer<FFTContext> Function(int, int)>();

  /// Do the permutation needed BEFORE calling ff_fft_calc().
  /// @deprecated without replacement
  void av_fft_permute(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTComplex> z,
  ) {
    return _av_fft_permute(
      s,
      z,
    );
  }

  late final _av_fft_permutePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FFTContext>,
              ffi.Pointer<FFTComplex>)>>('av_fft_permute');
  late final _av_fft_permute = _av_fft_permutePtr.asFunction<
      void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTComplex>)>();

  /// Do a complex FFT with the parameters defined in av_fft_init(). The
  /// input data must be permuted before. No 1.0/sqrt(n) normalization is done.
  /// @deprecated use the av_tx_fn value returned by av_tx_init, which also does permutation
  void av_fft_calc(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTComplex> z,
  ) {
    return _av_fft_calc(
      s,
      z,
    );
  }

  late final _av_fft_calcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FFTContext>,
              ffi.Pointer<FFTComplex>)>>('av_fft_calc');
  late final _av_fft_calc = _av_fft_calcPtr.asFunction<
      void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTComplex>)>();

  void av_fft_end(
    ffi.Pointer<FFTContext> s,
  ) {
    return _av_fft_end(
      s,
    );
  }

  late final _av_fft_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FFTContext>)>>(
          'av_fft_end');
  late final _av_fft_end =
      _av_fft_endPtr.asFunction<void Function(ffi.Pointer<FFTContext>)>();

  /// @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_MDCT,
  /// with a flag of AV_TX_FULL_IMDCT for a replacement to av_imdct_calc.
  ffi.Pointer<FFTContext> av_mdct_init(
    int nbits,
    int inverse,
    double scale,
  ) {
    return _av_mdct_init(
      nbits,
      inverse,
      scale,
    );
  }

  late final _av_mdct_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<FFTContext> Function(
              ffi.Int, ffi.Int, ffi.Double)>>('av_mdct_init');
  late final _av_mdct_init = _av_mdct_initPtr
      .asFunction<ffi.Pointer<FFTContext> Function(int, int, double)>();

  void av_imdct_calc(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTSample> output,
    ffi.Pointer<FFTSample> input,
  ) {
    return _av_imdct_calc(
      s,
      output,
      input,
    );
  }

  late final _av_imdct_calcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTSample>,
              ffi.Pointer<FFTSample>)>>('av_imdct_calc');
  late final _av_imdct_calc = _av_imdct_calcPtr.asFunction<
      void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTSample>,
          ffi.Pointer<FFTSample>)>();

  void av_imdct_half(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTSample> output,
    ffi.Pointer<FFTSample> input,
  ) {
    return _av_imdct_half(
      s,
      output,
      input,
    );
  }

  late final _av_imdct_halfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTSample>,
              ffi.Pointer<FFTSample>)>>('av_imdct_half');
  late final _av_imdct_half = _av_imdct_halfPtr.asFunction<
      void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTSample>,
          ffi.Pointer<FFTSample>)>();

  void av_mdct_calc(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTSample> output,
    ffi.Pointer<FFTSample> input,
  ) {
    return _av_mdct_calc(
      s,
      output,
      input,
    );
  }

  late final _av_mdct_calcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTSample>,
              ffi.Pointer<FFTSample>)>>('av_mdct_calc');
  late final _av_mdct_calc = _av_mdct_calcPtr.asFunction<
      void Function(ffi.Pointer<FFTContext>, ffi.Pointer<FFTSample>,
          ffi.Pointer<FFTSample>)>();

  void av_mdct_end(
    ffi.Pointer<FFTContext> s,
  ) {
    return _av_mdct_end(
      s,
    );
  }

  late final _av_mdct_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<FFTContext>)>>(
          'av_mdct_end');
  late final _av_mdct_end =
      _av_mdct_endPtr.asFunction<void Function(ffi.Pointer<FFTContext>)>();

  /// Set up a real FFT.
  /// @param nbits           log2 of the length of the input array
  /// @param trans           the type of transform
  ///
  /// @deprecated use av_tx_init from libavutil/tx.h with a type of AV_TX_FLOAT_RDFT
  ffi.Pointer<RDFTContext> av_rdft_init(
    int nbits,
    RDFTransformType trans,
  ) {
    return _av_rdft_init(
      nbits,
      trans.value,
    );
  }

  late final _av_rdft_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<RDFTContext> Function(
              ffi.Int, ffi.UnsignedInt)>>('av_rdft_init');
  late final _av_rdft_init = _av_rdft_initPtr
      .asFunction<ffi.Pointer<RDFTContext> Function(int, int)>();

  void av_rdft_calc(
    ffi.Pointer<RDFTContext> s,
    ffi.Pointer<FFTSample> data,
  ) {
    return _av_rdft_calc(
      s,
      data,
    );
  }

  late final _av_rdft_calcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<RDFTContext>,
              ffi.Pointer<FFTSample>)>>('av_rdft_calc');
  late final _av_rdft_calc = _av_rdft_calcPtr.asFunction<
      void Function(ffi.Pointer<RDFTContext>, ffi.Pointer<FFTSample>)>();

  void av_rdft_end(
    ffi.Pointer<RDFTContext> s,
  ) {
    return _av_rdft_end(
      s,
    );
  }

  late final _av_rdft_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<RDFTContext>)>>(
          'av_rdft_end');
  late final _av_rdft_end =
      _av_rdft_endPtr.asFunction<void Function(ffi.Pointer<RDFTContext>)>();

  /// Set up DCT.
  ///
  /// @param nbits           size of the input array:
  /// (1 << nbits)     for DCT-II, DCT-III and DST-I
  /// (1 << nbits) + 1 for DCT-I
  /// @param type            the type of transform
  ///
  /// @note the first element of the input of DST-I is ignored
  ///
  /// @deprecated use av_tx_init from libavutil/tx.h with an appropriate type of AV_TX_FLOAT_DCT
  ffi.Pointer<DCTContext> av_dct_init(
    int nbits,
    DCTTransformType type,
  ) {
    return _av_dct_init(
      nbits,
      type.value,
    );
  }

  late final _av_dct_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<DCTContext> Function(
              ffi.Int, ffi.UnsignedInt)>>('av_dct_init');
  late final _av_dct_init =
      _av_dct_initPtr.asFunction<ffi.Pointer<DCTContext> Function(int, int)>();

  void av_dct_calc(
    ffi.Pointer<DCTContext> s,
    ffi.Pointer<FFTSample> data,
  ) {
    return _av_dct_calc(
      s,
      data,
    );
  }

  late final _av_dct_calcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<DCTContext>, ffi.Pointer<FFTSample>)>>('av_dct_calc');
  late final _av_dct_calc = _av_dct_calcPtr.asFunction<
      void Function(ffi.Pointer<DCTContext>, ffi.Pointer<FFTSample>)>();

  void av_dct_end(
    ffi.Pointer<DCTContext> s,
  ) {
    return _av_dct_end(
      s,
    );
  }

  late final _av_dct_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<DCTContext>)>>(
          'av_dct_end');
  late final _av_dct_end =
      _av_dct_endPtr.asFunction<void Function(ffi.Pointer<DCTContext>)>();

  int av_jni_set_java_vm(
    ffi.Pointer<ffi.Void> vm,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_jni_set_java_vm(
      vm,
      log_ctx,
    );
  }

  late final _av_jni_set_java_vmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('av_jni_set_java_vm');
  late final _av_jni_set_java_vm = _av_jni_set_java_vmPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> av_jni_get_java_vm(
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_jni_get_java_vm(
      log_ctx,
    );
  }

  late final _av_jni_get_java_vmPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>)>>('av_jni_get_java_vm');
  late final _av_jni_get_java_vm = _av_jni_get_java_vmPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>)>();

  int av_jni_set_android_app_ctx(
    ffi.Pointer<ffi.Void> app_ctx,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_jni_set_android_app_ctx(
      app_ctx,
      log_ctx,
    );
  }

  late final _av_jni_set_android_app_ctxPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('av_jni_set_android_app_ctx');
  late final _av_jni_set_android_app_ctx = _av_jni_set_android_app_ctxPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> av_jni_get_android_app_ctx() {
    return _av_jni_get_android_app_ctx();
  }

  late final _av_jni_get_android_app_ctxPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function()>>(
          'av_jni_get_android_app_ctx');
  late final _av_jni_get_android_app_ctx = _av_jni_get_android_app_ctxPtr
      .asFunction<ffi.Pointer<ffi.Void> Function()>();

  /// @return a bitstream filter with the specified name or NULL if no such
  /// bitstream filter exists.
  ffi.Pointer<AVBitStreamFilter> av_bsf_get_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_bsf_get_by_name(
      name,
    );
  }

  late final _av_bsf_get_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBitStreamFilter> Function(
              ffi.Pointer<ffi.Char>)>>('av_bsf_get_by_name');
  late final _av_bsf_get_by_name = _av_bsf_get_by_namePtr.asFunction<
      ffi.Pointer<AVBitStreamFilter> Function(ffi.Pointer<ffi.Char>)>();

  /// Iterate over all registered bitstream filters.
  ///
  /// @param opaque a pointer where libavcodec will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered bitstream filter or NULL when the iteration is
  /// finished
  ffi.Pointer<AVBitStreamFilter> av_bsf_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_bsf_iterate(
      opaque,
    );
  }

  late final _av_bsf_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVBitStreamFilter> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_bsf_iterate');
  late final _av_bsf_iterate = _av_bsf_iteratePtr.asFunction<
      ffi.Pointer<AVBitStreamFilter> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Allocate a context for a given bitstream filter. The caller must fill in the
  /// context parameters as described in the documentation and then call
  /// av_bsf_init() before sending any data to the filter.
  ///
  /// @param filter the filter for which to allocate an instance.
  /// @param[out] ctx a pointer into which the pointer to the newly-allocated context
  /// will be written. It must be freed with av_bsf_free() after the
  /// filtering is done.
  ///
  /// @return 0 on success, a negative AVERROR code on failure
  int av_bsf_alloc(
    ffi.Pointer<AVBitStreamFilter> filter,
    ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
  ) {
    return _av_bsf_alloc(
      filter,
      ctx,
    );
  }

  late final _av_bsf_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBitStreamFilter>,
              ffi.Pointer<ffi.Pointer<AVBSFContext>>)>>('av_bsf_alloc');
  late final _av_bsf_alloc = _av_bsf_allocPtr.asFunction<
      int Function(ffi.Pointer<AVBitStreamFilter>,
          ffi.Pointer<ffi.Pointer<AVBSFContext>>)>();

  /// Prepare the filter for use, after all the parameters and options have been
  /// set.
  ///
  /// @param ctx a AVBSFContext previously allocated with av_bsf_alloc()
  int av_bsf_init(
    ffi.Pointer<AVBSFContext> ctx,
  ) {
    return _av_bsf_init(
      ctx,
    );
  }

  late final _av_bsf_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVBSFContext>)>>(
          'av_bsf_init');
  late final _av_bsf_init =
      _av_bsf_initPtr.asFunction<int Function(ffi.Pointer<AVBSFContext>)>();

  /// Submit a packet for filtering.
  ///
  /// After sending each packet, the filter must be completely drained by calling
  /// av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
  /// AVERROR_EOF.
  ///
  /// @param ctx an initialized AVBSFContext
  /// @param pkt the packet to filter. The bitstream filter will take ownership of
  /// the packet and reset the contents of pkt. pkt is not touched if an error occurs.
  /// If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),
  /// it signals the end of the stream (i.e. no more non-empty packets will be sent;
  /// sending more empty packets does nothing) and will cause the filter to output
  /// any packets it may have buffered internally.
  ///
  /// @return
  /// - 0 on success.
  /// - AVERROR(EAGAIN) if packets need to be retrieved from the filter (using
  /// av_bsf_receive_packet()) before new input can be consumed.
  /// - Another negative AVERROR value if an error occurs.
  int av_bsf_send_packet(
    ffi.Pointer<AVBSFContext> ctx,
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_bsf_send_packet(
      ctx,
      pkt,
    );
  }

  late final _av_bsf_send_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBSFContext>,
              ffi.Pointer<AVPacket>)>>('av_bsf_send_packet');
  late final _av_bsf_send_packet = _av_bsf_send_packetPtr.asFunction<
      int Function(ffi.Pointer<AVBSFContext>, ffi.Pointer<AVPacket>)>();

  /// Retrieve a filtered packet.
  ///
  /// @param ctx an initialized AVBSFContext
  /// @param[out] pkt this struct will be filled with the contents of the filtered
  /// packet. It is owned by the caller and must be freed using
  /// av_packet_unref() when it is no longer needed.
  /// This parameter should be "clean" (i.e. freshly allocated
  /// with av_packet_alloc() or unreffed with av_packet_unref())
  /// when this function is called. If this function returns
  /// successfully, the contents of pkt will be completely
  /// overwritten by the returned data. On failure, pkt is not
  /// touched.
  ///
  /// @return
  /// - 0 on success.
  /// - AVERROR(EAGAIN) if more packets need to be sent to the filter (using
  /// av_bsf_send_packet()) to get more output.
  /// - AVERROR_EOF if there will be no further output from the filter.
  /// - Another negative AVERROR value if an error occurs.
  ///
  /// @note one input packet may result in several output packets, so after sending
  /// a packet with av_bsf_send_packet(), this function needs to be called
  /// repeatedly until it stops returning 0. It is also possible for a filter to
  /// output fewer packets than were sent to it, so this function may return
  /// AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
  int av_bsf_receive_packet(
    ffi.Pointer<AVBSFContext> ctx,
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_bsf_receive_packet(
      ctx,
      pkt,
    );
  }

  late final _av_bsf_receive_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBSFContext>,
              ffi.Pointer<AVPacket>)>>('av_bsf_receive_packet');
  late final _av_bsf_receive_packet = _av_bsf_receive_packetPtr.asFunction<
      int Function(ffi.Pointer<AVBSFContext>, ffi.Pointer<AVPacket>)>();

  /// Reset the internal bitstream filter state. Should be called e.g. when seeking.
  void av_bsf_flush(
    ffi.Pointer<AVBSFContext> ctx,
  ) {
    return _av_bsf_flush(
      ctx,
    );
  }

  late final _av_bsf_flushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVBSFContext>)>>(
          'av_bsf_flush');
  late final _av_bsf_flush =
      _av_bsf_flushPtr.asFunction<void Function(ffi.Pointer<AVBSFContext>)>();

  /// Free a bitstream filter context and everything associated with it; write NULL
  /// into the supplied pointer.
  void av_bsf_free(
    ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
  ) {
    return _av_bsf_free(
      ctx,
    );
  }

  late final _av_bsf_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVBSFContext>>)>>('av_bsf_free');
  late final _av_bsf_free = _av_bsf_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVBSFContext>>)>();

  /// Get the AVClass for AVBSFContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> av_bsf_get_class() {
    return _av_bsf_get_class();
  }

  late final _av_bsf_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'av_bsf_get_class');
  late final _av_bsf_get_class =
      _av_bsf_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Allocate empty list of bitstream filters.
  /// The list must be later freed by av_bsf_list_free()
  /// or finalized by av_bsf_list_finalize().
  ///
  /// @return Pointer to @ref AVBSFList on success, NULL in case of failure
  ffi.Pointer<AVBSFList> av_bsf_list_alloc() {
    return _av_bsf_list_alloc();
  }

  late final _av_bsf_list_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVBSFList> Function()>>(
          'av_bsf_list_alloc');
  late final _av_bsf_list_alloc =
      _av_bsf_list_allocPtr.asFunction<ffi.Pointer<AVBSFList> Function()>();

  /// Free list of bitstream filters.
  ///
  /// @param lst Pointer to pointer returned by av_bsf_list_alloc()
  void av_bsf_list_free(
    ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
  ) {
    return _av_bsf_list_free(
      lst,
    );
  }

  late final _av_bsf_list_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVBSFList>>)>>('av_bsf_list_free');
  late final _av_bsf_list_free = _av_bsf_list_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVBSFList>>)>();

  /// Append bitstream filter to the list of bitstream filters.
  ///
  /// @param lst List to append to
  /// @param bsf Filter context to be appended
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_append(
    ffi.Pointer<AVBSFList> lst,
    ffi.Pointer<AVBSFContext> bsf,
  ) {
    return _av_bsf_list_append(
      lst,
      bsf,
    );
  }

  late final _av_bsf_list_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBSFList>,
              ffi.Pointer<AVBSFContext>)>>('av_bsf_list_append');
  late final _av_bsf_list_append = _av_bsf_list_appendPtr.asFunction<
      int Function(ffi.Pointer<AVBSFList>, ffi.Pointer<AVBSFContext>)>();

  /// Construct new bitstream filter context given it's name and options
  /// and append it to the list of bitstream filters.
  ///
  /// @param lst      List to append to
  /// @param bsf_name Name of the bitstream filter
  /// @param options  Options for the bitstream filter, can be set to NULL
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_append2(
    ffi.Pointer<AVBSFList> lst,
    ffi.Pointer<ffi.Char> bsf_name,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _av_bsf_list_append2(
      lst,
      bsf_name,
      options,
    );
  }

  late final _av_bsf_list_append2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBSFList>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('av_bsf_list_append2');
  late final _av_bsf_list_append2 = _av_bsf_list_append2Ptr.asFunction<
      int Function(ffi.Pointer<AVBSFList>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Finalize list of bitstream filters.
  ///
  /// This function will transform @ref AVBSFList to single @ref AVBSFContext,
  /// so the whole chain of bitstream filters can be treated as single filter
  /// freshly allocated by av_bsf_alloc().
  /// If the call is successful, @ref AVBSFList structure is freed and lst
  /// will be set to NULL. In case of failure, caller is responsible for
  /// freeing the structure by av_bsf_list_free()
  ///
  /// @param      lst Filter list structure to be transformed
  /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
  /// representing the chain of bitstream filters
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_finalize(
    ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
    ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
  ) {
    return _av_bsf_list_finalize(
      lst,
      bsf,
    );
  }

  late final _av_bsf_list_finalizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVBSFList>>,
              ffi.Pointer<ffi.Pointer<AVBSFContext>>)>>('av_bsf_list_finalize');
  late final _av_bsf_list_finalize = _av_bsf_list_finalizePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVBSFList>>,
          ffi.Pointer<ffi.Pointer<AVBSFContext>>)>();

  /// Parse string describing list of bitstream filters and create single
  /// @ref AVBSFContext describing the whole chain of bitstream filters.
  /// Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
  /// allocated by av_bsf_alloc().
  ///
  /// @param      str String describing chain of bitstream filters in format
  /// `bsf1[=opt1=val1:opt2=val2][,bsf2]`
  /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
  /// representing the chain of bitstream filters
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_parse_str(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
  ) {
    return _av_bsf_list_parse_str(
      str,
      bsf,
    );
  }

  late final _av_bsf_list_parse_strPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<AVBSFContext>>)>>(
      'av_bsf_list_parse_str');
  late final _av_bsf_list_parse_str = _av_bsf_list_parse_strPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<AVBSFContext>>)>();

  /// Get null/pass-through bitstream filter.
  ///
  /// @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
  ///
  /// @return
  int av_bsf_get_null_filter(
    ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
  ) {
    return _av_bsf_get_null_filter(
      bsf,
    );
  }

  late final _av_bsf_get_null_filterPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<AVBSFContext>>)>>(
      'av_bsf_get_null_filter');
  late final _av_bsf_get_null_filter = _av_bsf_get_null_filterPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVBSFContext>>)>();

  /// Parse a Dirac sequence header.
  ///
  /// @param dsh this function will allocate and fill an AVDiracSeqHeader struct
  /// and write it into this pointer. The caller must free it with
  /// av_free().
  /// @param buf the data buffer
  /// @param buf_size the size of the data buffer in bytes
  /// @param log_ctx if non-NULL, this function will log errors here
  /// @return 0 on success, a negative AVERROR code on failure
  int av_dirac_parse_sequence_header(
    ffi.Pointer<ffi.Pointer<AVDiracSeqHeader>> dsh,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_dirac_parse_sequence_header(
      dsh,
      buf,
      buf_size,
      log_ctx,
    );
  }

  late final _av_dirac_parse_sequence_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVDiracSeqHeader>>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Void>)>>('av_dirac_parse_sequence_header');
  late final _av_dirac_parse_sequence_header =
      _av_dirac_parse_sequence_headerPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<AVDiracSeqHeader>>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Void>)>();

  /// Set the values of all AVOption fields to their default values.
  ///
  /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
  void av_opt_set_defaults(
    ffi.Pointer<ffi.Void> s,
  ) {
    return _av_opt_set_defaults(
      s,
    );
  }

  late final _av_opt_set_defaultsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'av_opt_set_defaults');
  late final _av_opt_set_defaults = _av_opt_set_defaultsPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Set the values of all AVOption fields to their default values. Only these
  /// AVOption fields for which (opt->flags & mask) == flags will have their
  /// default applied to s.
  ///
  /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
  /// @param mask combination of AV_OPT_FLAG_*
  /// @param flags combination of AV_OPT_FLAG_*
  void av_opt_set_defaults2(
    ffi.Pointer<ffi.Void> s,
    int mask,
    int flags,
  ) {
    return _av_opt_set_defaults2(
      s,
      mask,
      flags,
    );
  }

  late final _av_opt_set_defaults2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Int)>>('av_opt_set_defaults2');
  late final _av_opt_set_defaults2 = _av_opt_set_defaults2Ptr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int, int)>();

  /// Free all allocated objects in obj.
  void av_opt_free(
    ffi.Pointer<ffi.Void> obj,
  ) {
    return _av_opt_free(
      obj,
    );
  }

  late final _av_opt_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'av_opt_free');
  late final _av_opt_free =
      _av_opt_freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  /// Iterate over all AVOptions belonging to obj.
  ///
  /// @param obj an AVOptions-enabled struct or a double pointer to an
  /// AVClass describing it.
  /// @param prev result of the previous call to av_opt_next() on this object
  /// or NULL
  /// @return next AVOption or NULL
  ffi.Pointer<AVOption> av_opt_next(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> prev,
  ) {
    return _av_opt_next(
      obj,
      prev,
    );
  }

  late final _av_opt_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOption> Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>)>>('av_opt_next');
  late final _av_opt_next = _av_opt_nextPtr.asFunction<
      ffi.Pointer<AVOption> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>)>();

  /// Iterate over AVOptions-enabled children of obj.
  ///
  /// @param prev result of a previous call to this function or NULL
  /// @return next AVOptions-enabled child or NULL
  ffi.Pointer<ffi.Void> av_opt_child_next(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Void> prev,
  ) {
    return _av_opt_child_next(
      obj,
      prev,
    );
  }

  late final _av_opt_child_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>)>>('av_opt_child_next');
  late final _av_opt_child_next = _av_opt_child_nextPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// Iterate over potential AVOptions-enabled children of parent.
  ///
  /// @param iter a pointer where iteration state is stored.
  /// @return AVClass corresponding to next potential child or NULL
  ffi.Pointer<AVClass> av_opt_child_class_iterate(
    ffi.Pointer<AVClass> parent,
    ffi.Pointer<ffi.Pointer<ffi.Void>> iter,
  ) {
    return _av_opt_child_class_iterate(
      parent,
      iter,
    );
  }

  late final _av_opt_child_class_iteratePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVClass> Function(
                  ffi.Pointer<AVClass>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>>(
      'av_opt_child_class_iterate');
  late final _av_opt_child_class_iterate =
      _av_opt_child_class_iteratePtr.asFunction<
          ffi.Pointer<AVClass> Function(
              ffi.Pointer<AVClass>, ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Look for an option in an object. Consider only options which
  /// have all the specified flags set.
  ///
  /// @param[in] obj A pointer to a struct whose first element is a
  /// pointer to an AVClass.
  /// Alternatively a double pointer to an AVClass, if
  /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
  /// @param[in] name The name of the option to look for.
  /// @param[in] unit When searching for named constants, name of the unit
  /// it belongs to.
  /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
  /// @param search_flags A combination of AV_OPT_SEARCH_*.
  ///
  /// @return A pointer to the option found, or NULL if no option
  /// was found.
  ///
  /// @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable
  /// directly with av_opt_set(). Use special calls which take an options
  /// AVDictionary (e.g. avformat_open_input()) to set options found with this
  /// flag.
  ffi.Pointer<AVOption> av_opt_find(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> unit,
    int opt_flags,
    int search_flags,
  ) {
    return _av_opt_find(
      obj,
      name,
      unit,
      opt_flags,
      search_flags,
    );
  }

  late final _av_opt_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOption> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('av_opt_find');
  late final _av_opt_find = _av_opt_findPtr.asFunction<
      ffi.Pointer<AVOption> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Look for an option in an object. Consider only options which
  /// have all the specified flags set.
  ///
  /// @param[in] obj A pointer to a struct whose first element is a
  /// pointer to an AVClass.
  /// Alternatively a double pointer to an AVClass, if
  /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
  /// @param[in] name The name of the option to look for.
  /// @param[in] unit When searching for named constants, name of the unit
  /// it belongs to.
  /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
  /// @param search_flags A combination of AV_OPT_SEARCH_*.
  /// @param[out] target_obj if non-NULL, an object to which the option belongs will be
  /// written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present
  /// in search_flags. This parameter is ignored if search_flags contain
  /// AV_OPT_SEARCH_FAKE_OBJ.
  ///
  /// @return A pointer to the option found, or NULL if no option
  /// was found.
  ffi.Pointer<AVOption> av_opt_find2(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> unit,
    int opt_flags,
    int search_flags,
    ffi.Pointer<ffi.Pointer<ffi.Void>> target_obj,
  ) {
    return _av_opt_find2(
      obj,
      name,
      unit,
      opt_flags,
      search_flags,
      target_obj,
    );
  }

  late final _av_opt_find2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOption> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_opt_find2');
  late final _av_opt_find2 = _av_opt_find2Ptr.asFunction<
      ffi.Pointer<AVOption> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Show the obj options.
  ///
  /// @param req_flags requested flags for the options to show. Show only the
  /// options for which it is opt->flags & req_flags.
  /// @param rej_flags rejected flags for the options to show. Show only the
  /// options for which it is !(opt->flags & req_flags).
  /// @param av_log_obj log context to use for showing the options
  int av_opt_show2(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Void> av_log_obj,
    int req_flags,
    int rej_flags,
  ) {
    return _av_opt_show2(
      obj,
      av_log_obj,
      req_flags,
      rej_flags,
    );
  }

  late final _av_opt_show2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
              ffi.Int, ffi.Int)>>('av_opt_show2');
  late final _av_opt_show2 = _av_opt_show2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Extract a key-value pair from the beginning of a string.
  ///
  /// @param ropts        pointer to the options string, will be updated to
  /// point to the rest of the string (one of the pairs_sep
  /// or the final NUL)
  /// @param key_val_sep  a 0-terminated list of characters used to separate
  /// key from value, for example '='
  /// @param pairs_sep    a 0-terminated list of characters used to separate
  /// two pairs from each other, for example ':' or ','
  /// @param flags        flags; see the AV_OPT_FLAG_* values below
  /// @param rkey         parsed key; must be freed using av_free()
  /// @param rval         parsed value; must be freed using av_free()
  ///
  /// @return  >=0 for success, or a negative value corresponding to an
  /// AVERROR code in case of error; in particular:
  /// AVERROR(EINVAL) if no key is present
  int av_opt_get_key_value(
    ffi.Pointer<ffi.Pointer<ffi.Char>> ropts,
    ffi.Pointer<ffi.Char> key_val_sep,
    ffi.Pointer<ffi.Char> pairs_sep,
    int flags,
    ffi.Pointer<ffi.Pointer<ffi.Char>> rkey,
    ffi.Pointer<ffi.Pointer<ffi.Char>> rval,
  ) {
    return _av_opt_get_key_value(
      ropts,
      key_val_sep,
      pairs_sep,
      flags,
      rkey,
      rval,
    );
  }

  late final _av_opt_get_key_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('av_opt_get_key_value');
  late final _av_opt_get_key_value = _av_opt_get_key_valuePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Parse the key/value pairs list in opts. For each key/value pair
  /// found, stores the value in the field in ctx that is named like the
  /// key. ctx must be an AVClass context, storing is done using
  /// AVOptions.
  ///
  /// @param opts options string to parse, may be NULL
  /// @param key_val_sep a 0-terminated list of characters used to
  /// separate key from value
  /// @param pairs_sep a 0-terminated list of characters used to separate
  /// two pairs from each other
  /// @return the number of successfully set key/value pairs, or a negative
  /// value corresponding to an AVERROR code in case of error:
  /// AVERROR(EINVAL) if opts cannot be parsed,
  /// the error code issued by av_opt_set() if a key/value pair
  /// cannot be set
  int av_set_options_string(
    ffi.Pointer<ffi.Void> ctx,
    ffi.Pointer<ffi.Char> opts,
    ffi.Pointer<ffi.Char> key_val_sep,
    ffi.Pointer<ffi.Char> pairs_sep,
  ) {
    return _av_set_options_string(
      ctx,
      opts,
      key_val_sep,
      pairs_sep,
    );
  }

  late final _av_set_options_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('av_set_options_string');
  late final _av_set_options_string = _av_set_options_stringPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Parse the key-value pairs list in opts. For each key=value pair found,
  /// set the value of the corresponding option in ctx.
  ///
  /// @param ctx          the AVClass object to set options on
  /// @param opts         the options string, key-value pairs separated by a
  /// delimiter
  /// @param shorthand    a NULL-terminated array of options names for shorthand
  /// notation: if the first field in opts has no key part,
  /// the key is taken from the first element of shorthand;
  /// then again for the second, etc., until either opts is
  /// finished, shorthand is finished or a named option is
  /// found; after that, all options must be named
  /// @param key_val_sep  a 0-terminated list of characters used to separate
  /// key from value, for example '='
  /// @param pairs_sep    a 0-terminated list of characters used to separate
  /// two pairs from each other, for example ':' or ','
  /// @return  the number of successfully set key=value pairs, or a negative
  /// value corresponding to an AVERROR code in case of error:
  /// AVERROR(EINVAL) if opts cannot be parsed,
  /// the error code issued by av_set_string3() if a key/value pair
  /// cannot be set
  ///
  /// Options names must use only the following characters: a-z A-Z 0-9 - . / _
  /// Separators must use characters distinct from option names and from each
  /// other.
  int av_opt_set_from_string(
    ffi.Pointer<ffi.Void> ctx,
    ffi.Pointer<ffi.Char> opts,
    ffi.Pointer<ffi.Pointer<ffi.Char>> shorthand,
    ffi.Pointer<ffi.Char> key_val_sep,
    ffi.Pointer<ffi.Char> pairs_sep,
  ) {
    return _av_opt_set_from_string(
      ctx,
      opts,
      shorthand,
      key_val_sep,
      pairs_sep,
    );
  }

  late final _av_opt_set_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('av_opt_set_from_string');
  late final _av_opt_set_from_string = _av_opt_set_from_stringPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set all the options from a given dictionary on an object.
  ///
  /// @param obj a struct whose first element is a pointer to AVClass
  /// @param options options to process. This dictionary will be freed and replaced
  /// by a new one containing all options not found in obj.
  /// Of course this new dictionary needs to be freed by caller
  /// with av_dict_free().
  ///
  /// @return 0 on success, a negative AVERROR if some option was found in obj,
  /// but could not be set.
  ///
  /// @see av_dict_copy()
  int av_opt_set_dict(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _av_opt_set_dict(
      obj,
      options,
    );
  }

  late final _av_opt_set_dictPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('av_opt_set_dict');
  late final _av_opt_set_dict = _av_opt_set_dictPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Set all the options from a given dictionary on an object.
  ///
  /// @param obj a struct whose first element is a pointer to AVClass
  /// @param options options to process. This dictionary will be freed and replaced
  /// by a new one containing all options not found in obj.
  /// Of course this new dictionary needs to be freed by caller
  /// with av_dict_free().
  /// @param search_flags A combination of AV_OPT_SEARCH_*.
  ///
  /// @return 0 on success, a negative AVERROR if some option was found in obj,
  /// but could not be set.
  ///
  /// @see av_dict_copy()
  int av_opt_set_dict2(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
    int search_flags,
  ) {
    return _av_opt_set_dict2(
      obj,
      options,
      search_flags,
    );
  }

  late final _av_opt_set_dict2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>,
              ffi.Int)>>('av_opt_set_dict2');
  late final _av_opt_set_dict2 = _av_opt_set_dict2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>, int)>();

  /// Copy options from src object into dest object.
  ///
  /// The underlying AVClass of both src and dest must coincide. The guarantee
  /// below does not apply if this is not fulfilled.
  ///
  /// Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
  /// Original memory allocated for such options is freed unless both src and dest options points to the same memory.
  ///
  /// Even on error it is guaranteed that allocated options from src and dest
  /// no longer alias each other afterwards; in particular calling av_opt_free()
  /// on both src and dest is safe afterwards if dest has been memdup'ed from src.
  ///
  /// @param dest Object to copy from
  /// @param src  Object to copy into
  /// @return 0 on success, negative on error
  int av_opt_copy(
    ffi.Pointer<ffi.Void> dest,
    ffi.Pointer<ffi.Void> src,
  ) {
    return _av_opt_copy(
      dest,
      src,
    );
  }

  late final _av_opt_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>('av_opt_copy');
  late final _av_opt_copy = _av_opt_copyPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>();

  /// @defgroup opt_set_funcs Option setting functions
  /// @{
  /// Those functions set the field of obj with the given name to value.
  ///
  /// @param[in] obj A struct whose first element is a pointer to an AVClass.
  /// @param[in] name the name of the field to set
  /// @param[in] val The value to set. In case of av_opt_set() if the field is not
  /// of a string type, then the given string is parsed.
  /// SI postfixes and some named scalars are supported.
  /// If the field is of a numeric type, it has to be a numeric or named
  /// scalar. Behavior with more than one scalar and +- infix operators
  /// is undefined.
  /// If the field is of a flags type, it has to be a sequence of numeric
  /// scalars or named flags separated by '+' or '-'. Prefixing a flag
  /// with '+' causes it to be set without affecting the other flags;
  /// similarly, '-' unsets a flag.
  /// If the field is of a dictionary type, it has to be a ':' separated list of
  /// key=value parameters. Values containing ':' special characters must be
  /// escaped.
  /// @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
  /// is passed here, then the option may be set on a child of obj.
  ///
  /// @return 0 if the value has been set, or an AVERROR code in case of
  /// error:
  /// AVERROR_OPTION_NOT_FOUND if no matching option exists
  /// AVERROR(ERANGE) if the value is out of range
  /// AVERROR(EINVAL) if the value is not valid
  int av_opt_set(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> val,
    int search_flags,
  ) {
    return _av_opt_set(
      obj,
      name,
      val,
      search_flags,
    );
  }

  late final _av_opt_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('av_opt_set');
  late final _av_opt_set = _av_opt_setPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int)>();

  int av_opt_set_int(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int val,
    int search_flags,
  ) {
    return _av_opt_set_int(
      obj,
      name,
      val,
      search_flags,
    );
  }

  late final _av_opt_set_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int64, ffi.Int)>>('av_opt_set_int');
  late final _av_opt_set_int = _av_opt_set_intPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int, int)>();

  int av_opt_set_double(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    double val,
    int search_flags,
  ) {
    return _av_opt_set_double(
      obj,
      name,
      val,
      search_flags,
    );
  }

  late final _av_opt_set_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Double, ffi.Int)>>('av_opt_set_double');
  late final _av_opt_set_double = _av_opt_set_doublePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, double, int)>();

  int av_opt_set_q(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    AVRational val,
    int search_flags,
  ) {
    return _av_opt_set_q(
      obj,
      name,
      val,
      search_flags,
    );
  }

  late final _av_opt_set_qPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              AVRational, ffi.Int)>>('av_opt_set_q');
  late final _av_opt_set_q = _av_opt_set_qPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, AVRational, int)>();

  int av_opt_set_bin(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Uint8> val,
    int size,
    int search_flags,
  ) {
    return _av_opt_set_bin(
      obj,
      name,
      val,
      size,
      search_flags,
    );
  }

  late final _av_opt_set_binPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int)>>('av_opt_set_bin');
  late final _av_opt_set_bin = _av_opt_set_binPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>, int, int)>();

  int av_opt_set_image_size(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int w,
    int h,
    int search_flags,
  ) {
    return _av_opt_set_image_size(
      obj,
      name,
      w,
      h,
      search_flags,
    );
  }

  late final _av_opt_set_image_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int, ffi.Int)>>('av_opt_set_image_size');
  late final _av_opt_set_image_size = _av_opt_set_image_sizePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int, int, int)>();

  int av_opt_set_pixel_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    AVPixelFormat fmt,
    int search_flags,
  ) {
    return _av_opt_set_pixel_fmt(
      obj,
      name,
      fmt.value,
      search_flags,
    );
  }

  late final _av_opt_set_pixel_fmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int)>>('av_opt_set_pixel_fmt');
  late final _av_opt_set_pixel_fmt = _av_opt_set_pixel_fmtPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int, int)>();

  int av_opt_set_sample_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    AVSampleFormat fmt,
    int search_flags,
  ) {
    return _av_opt_set_sample_fmt(
      obj,
      name,
      fmt.value,
      search_flags,
    );
  }

  late final _av_opt_set_sample_fmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int)>>('av_opt_set_sample_fmt');
  late final _av_opt_set_sample_fmt = _av_opt_set_sample_fmtPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int, int)>();

  int av_opt_set_video_rate(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    AVRational val,
    int search_flags,
  ) {
    return _av_opt_set_video_rate(
      obj,
      name,
      val,
      search_flags,
    );
  }

  late final _av_opt_set_video_ratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              AVRational, ffi.Int)>>('av_opt_set_video_rate');
  late final _av_opt_set_video_rate = _av_opt_set_video_ratePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, AVRational, int)>();

  /// @note Any old chlayout present is discarded and replaced with a copy of the new one. The
  /// caller still owns layout and is responsible for uninitializing it.
  int av_opt_set_chlayout(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<AVChannelLayout> layout,
    int search_flags,
  ) {
    return _av_opt_set_chlayout(
      obj,
      name,
      layout,
      search_flags,
    );
  }

  late final _av_opt_set_chlayoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVChannelLayout>, ffi.Int)>>('av_opt_set_chlayout');
  late final _av_opt_set_chlayout = _av_opt_set_chlayoutPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<AVChannelLayout>, int)>();

  /// @note Any old dictionary present is discarded and replaced with a copy of the new one. The
  /// caller still owns val is and responsible for freeing it.
  int av_opt_set_dict_val(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<AVDictionary> val,
    int search_flags,
  ) {
    return _av_opt_set_dict_val(
      obj,
      name,
      val,
      search_flags,
    );
  }

  late final _av_opt_set_dict_valPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVDictionary>, ffi.Int)>>('av_opt_set_dict_val');
  late final _av_opt_set_dict_val = _av_opt_set_dict_valPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<AVDictionary>, int)>();

  /// Add, replace, or remove elements for an array option. Which of these
  /// operations is performed depends on the values of val and search_flags.
  ///
  /// @param start_elem Index of the first array element to modify; must not be
  /// larger than array size as returned by
  /// av_opt_get_array_size().
  /// @param nb_elems number of array elements to modify; when val is NULL,
  /// start_elem+nb_elems must not be larger than array size as
  /// returned by av_opt_get_array_size()
  ///
  /// @param val_type Option type corresponding to the type of val, ignored when val is
  /// NULL.
  ///
  /// The effect of this function will will be as if av_opt_setX()
  /// was called for each element, where X is specified by type.
  /// E.g. AV_OPT_TYPE_STRING corresponds to av_opt_set().
  ///
  /// Typically this should be the same as the scalarized type of
  /// the AVOption being set, but certain conversions are also
  /// possible - the same as those done by the corresponding
  /// av_opt_set*() function. E.g. any option type can be set from
  /// a string, numeric types can be set from int64, double, or
  /// rational, etc.
  ///
  /// @param val Array with nb_elems elements or NULL.
  ///
  /// When NULL, nb_elems array elements starting at start_elem are
  /// removed from the array. Any array elements remaining at the end
  /// are shifted by nb_elems towards the first element in order to keep
  /// the array contiguous.
  ///
  /// Otherwise (val is non-NULL), the type of val must match the
  /// underlying C type as documented for val_type.
  ///
  /// When AV_OPT_ARRAY_REPLACE is not set in search_flags, the array is
  /// enlarged by nb_elems, and the contents of val are inserted at
  /// start_elem. Previously existing array elements from start_elem
  /// onwards (if present) are shifted by nb_elems away from the first
  /// element in order to make space for the new elements.
  ///
  /// When AV_OPT_ARRAY_REPLACE is set in search_flags, the contents
  /// of val replace existing array elements from start_elem to
  /// start_elem+nb_elems (if present). New array size is
  /// max(start_elem + nb_elems, old array size).
  int av_opt_set_array(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    int start_elem,
    int nb_elems,
    AVOptionType val_type,
    ffi.Pointer<ffi.Void> val,
  ) {
    return _av_opt_set_array(
      obj,
      name,
      search_flags,
      start_elem,
      nb_elems,
      val_type.value,
      val,
    );
  }

  late final _av_opt_set_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('av_opt_set_array');
  late final _av_opt_set_array = _av_opt_set_arrayPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int, int, int,
          int, ffi.Pointer<ffi.Void>)>();

  /// @defgroup opt_get_funcs Option getting functions
  /// @{
  /// Those functions get a value of the option with the given name from an object.
  ///
  /// @param[in] obj a struct whose first element is a pointer to an AVClass.
  /// @param[in] name name of the option to get.
  /// @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
  /// is passed here, then the option may be found in a child of obj.
  /// @param[out] out_val value of the option will be written here
  /// @return >=0 on success, a negative error code otherwise
  /// /
  /// /**
  /// @note the returned string will be av_malloc()ed and must be av_free()ed by the caller
  ///
  /// @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the
  /// option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT
  /// and is set to NULL, *out_val will be set to NULL instead of an allocated
  /// empty string.
  int av_opt_get(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_val,
  ) {
    return _av_opt_get(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('av_opt_get');
  late final _av_opt_get = _av_opt_getPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  int av_opt_get_int(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Int64> out_val,
  ) {
    return _av_opt_get_int(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_get_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Int64>)>>('av_opt_get_int');
  late final _av_opt_get_int = _av_opt_get_intPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Int64>)>();

  int av_opt_get_double(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Double> out_val,
  ) {
    return _av_opt_get_double(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_get_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Double>)>>('av_opt_get_double');
  late final _av_opt_get_double = _av_opt_get_doublePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Double>)>();

  int av_opt_get_q(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<AVRational> out_val,
  ) {
    return _av_opt_get_q(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_get_qPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<AVRational>)>>('av_opt_get_q');
  late final _av_opt_get_q = _av_opt_get_qPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<AVRational>)>();

  int av_opt_get_image_size(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Int> w_out,
    ffi.Pointer<ffi.Int> h_out,
  ) {
    return _av_opt_get_image_size(
      obj,
      name,
      search_flags,
      w_out,
      h_out,
    );
  }

  late final _av_opt_get_image_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('av_opt_get_image_size');
  late final _av_opt_get_image_size = _av_opt_get_image_sizePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  int av_opt_get_pixel_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Int> out_fmt,
  ) {
    return _av_opt_get_pixel_fmt(
      obj,
      name,
      search_flags,
      out_fmt,
    );
  }

  late final _av_opt_get_pixel_fmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Int>)>>('av_opt_get_pixel_fmt');
  late final _av_opt_get_pixel_fmt = _av_opt_get_pixel_fmtPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Int>)>();

  int av_opt_get_sample_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Int> out_fmt,
  ) {
    return _av_opt_get_sample_fmt(
      obj,
      name,
      search_flags,
      out_fmt,
    );
  }

  late final _av_opt_get_sample_fmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Int>)>>('av_opt_get_sample_fmt');
  late final _av_opt_get_sample_fmt = _av_opt_get_sample_fmtPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Int>)>();

  int av_opt_get_video_rate(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<AVRational> out_val,
  ) {
    return _av_opt_get_video_rate(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_get_video_ratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<AVRational>)>>('av_opt_get_video_rate');
  late final _av_opt_get_video_rate = _av_opt_get_video_ratePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<AVRational>)>();

  /// @param[out] layout The returned layout is a copy of the actual value and must
  /// be freed with av_channel_layout_uninit() by the caller
  int av_opt_get_chlayout(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<AVChannelLayout> layout,
  ) {
    return _av_opt_get_chlayout(
      obj,
      name,
      search_flags,
      layout,
    );
  }

  late final _av_opt_get_chlayoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<AVChannelLayout>)>>('av_opt_get_chlayout');
  late final _av_opt_get_chlayout = _av_opt_get_chlayoutPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<AVChannelLayout>)>();

  /// @param[out] out_val The returned dictionary is a copy of the actual value and must
  /// be freed with av_dict_free() by the caller
  int av_opt_get_dict_val(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.Pointer<AVDictionary>> out_val,
  ) {
    return _av_opt_get_dict_val(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_get_dict_valPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('av_opt_get_dict_val');
  late final _av_opt_get_dict_val = _av_opt_get_dict_valPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// For an array-type option, get the number of elements in the array.
  int av_opt_get_array_size(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    ffi.Pointer<ffi.UnsignedInt> out_val,
  ) {
    return _av_opt_get_array_size(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  late final _av_opt_get_array_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.UnsignedInt>)>>('av_opt_get_array_size');
  late final _av_opt_get_array_size = _av_opt_get_array_sizePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// For an array-type option, retrieve the values of one or more array elements.
  ///
  /// @param start_elem index of the first array element to retrieve
  /// @param nb_elems number of array elements to retrieve; start_elem+nb_elems
  /// must not be larger than array size as returned by
  /// av_opt_get_array_size()
  ///
  /// @param out_type Option type corresponding to the desired output.
  ///
  /// The array elements produced by this function will
  /// will be as if av_opt_getX() was called for each element,
  /// where X is specified by out_type. E.g. AV_OPT_TYPE_STRING
  /// corresponds to av_opt_get().
  ///
  /// Typically this should be the same as the scalarized type of
  /// the AVOption being retrieved, but certain conversions are
  /// also possible - the same as those done by the corresponding
  /// av_opt_get*() function. E.g. any option type can be retrieved
  /// as a string, numeric types can be retrieved as int64, double,
  /// or rational, etc.
  ///
  /// @param out_val  Array with nb_elems members into which the output will be
  /// written. The array type must match the underlying C type as
  /// documented for out_type, and be zeroed on entry to this
  /// function.
  ///
  /// For dynamically allocated types (strings, binary, dicts,
  /// etc.), the result is owned and freed by the caller.
  int av_opt_get_array(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
    int start_elem,
    int nb_elems,
    AVOptionType out_type,
    ffi.Pointer<ffi.Void> out_val,
  ) {
    return _av_opt_get_array(
      obj,
      name,
      search_flags,
      start_elem,
      nb_elems,
      out_type.value,
      out_val,
    );
  }

  late final _av_opt_get_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('av_opt_get_array');
  late final _av_opt_get_array = _av_opt_get_arrayPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int, int, int,
          int, ffi.Pointer<ffi.Void>)>();

  /// @defgroup opt_eval_funcs Evaluating option strings
  /// @{
  /// This group of functions can be used to evaluate option strings
  /// and get numbers out of them. They do the same thing as av_opt_set(),
  /// except the result is written into the caller-supplied pointer.
  ///
  /// @param obj a struct whose first element is a pointer to AVClass.
  /// @param o an option for which the string is to be evaluated.
  /// @param val string to be evaluated.
  /// @param *_out value of the string will be written here.
  ///
  /// @return 0 on success, a negative number on failure.
  int av_opt_eval_flags(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<ffi.Int> flags_out,
  ) {
    return _av_opt_eval_flags(
      obj,
      o,
      val,
      flags_out,
    );
  }

  late final _av_opt_eval_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('av_opt_eval_flags');
  late final _av_opt_eval_flags = _av_opt_eval_flagsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>();

  int av_opt_eval_int(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<ffi.Int> int_out,
  ) {
    return _av_opt_eval_int(
      obj,
      o,
      val,
      int_out,
    );
  }

  late final _av_opt_eval_intPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>>('av_opt_eval_int');
  late final _av_opt_eval_int = _av_opt_eval_intPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>();

  int av_opt_eval_uint(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<ffi.UnsignedInt> uint_out,
  ) {
    return _av_opt_eval_uint(
      obj,
      o,
      val,
      uint_out,
    );
  }

  late final _av_opt_eval_uintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedInt>)>>('av_opt_eval_uint');
  late final _av_opt_eval_uint = _av_opt_eval_uintPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.UnsignedInt>)>();

  int av_opt_eval_int64(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<ffi.Int64> int64_out,
  ) {
    return _av_opt_eval_int64(
      obj,
      o,
      val,
      int64_out,
    );
  }

  late final _av_opt_eval_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int64>)>>('av_opt_eval_int64');
  late final _av_opt_eval_int64 = _av_opt_eval_int64Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int64>)>();

  int av_opt_eval_float(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<ffi.Float> float_out,
  ) {
    return _av_opt_eval_float(
      obj,
      o,
      val,
      float_out,
    );
  }

  late final _av_opt_eval_floatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Float>)>>('av_opt_eval_float');
  late final _av_opt_eval_float = _av_opt_eval_floatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Float>)>();

  int av_opt_eval_double(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<ffi.Double> double_out,
  ) {
    return _av_opt_eval_double(
      obj,
      o,
      val,
      double_out,
    );
  }

  late final _av_opt_eval_doublePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Double>)>>('av_opt_eval_double');
  late final _av_opt_eval_double = _av_opt_eval_doublePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Double>)>();

  int av_opt_eval_q(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Char> val,
    ffi.Pointer<AVRational> q_out,
  ) {
    return _av_opt_eval_q(
      obj,
      o,
      val,
      q_out,
    );
  }

  late final _av_opt_eval_qPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVRational>)>>('av_opt_eval_q');
  late final _av_opt_eval_q = _av_opt_eval_qPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<AVRational>)>();

  /// Gets a pointer to the requested field in a struct.
  /// This function allows accessing a struct even when its fields are moved or
  /// renamed since the application making the access has been compiled,
  ///
  /// @returns a pointer to the field, it can be cast to the correct type and read
  /// or written to.
  ffi.Pointer<ffi.Void> av_opt_ptr(
    ffi.Pointer<AVClass> avclass,
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_opt_ptr(
      avclass,
      obj,
      name,
    );
  }

  late final _av_opt_ptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<AVClass>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>>('av_opt_ptr');
  late final _av_opt_ptr = _av_opt_ptrPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<AVClass>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>)>();

  /// Check if given option is set to its default value.
  ///
  /// Options o must belong to the obj. This function must not be called to check child's options state.
  /// @see av_opt_is_set_to_default_by_name().
  ///
  /// @param obj  AVClass object to check option on
  /// @param o    option to be checked
  /// @return     >0 when option is set to its default,
  /// 0 when option is not set its default,
  /// <0 on error
  int av_opt_is_set_to_default(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
  ) {
    return _av_opt_is_set_to_default(
      obj,
      o,
    );
  }

  late final _av_opt_is_set_to_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVOption>)>>('av_opt_is_set_to_default');
  late final _av_opt_is_set_to_default = _av_opt_is_set_to_defaultPtr
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<AVOption>)>();

  /// Check if given option is set to its default value.
  ///
  /// @param obj          AVClass object to check option on
  /// @param name         option name
  /// @param search_flags combination of AV_OPT_SEARCH_*
  /// @return             >0 when option is set to its default,
  /// 0 when option is not set its default,
  /// <0 on error
  int av_opt_is_set_to_default_by_name(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> name,
    int search_flags,
  ) {
    return _av_opt_is_set_to_default_by_name(
      obj,
      name,
      search_flags,
    );
  }

  late final _av_opt_is_set_to_default_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_opt_is_set_to_default_by_name');
  late final _av_opt_is_set_to_default_by_name =
      _av_opt_is_set_to_default_by_namePtr.asFunction<
          int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int)>();

  /// Check whether a particular flag is set in a flags field.
  ///
  /// @param field_name the name of the flag field option
  /// @param flag_name the name of the flag to check
  /// @return non-zero if the flag is set, zero if the flag isn't set,
  /// isn't of the right type, or the flags field doesn't exist.
  int av_opt_flag_is_set(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> field_name,
    ffi.Pointer<ffi.Char> flag_name,
  ) {
    return _av_opt_flag_is_set(
      obj,
      field_name,
      flag_name,
    );
  }

  late final _av_opt_flag_is_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('av_opt_flag_is_set');
  late final _av_opt_flag_is_set = _av_opt_flag_is_setPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Serialize object's options.
  ///
  /// Create a string containing object's serialized options.
  /// Such string may be passed back to av_opt_set_from_string() in order to restore option values.
  /// A key/value or pairs separator occurring in the serialized value or
  /// name string are escaped through the av_escape() function.
  ///
  /// @param[in]  obj           AVClass object to serialize
  /// @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)
  /// @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags
  /// @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.
  /// Buffer must be freed by the caller when is no longer needed.
  /// @param[in]  key_val_sep   character used to separate key from value
  /// @param[in]  pairs_sep     character used to separate two pairs from each other
  /// @return                   >= 0 on success, negative on error
  /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
  int av_opt_serialize(
    ffi.Pointer<ffi.Void> obj,
    int opt_flags,
    int flags,
    ffi.Pointer<ffi.Pointer<ffi.Char>> buffer,
    int key_val_sep,
    int pairs_sep,
  ) {
    return _av_opt_serialize(
      obj,
      opt_flags,
      flags,
      buffer,
      key_val_sep,
      pairs_sep,
    );
  }

  late final _av_opt_serializePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Char,
              ffi.Char)>>('av_opt_serialize');
  late final _av_opt_serialize = _av_opt_serializePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, int, int)>();

  /// Free an AVOptionRanges struct and set it to NULL.
  void av_opt_freep_ranges(
    ffi.Pointer<ffi.Pointer<AVOptionRanges>> ranges,
  ) {
    return _av_opt_freep_ranges(
      ranges,
    );
  }

  late final _av_opt_freep_rangesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVOptionRanges>>)>>(
      'av_opt_freep_ranges');
  late final _av_opt_freep_ranges = _av_opt_freep_rangesPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVOptionRanges>>)>();

  /// Get a list of allowed ranges for the given option.
  ///
  /// The returned list may depend on other fields in obj like for example profile.
  ///
  /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
  /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
  /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
  ///
  /// The result must be freed with av_opt_freep_ranges.
  ///
  /// @return number of compontents returned on success, a negative errro code otherwise
  int av_opt_query_ranges(
    ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> key,
    int flags,
  ) {
    return _av_opt_query_ranges(
      arg0,
      obj,
      key,
      flags,
    );
  }

  late final _av_opt_query_rangesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVOptionRanges>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_opt_query_ranges');
  late final _av_opt_query_ranges = _av_opt_query_rangesPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVOptionRanges>>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int)>();

  /// Get a default list of allowed ranges for the given option.
  ///
  /// This list is constructed without using the AVClass.query_ranges() callback
  /// and can be used as fallback from within the callback.
  ///
  /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
  /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
  /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
  ///
  /// The result must be freed with av_opt_free_ranges.
  ///
  /// @return number of compontents returned on success, a negative errro code otherwise
  int av_opt_query_ranges_default(
    ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Char> key,
    int flags,
  ) {
    return _av_opt_query_ranges_default(
      arg0,
      obj,
      key,
      flags,
    );
  }

  late final _av_opt_query_ranges_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVOptionRanges>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_opt_query_ranges_default');
  late final _av_opt_query_ranges_default =
      _av_opt_query_ranges_defaultPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<AVOptionRanges>>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, int)>();

  /// Allocates a AVDCT context.
  /// This needs to be initialized with avcodec_dct_init() after optionally
  /// configuring it with AVOptions.
  ///
  /// To free it use av_free()
  ffi.Pointer<AVDCT> avcodec_dct_alloc() {
    return _avcodec_dct_alloc();
  }

  late final _avcodec_dct_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVDCT> Function()>>(
          'avcodec_dct_alloc');
  late final _avcodec_dct_alloc =
      _avcodec_dct_allocPtr.asFunction<ffi.Pointer<AVDCT> Function()>();

  int avcodec_dct_init(
    ffi.Pointer<AVDCT> arg0,
  ) {
    return _avcodec_dct_init(
      arg0,
    );
  }

  late final _avcodec_dct_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVDCT>)>>(
          'avcodec_dct_init');
  late final _avcodec_dct_init =
      _avcodec_dct_initPtr.asFunction<int Function(ffi.Pointer<AVDCT>)>();

  ffi.Pointer<AVClass> avcodec_dct_get_class() {
    return _avcodec_dct_get_class();
  }

  late final _avcodec_dct_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'avcodec_dct_get_class');
  late final _avcodec_dct_get_class =
      _avcodec_dct_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Extract the bitstream ID and the frame size from AC-3 data.
  int av_ac3_parse_header(
    ffi.Pointer<ffi.Uint8> buf,
    int size,
    ffi.Pointer<ffi.Uint8> bitstream_id,
    ffi.Pointer<ffi.Uint16> frame_size,
  ) {
    return _av_ac3_parse_header(
      buf,
      size,
      bitstream_id,
      frame_size,
    );
  }

  late final _av_ac3_parse_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Size,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint16>)>>('av_ac3_parse_header');
  late final _av_ac3_parse_header = _av_ac3_parse_headerPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint16>)>();

  /// Allocate and initialize the Vorbis parser using headers in the extradata.
  ffi.Pointer<AVVorbisParseContext> av_vorbis_parse_init(
    ffi.Pointer<ffi.Uint8> extradata,
    int extradata_size,
  ) {
    return _av_vorbis_parse_init(
      extradata,
      extradata_size,
    );
  }

  late final _av_vorbis_parse_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVVorbisParseContext> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('av_vorbis_parse_init');
  late final _av_vorbis_parse_init = _av_vorbis_parse_initPtr.asFunction<
      ffi.Pointer<AVVorbisParseContext> Function(
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Free the parser and everything associated with it.
  void av_vorbis_parse_free(
    ffi.Pointer<ffi.Pointer<AVVorbisParseContext>> s,
  ) {
    return _av_vorbis_parse_free(
      s,
    );
  }

  late final _av_vorbis_parse_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Pointer<AVVorbisParseContext>>)>>(
      'av_vorbis_parse_free');
  late final _av_vorbis_parse_free = _av_vorbis_parse_freePtr.asFunction<
      void Function(ffi.Pointer<ffi.Pointer<AVVorbisParseContext>>)>();

  /// Get the duration for a Vorbis packet.
  ///
  /// If @p flags is @c NULL,
  /// special frames are considered invalid.
  ///
  /// @param s        Vorbis parser context
  /// @param buf      buffer containing a Vorbis frame
  /// @param buf_size size of the buffer
  /// @param flags    flags for special frames
  int av_vorbis_parse_frame_flags(
    ffi.Pointer<AVVorbisParseContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    ffi.Pointer<ffi.Int> flags,
  ) {
    return _av_vorbis_parse_frame_flags(
      s,
      buf,
      buf_size,
      flags,
    );
  }

  late final _av_vorbis_parse_frame_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVVorbisParseContext>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Int>)>>('av_vorbis_parse_frame_flags');
  late final _av_vorbis_parse_frame_flags =
      _av_vorbis_parse_frame_flagsPtr.asFunction<
          int Function(ffi.Pointer<AVVorbisParseContext>,
              ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Int>)>();

  /// Get the duration for a Vorbis packet.
  ///
  /// @param s        Vorbis parser context
  /// @param buf      buffer containing a Vorbis frame
  /// @param buf_size size of the buffer
  int av_vorbis_parse_frame(
    ffi.Pointer<AVVorbisParseContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
  ) {
    return _av_vorbis_parse_frame(
      s,
      buf,
      buf_size,
    );
  }

  late final _av_vorbis_parse_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVVorbisParseContext>,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('av_vorbis_parse_frame');
  late final _av_vorbis_parse_frame = _av_vorbis_parse_framePtr.asFunction<
      int Function(
          ffi.Pointer<AVVorbisParseContext>, ffi.Pointer<ffi.Uint8>, int)>();

  void av_vorbis_parse_reset(
    ffi.Pointer<AVVorbisParseContext> s,
  ) {
    return _av_vorbis_parse_reset(
      s,
    );
  }

  late final _av_vorbis_parse_resetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVVorbisParseContext>)>>('av_vorbis_parse_reset');
  late final _av_vorbis_parse_reset = _av_vorbis_parse_resetPtr
      .asFunction<void Function(ffi.Pointer<AVVorbisParseContext>)>();

  /// Get a DV profile for the provided compressed frame.
  ///
  /// @param sys the profile used for the previous frame, may be NULL
  /// @param frame the compressed data buffer
  /// @param buf_size size of the buffer in bytes
  /// @return the DV profile for the supplied data or NULL on failure
  ffi.Pointer<AVDVProfile> av_dv_frame_profile(
    ffi.Pointer<AVDVProfile> sys,
    ffi.Pointer<ffi.Uint8> frame,
    int buf_size,
  ) {
    return _av_dv_frame_profile(
      sys,
      frame,
      buf_size,
    );
  }

  late final _av_dv_frame_profilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDVProfile> Function(ffi.Pointer<AVDVProfile>,
              ffi.Pointer<ffi.Uint8>, ffi.UnsignedInt)>>('av_dv_frame_profile');
  late final _av_dv_frame_profile = _av_dv_frame_profilePtr.asFunction<
      ffi.Pointer<AVDVProfile> Function(
          ffi.Pointer<AVDVProfile>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get a DV profile for the provided stream parameters.
  ffi.Pointer<AVDVProfile> av_dv_codec_profile(
    int width,
    int height,
    AVPixelFormat pix_fmt,
  ) {
    return _av_dv_codec_profile(
      width,
      height,
      pix_fmt.value,
    );
  }

  late final _av_dv_codec_profilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDVProfile> Function(
              ffi.Int, ffi.Int, ffi.Int)>>('av_dv_codec_profile');
  late final _av_dv_codec_profile = _av_dv_codec_profilePtr
      .asFunction<ffi.Pointer<AVDVProfile> Function(int, int, int)>();

  /// Get a DV profile for the provided stream parameters.
  /// The frame rate is used as a best-effort parameter.
  ffi.Pointer<AVDVProfile> av_dv_codec_profile2(
    int width,
    int height,
    AVPixelFormat pix_fmt,
    AVRational frame_rate,
  ) {
    return _av_dv_codec_profile2(
      width,
      height,
      pix_fmt.value,
      frame_rate,
    );
  }

  late final _av_dv_codec_profile2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDVProfile> Function(
              ffi.Int, ffi.Int, ffi.Int, AVRational)>>('av_dv_codec_profile2');
  late final _av_dv_codec_profile2 = _av_dv_codec_profile2Ptr.asFunction<
      ffi.Pointer<AVDVProfile> Function(int, int, int, AVRational)>();

  /// Return the name of the protocol that will handle the passed URL.
  ///
  /// NULL is returned if no protocol could be found for the given URL.
  ///
  /// @return Name of the protocol or NULL.
  ffi.Pointer<ffi.Char> avio_find_protocol_name(
    ffi.Pointer<ffi.Char> url,
  ) {
    return _avio_find_protocol_name(
      url,
    );
  }

  late final _avio_find_protocol_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('avio_find_protocol_name');
  late final _avio_find_protocol_name = _avio_find_protocol_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Return AVIO_FLAG_* access flags corresponding to the access permissions
  /// of the resource in url, or a negative value corresponding to an
  /// AVERROR code in case of failure. The returned access flags are
  /// masked by the value in flags.
  ///
  /// @note This function is intrinsically unsafe, in the sense that the
  /// checked resource may change its existence or permission status from
  /// one call to another. Thus you should not trust the returned value,
  /// unless you are sure that no other processes are accessing the
  /// checked resource.
  int avio_check(
    ffi.Pointer<ffi.Char> url,
    int flags,
  ) {
    return _avio_check(
      url,
      flags,
    );
  }

  late final _avio_checkPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'avio_check');
  late final _avio_check =
      _avio_checkPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Open directory for reading.
  ///
  /// @param s       directory read context. Pointer to a NULL pointer must be passed.
  /// @param url     directory to be listed.
  /// @param options A dictionary filled with protocol-private options. On return
  /// this parameter will be destroyed and replaced with a dictionary
  /// containing options that were not found. May be NULL.
  /// @return >=0 on success or negative on error.
  int avio_open_dir(
    ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avio_open_dir(
      s,
      url,
      options,
    );
  }

  late final _avio_open_dirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVIODirContext>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('avio_open_dir');
  late final _avio_open_dir = _avio_open_dirPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVIODirContext>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Get next directory entry.
  ///
  /// Returned entry must be freed with avio_free_directory_entry(). In particular
  /// it may outlive AVIODirContext.
  ///
  /// @param s         directory read context.
  /// @param[out] next next entry or NULL when no more entries.
  /// @return >=0 on success or negative on error. End of list is not considered an
  /// error.
  int avio_read_dir(
    ffi.Pointer<AVIODirContext> s,
    ffi.Pointer<ffi.Pointer<AVIODirEntry>> next,
  ) {
    return _avio_read_dir(
      s,
      next,
    );
  }

  late final _avio_read_dirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIODirContext>,
              ffi.Pointer<ffi.Pointer<AVIODirEntry>>)>>('avio_read_dir');
  late final _avio_read_dir = _avio_read_dirPtr.asFunction<
      int Function(ffi.Pointer<AVIODirContext>,
          ffi.Pointer<ffi.Pointer<AVIODirEntry>>)>();

  /// Close directory.
  ///
  /// @note Entries created using avio_read_dir() are not deleted and must be
  /// freeded with avio_free_directory_entry().
  ///
  /// @param s         directory read context.
  /// @return >=0 on success or negative on error.
  int avio_close_dir(
    ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
  ) {
    return _avio_close_dir(
      s,
    );
  }

  late final _avio_close_dirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVIODirContext>>)>>('avio_close_dir');
  late final _avio_close_dir = _avio_close_dirPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVIODirContext>>)>();

  /// Free entry allocated by avio_read_dir().
  ///
  /// @param entry entry to be freed.
  void avio_free_directory_entry(
    ffi.Pointer<ffi.Pointer<AVIODirEntry>> entry,
  ) {
    return _avio_free_directory_entry(
      entry,
    );
  }

  late final _avio_free_directory_entryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVIODirEntry>>)>>(
      'avio_free_directory_entry');
  late final _avio_free_directory_entry = _avio_free_directory_entryPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVIODirEntry>>)>();

  /// Allocate and initialize an AVIOContext for buffered I/O. It must be later
  /// freed with avio_context_free().
  ///
  /// @param buffer Memory block for input/output operations via AVIOContext.
  /// The buffer must be allocated with av_malloc() and friends.
  /// It may be freed and replaced with a new buffer by libavformat.
  /// AVIOContext.buffer holds the buffer currently in use,
  /// which must be later freed with av_free().
  /// @param buffer_size The buffer size is very important for performance.
  /// For protocols with fixed blocksize it should be set to this blocksize.
  /// For others a typical size is a cache page, e.g. 4kb.
  /// @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
  /// @param opaque An opaque pointer to user-specific data.
  /// @param read_packet  A function for refilling the buffer, may be NULL.
  /// For stream protocols, must never return 0 but rather
  /// a proper AVERROR code.
  /// @param write_packet A function for writing the buffer contents, may be NULL.
  /// The function may not change the input buffers content.
  /// @param seek A function for seeking to specified byte position, may be NULL.
  ///
  /// @return Allocated AVIOContext or NULL on failure.
  ffi.Pointer<AVIOContext> avio_alloc_context(
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int buffer_size,
    int write_flag,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                    ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>>
        read_packet,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                    ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>>
        write_packet,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int64 Function(ffi.Pointer<ffi.Void> opaque,
                    ffi.Int64 offset, ffi.Int whence)>>
        seek,
  ) {
    return _avio_alloc_context(
      buffer,
      buffer_size,
      write_flag,
      opaque,
      read_packet,
      write_packet,
      seek,
    );
  }

  late final _avio_alloc_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVIOContext> Function(
              ffi.Pointer<ffi.UnsignedChar>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                          ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                          ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int64 Function(
                          ffi.Pointer<ffi.Void> opaque,
                          ffi.Int64 offset,
                          ffi.Int whence)>>)>>('avio_alloc_context');
  late final _avio_alloc_context = _avio_alloc_contextPtr.asFunction<
      ffi.Pointer<AVIOContext> Function(
          ffi.Pointer<ffi.UnsignedChar>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                      ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                      ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int64 Function(ffi.Pointer<ffi.Void> opaque,
                      ffi.Int64 offset, ffi.Int whence)>>)>();

  /// Free the supplied IO context and everything associated with it.
  ///
  /// @param s Double pointer to the IO context. This function will write NULL
  /// into s.
  void avio_context_free(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ) {
    return _avio_context_free(
      s,
    );
  }

  late final _avio_context_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVIOContext>>)>>('avio_context_free');
  late final _avio_context_free = _avio_context_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVIOContext>>)>();

  void avio_w8(
    ffi.Pointer<AVIOContext> s,
    int b,
  ) {
    return _avio_w8(
      s,
      b,
    );
  }

  late final _avio_w8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVIOContext>, ffi.Int)>>('avio_w8');
  late final _avio_w8 =
      _avio_w8Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_write(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.UnsignedChar> buf,
    int size,
  ) {
    return _avio_write(
      s,
      buf,
      size,
    );
  }

  late final _avio_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('avio_write');
  late final _avio_write = _avio_writePtr.asFunction<
      void Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  void avio_wl64(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wl64(
      s,
      val,
    );
  }

  late final _avio_wl64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.Uint64)>>('avio_wl64');
  late final _avio_wl64 =
      _avio_wl64Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wb64(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wb64(
      s,
      val,
    );
  }

  late final _avio_wb64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.Uint64)>>('avio_wb64');
  late final _avio_wb64 =
      _avio_wb64Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wl32(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wl32(
      s,
      val,
    );
  }

  late final _avio_wl32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.UnsignedInt)>>('avio_wl32');
  late final _avio_wl32 =
      _avio_wl32Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wb32(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wb32(
      s,
      val,
    );
  }

  late final _avio_wb32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.UnsignedInt)>>('avio_wb32');
  late final _avio_wb32 =
      _avio_wb32Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wl24(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wl24(
      s,
      val,
    );
  }

  late final _avio_wl24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.UnsignedInt)>>('avio_wl24');
  late final _avio_wl24 =
      _avio_wl24Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wb24(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wb24(
      s,
      val,
    );
  }

  late final _avio_wb24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.UnsignedInt)>>('avio_wb24');
  late final _avio_wb24 =
      _avio_wb24Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wl16(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wl16(
      s,
      val,
    );
  }

  late final _avio_wl16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.UnsignedInt)>>('avio_wl16');
  late final _avio_wl16 =
      _avio_wl16Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  void avio_wb16(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    return _avio_wb16(
      s,
      val,
    );
  }

  late final _avio_wb16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVIOContext>, ffi.UnsignedInt)>>('avio_wb16');
  late final _avio_wb16 =
      _avio_wb16Ptr.asFunction<void Function(ffi.Pointer<AVIOContext>, int)>();

  /// Write a NULL-terminated string.
  /// @return number of bytes written.
  int avio_put_str(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _avio_put_str(
      s,
      str,
    );
  }

  late final _avio_put_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Char>)>>('avio_put_str');
  late final _avio_put_str = _avio_put_strPtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>)>();

  /// Convert an UTF-8 string to UTF-16LE and write it.
  /// @param s the AVIOContext
  /// @param str NULL-terminated UTF-8 string
  ///
  /// @return number of bytes written.
  int avio_put_str16le(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _avio_put_str16le(
      s,
      str,
    );
  }

  late final _avio_put_str16lePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Char>)>>('avio_put_str16le');
  late final _avio_put_str16le = _avio_put_str16lePtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>)>();

  /// Convert an UTF-8 string to UTF-16BE and write it.
  /// @param s the AVIOContext
  /// @param str NULL-terminated UTF-8 string
  ///
  /// @return number of bytes written.
  int avio_put_str16be(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _avio_put_str16be(
      s,
      str,
    );
  }

  late final _avio_put_str16bePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Char>)>>('avio_put_str16be');
  late final _avio_put_str16be = _avio_put_str16bePtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>)>();

  /// Mark the written bytestream as a specific type.
  ///
  /// Zero-length ranges are omitted from the output.
  ///
  /// @param s    the AVIOContext
  /// @param time the stream time the current bytestream pos corresponds to
  /// (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
  /// applicable
  /// @param type the kind of data written starting at the current pos
  void avio_write_marker(
    ffi.Pointer<AVIOContext> s,
    int time,
    AVIODataMarkerType type,
  ) {
    return _avio_write_marker(
      s,
      time,
      type.value,
    );
  }

  late final _avio_write_markerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVIOContext>, ffi.Int64,
              ffi.UnsignedInt)>>('avio_write_marker');
  late final _avio_write_marker = _avio_write_markerPtr
      .asFunction<void Function(ffi.Pointer<AVIOContext>, int, int)>();

  /// fseek() equivalent for AVIOContext.
  /// @return new position or AVERROR.
  int avio_seek(
    ffi.Pointer<AVIOContext> s,
    int offset,
    int whence,
  ) {
    return _avio_seek(
      s,
      offset,
      whence,
    );
  }

  late final _avio_seekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<AVIOContext>, ffi.Int64, ffi.Int)>>('avio_seek');
  late final _avio_seek = _avio_seekPtr
      .asFunction<int Function(ffi.Pointer<AVIOContext>, int, int)>();

  /// Skip given number of bytes forward
  /// @return new position or AVERROR.
  int avio_skip(
    ffi.Pointer<AVIOContext> s,
    int offset,
  ) {
    return _avio_skip(
      s,
      offset,
    );
  }

  late final _avio_skipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<AVIOContext>, ffi.Int64)>>('avio_skip');
  late final _avio_skip =
      _avio_skipPtr.asFunction<int Function(ffi.Pointer<AVIOContext>, int)>();

  /// Get the filesize.
  /// @return filesize or AVERROR
  int avio_size(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_size(
      s,
    );
  }

  late final _avio_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<AVIOContext>)>>(
          'avio_size');
  late final _avio_size =
      _avio_sizePtr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  /// Similar to feof() but also returns nonzero on read errors.
  /// @return non zero if and only if at end of file or a read error happened when reading.
  int avio_feof(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_feof(
      s,
    );
  }

  late final _avio_feofPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVIOContext>)>>(
          'avio_feof');
  late final _avio_feof =
      _avio_feofPtr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  /// Writes a formatted string to the context taking a va_list.
  /// @return number of bytes written, < 0 on error.
  int avio_vprintf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Char> fmt,
    va_list2 ap,
  ) {
    return _avio_vprintf(
      s,
      fmt,
      ap,
    );
  }

  late final _avio_vprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>,
              va_list2)>>('avio_vprintf');
  late final _avio_vprintf = _avio_vprintfPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>, va_list2)>();

  /// Writes a formatted string to the context.
  /// @return number of bytes written, < 0 on error.
  int avio_printf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _avio_printf(
      s,
      fmt,
    );
  }

  late final _avio_printfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>)>>('avio_printf');
  late final _avio_printf = _avio_printfPtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Char>)>();

  /// Write a NULL terminated array of strings to the context.
  /// Usually you don't need to use this function directly but its macro wrapper,
  /// avio_print.
  void avio_print_string_array(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Char>> strings,
  ) {
    return _avio_print_string_array(
      s,
      strings,
    );
  }

  late final _avio_print_string_arrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('avio_print_string_array');
  late final _avio_print_string_array = _avio_print_string_arrayPtr.asFunction<
      void Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Force flushing of buffered data.
  ///
  /// For write streams, force the buffered data to be immediately written to the output,
  /// without to wait to fill the internal buffer.
  ///
  /// For read streams, discard all currently buffered data, and advance the
  /// reported file position to that of the underlying stream. This does not
  /// read new data, and does not perform any seeks.
  void avio_flush(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_flush(
      s,
    );
  }

  late final _avio_flushPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVIOContext>)>>(
          'avio_flush');
  late final _avio_flush =
      _avio_flushPtr.asFunction<void Function(ffi.Pointer<AVIOContext>)>();

  /// Read size bytes from AVIOContext into buf.
  /// @return number of bytes read or AVERROR
  int avio_read(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.UnsignedChar> buf,
    int size,
  ) {
    return _avio_read(
      s,
      buf,
      size,
    );
  }

  late final _avio_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('avio_read');
  late final _avio_read = _avio_readPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed
  /// to read fewer bytes than requested. The missing bytes can be read in the next
  /// call. This always tries to read at least 1 byte.
  /// Useful to reduce latency in certain cases.
  /// @return number of bytes read or AVERROR
  int avio_read_partial(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.UnsignedChar> buf,
    int size,
  ) {
    return _avio_read_partial(
      s,
      buf,
      size,
    );
  }

  late final _avio_read_partialPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('avio_read_partial');
  late final _avio_read_partial = _avio_read_partialPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.UnsignedChar>, int)>();

  /// @name Functions for reading from AVIOContext
  /// @{
  ///
  /// @note return 0 if EOF, so you cannot use it if EOF handling is
  /// necessary
  int avio_r8(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_r8(
      s,
    );
  }

  late final _avio_r8Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVIOContext>)>>(
          'avio_r8');
  late final _avio_r8 =
      _avio_r8Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rl16(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rl16(
      s,
    );
  }

  late final _avio_rl16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<AVIOContext>)>>('avio_rl16');
  late final _avio_rl16 =
      _avio_rl16Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rl24(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rl24(
      s,
    );
  }

  late final _avio_rl24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<AVIOContext>)>>('avio_rl24');
  late final _avio_rl24 =
      _avio_rl24Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rl32(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rl32(
      s,
    );
  }

  late final _avio_rl32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<AVIOContext>)>>('avio_rl32');
  late final _avio_rl32 =
      _avio_rl32Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rl64(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rl64(
      s,
    );
  }

  late final _avio_rl64Ptr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<AVIOContext>)>>(
      'avio_rl64');
  late final _avio_rl64 =
      _avio_rl64Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rb16(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rb16(
      s,
    );
  }

  late final _avio_rb16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<AVIOContext>)>>('avio_rb16');
  late final _avio_rb16 =
      _avio_rb16Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rb24(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rb24(
      s,
    );
  }

  late final _avio_rb24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<AVIOContext>)>>('avio_rb24');
  late final _avio_rb24 =
      _avio_rb24Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rb32(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rb32(
      s,
    );
  }

  late final _avio_rb32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<AVIOContext>)>>('avio_rb32');
  late final _avio_rb32 =
      _avio_rb32Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  int avio_rb64(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_rb64(
      s,
    );
  }

  late final _avio_rb64Ptr = _lookup<
          ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<AVIOContext>)>>(
      'avio_rb64');
  late final _avio_rb64 =
      _avio_rb64Ptr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  /// Read a string from pb into buf. The reading will terminate when either
  /// a NULL character was encountered, maxlen bytes have been read, or nothing
  /// more can be read from pb. The result is guaranteed to be NULL-terminated, it
  /// will be truncated if buf is too small.
  /// Note that the string is not interpreted or validated in any way, it
  /// might get truncated in the middle of a sequence for multi-byte encodings.
  ///
  /// @return number of bytes read (is always <= maxlen).
  /// If reading ends on EOF or error, the return value will be one more than
  /// bytes actually read.
  int avio_get_str(
    ffi.Pointer<AVIOContext> pb,
    int maxlen,
    ffi.Pointer<ffi.Char> buf,
    int buflen,
  ) {
    return _avio_get_str(
      pb,
      maxlen,
      buf,
      buflen,
    );
  }

  late final _avio_get_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('avio_get_str');
  late final _avio_get_str = _avio_get_strPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Read a UTF-16 string from pb and convert it to UTF-8.
  /// The reading will terminate when either a null or invalid character was
  /// encountered or maxlen bytes have been read.
  /// @return number of bytes read (is always <= maxlen)
  int avio_get_str16le(
    ffi.Pointer<AVIOContext> pb,
    int maxlen,
    ffi.Pointer<ffi.Char> buf,
    int buflen,
  ) {
    return _avio_get_str16le(
      pb,
      maxlen,
      buf,
      buflen,
    );
  }

  late final _avio_get_str16lePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('avio_get_str16le');
  late final _avio_get_str16le = _avio_get_str16lePtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, int, ffi.Pointer<ffi.Char>, int)>();

  int avio_get_str16be(
    ffi.Pointer<AVIOContext> pb,
    int maxlen,
    ffi.Pointer<ffi.Char> buf,
    int buflen,
  ) {
    return _avio_get_str16be(
      pb,
      maxlen,
      buf,
      buflen,
    );
  }

  late final _avio_get_str16bePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('avio_get_str16be');
  late final _avio_get_str16be = _avio_get_str16bePtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Create and initialize a AVIOContext for accessing the
  /// resource indicated by url.
  /// @note When the resource indicated by url has been opened in
  /// read+write mode, the AVIOContext can be used only for writing.
  ///
  /// @param s Used to return the pointer to the created AVIOContext.
  /// In case of failure the pointed to value is set to NULL.
  /// @param url resource to access
  /// @param flags flags which control how the resource indicated by url
  /// is to be opened
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code in case of failure
  int avio_open(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
    ffi.Pointer<ffi.Char> url,
    int flags,
  ) {
    return _avio_open(
      s,
      url,
      flags,
    );
  }

  late final _avio_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVIOContext>>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('avio_open');
  late final _avio_open = _avio_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVIOContext>>, ffi.Pointer<ffi.Char>, int)>();

  /// Create and initialize a AVIOContext for accessing the
  /// resource indicated by url.
  /// @note When the resource indicated by url has been opened in
  /// read+write mode, the AVIOContext can be used only for writing.
  ///
  /// @param s Used to return the pointer to the created AVIOContext.
  /// In case of failure the pointed to value is set to NULL.
  /// @param url resource to access
  /// @param flags flags which control how the resource indicated by url
  /// is to be opened
  /// @param int_cb an interrupt callback to be used at the protocols level
  /// @param options  A dictionary filled with protocol-private options. On return
  /// this parameter will be destroyed and replaced with a dict containing options
  /// that were not found. May be NULL.
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code in case of failure
  int avio_open2(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
    ffi.Pointer<ffi.Char> url,
    int flags,
    ffi.Pointer<AVIOInterruptCB> int_cb,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avio_open2(
      s,
      url,
      flags,
      int_cb,
      options,
    );
  }

  late final _avio_open2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVIOContext>>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<AVIOInterruptCB>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('avio_open2');
  late final _avio_open2 = _avio_open2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVIOContext>>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<AVIOInterruptCB>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Close the resource accessed by the AVIOContext s and free it.
  /// This function can only be used if s was opened by avio_open().
  ///
  /// The internal buffer is automatically flushed before closing the
  /// resource.
  ///
  /// @return 0 on success, an AVERROR < 0 on error.
  /// @see avio_closep
  int avio_close(
    ffi.Pointer<AVIOContext> s,
  ) {
    return _avio_close(
      s,
    );
  }

  late final _avio_closePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVIOContext>)>>(
          'avio_close');
  late final _avio_close =
      _avio_closePtr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  /// Close the resource accessed by the AVIOContext *s, free it
  /// and set the pointer pointing to it to NULL.
  /// This function can only be used if s was opened by avio_open().
  ///
  /// The internal buffer is automatically flushed before closing the
  /// resource.
  ///
  /// @return 0 on success, an AVERROR < 0 on error.
  /// @see avio_close
  int avio_closep(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ) {
    return _avio_closep(
      s,
    );
  }

  late final _avio_closepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVIOContext>>)>>('avio_closep');
  late final _avio_closep = _avio_closepPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVIOContext>>)>();

  /// Open a write only memory stream.
  ///
  /// @param s new IO context
  /// @return zero if no error.
  int avio_open_dyn_buf(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ) {
    return _avio_open_dyn_buf(
      s,
    );
  }

  late final _avio_open_dyn_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVIOContext>>)>>('avio_open_dyn_buf');
  late final _avio_open_dyn_buf = _avio_open_dyn_bufPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVIOContext>>)>();

  /// Return the written size and a pointer to the buffer.
  /// The AVIOContext stream is left intact.
  /// The buffer must NOT be freed.
  /// No padding is added to the buffer.
  ///
  /// @param s IO context
  /// @param pbuffer pointer to a byte buffer
  /// @return the length of the byte buffer
  int avio_get_dyn_buf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
  ) {
    return _avio_get_dyn_buf(
      s,
      pbuffer,
    );
  }

  late final _avio_get_dyn_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('avio_get_dyn_buf');
  late final _avio_get_dyn_buf = _avio_get_dyn_bufPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Return the written size and a pointer to the buffer. The buffer
  /// must be freed with av_free().
  /// Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
  ///
  /// @param s IO context
  /// @param pbuffer pointer to a byte buffer
  /// @return the length of the byte buffer
  int avio_close_dyn_buf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
  ) {
    return _avio_close_dyn_buf(
      s,
      pbuffer,
    );
  }

  late final _avio_close_dyn_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('avio_close_dyn_buf');
  late final _avio_close_dyn_buf = _avio_close_dyn_bufPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Iterate through names of available protocols.
  ///
  /// @param opaque A private pointer representing current protocol.
  /// It must be a pointer to NULL on first iteration and will
  /// be updated by successive calls to avio_enum_protocols.
  /// @param output If set to 1, iterate over output protocols,
  /// otherwise over input protocols.
  ///
  /// @return A static string containing the name of current protocol or NULL
  ffi.Pointer<ffi.Char> avio_enum_protocols(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
    int output,
  ) {
    return _avio_enum_protocols(
      opaque,
      output,
    );
  }

  late final _avio_enum_protocolsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Int)>>('avio_enum_protocols');
  late final _avio_enum_protocols = _avio_enum_protocolsPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>, int)>();

  /// Get AVClass by names of available protocols.
  ///
  /// @return A AVClass of input protocol name or NULL
  ffi.Pointer<AVClass> avio_protocol_get_class(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avio_protocol_get_class(
      name,
    );
  }

  late final _avio_protocol_get_classPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVClass> Function(
              ffi.Pointer<ffi.Char>)>>('avio_protocol_get_class');
  late final _avio_protocol_get_class = _avio_protocol_get_classPtr
      .asFunction<ffi.Pointer<AVClass> Function(ffi.Pointer<ffi.Char>)>();

  /// Pause and resume playing - only meaningful if using a network streaming
  /// protocol (e.g. MMS).
  ///
  /// @param h     IO context from which to call the read_pause function pointer
  /// @param pause 1 for pause, 0 for resume
  int avio_pause(
    ffi.Pointer<AVIOContext> h,
    int pause,
  ) {
    return _avio_pause(
      h,
      pause,
    );
  }

  late final _avio_pausePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Int)>>('avio_pause');
  late final _avio_pause =
      _avio_pausePtr.asFunction<int Function(ffi.Pointer<AVIOContext>, int)>();

  /// Seek to a given timestamp relative to some component stream.
  /// Only meaningful if using a network streaming protocol (e.g. MMS.).
  ///
  /// @param h IO context from which to call the seek function pointers
  /// @param stream_index The stream index that the timestamp is relative to.
  /// If stream_index is (-1) the timestamp should be in AV_TIME_BASE
  /// units from the beginning of the presentation.
  /// If a stream_index >= 0 is used and the protocol does not support
  /// seeking based on component streams, the call will fail.
  /// @param timestamp timestamp in AVStream.time_base units
  /// or if there is no stream specified then in AV_TIME_BASE units.
  /// @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
  /// and AVSEEK_FLAG_ANY. The protocol may silently ignore
  /// AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
  /// fail if used and not supported.
  /// @return >= 0 on success
  /// @see AVInputFormat::read_seek
  int avio_seek_time(
    ffi.Pointer<AVIOContext> h,
    int stream_index,
    int timestamp,
    int flags,
  ) {
    return _avio_seek_time(
      h,
      stream_index,
      timestamp,
      flags,
    );
  }

  late final _avio_seek_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Pointer<AVIOContext>, ffi.Int, ffi.Int64,
              ffi.Int)>>('avio_seek_time');
  late final _avio_seek_time = _avio_seek_timePtr
      .asFunction<int Function(ffi.Pointer<AVIOContext>, int, int, int)>();

  /// Read contents of h into print buffer, up to max_size bytes, or up to EOF.
  ///
  /// @return 0 for success (max_size bytes read or EOF reached), negative error
  /// code otherwise
  int avio_read_to_bprint(
    ffi.Pointer<AVIOContext> h,
    ffi.Pointer<AVBPrint> pb,
    int max_size,
  ) {
    return _avio_read_to_bprint(
      h,
      pb,
      max_size,
    );
  }

  late final _avio_read_to_bprintPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<AVBPrint>,
              ffi.Size)>>('avio_read_to_bprint');
  late final _avio_read_to_bprint = _avio_read_to_bprintPtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<AVBPrint>, int)>();

  /// Accept and allocate a client context on a server context.
  /// @param  s the server context
  /// @param  c the client context, must be unallocated
  /// @return   >= 0 on success or a negative value corresponding
  /// to an AVERROR on failure
  int avio_accept(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<AVIOContext>> c,
  ) {
    return _avio_accept(
      s,
      c,
    );
  }

  late final _avio_acceptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Pointer<AVIOContext>>)>>('avio_accept');
  late final _avio_accept = _avio_acceptPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>, ffi.Pointer<ffi.Pointer<AVIOContext>>)>();

  /// Perform one step of the protocol handshake to accept a new client.
  /// This function must be called on a client returned by avio_accept() before
  /// using it as a read/write context.
  /// It is separate from avio_accept() because it may block.
  /// A step of the handshake is defined by places where the application may
  /// decide to change the proceedings.
  /// For example, on a protocol with a request header and a reply header, each
  /// one can constitute a step because the application may use the parameters
  /// from the request to change parameters in the reply; or each individual
  /// chunk of the request can constitute a step.
  /// If the handshake is already finished, avio_handshake() does nothing and
  /// returns 0 immediately.
  ///
  /// @param  c the client context to perform the handshake on
  /// @return   0   on a complete and successful handshake
  /// > 0 if the handshake progressed, but is not complete
  /// < 0 for an AVERROR code
  int avio_handshake(
    ffi.Pointer<AVIOContext> c,
  ) {
    return _avio_handshake(
      c,
    );
  }

  late final _avio_handshakePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVIOContext>)>>(
          'avio_handshake');
  late final _avio_handshake =
      _avio_handshakePtr.asFunction<int Function(ffi.Pointer<AVIOContext>)>();

  /// Allocate and read the payload of a packet and initialize its
  /// fields with default values.
  ///
  /// @param s    associated IO context
  /// @param pkt packet
  /// @param size desired payload size
  /// @return >0 (read size) if OK, AVERROR_xxx otherwise
  int av_get_packet(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    return _av_get_packet(
      s,
      pkt,
      size,
    );
  }

  late final _av_get_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<AVPacket>,
              ffi.Int)>>('av_get_packet');
  late final _av_get_packet = _av_get_packetPtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<AVPacket>, int)>();

  /// Read data and append it to the current content of the AVPacket.
  /// If pkt->size is 0 this is identical to av_get_packet.
  /// Note that this uses av_grow_packet and thus involves a realloc
  /// which is inefficient. Thus this function should only be used
  /// when there is no reasonable way to know (an upper bound of)
  /// the final size.
  ///
  /// @param s    associated IO context
  /// @param pkt packet
  /// @param size amount of data to read
  /// @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
  /// will not be lost even if an error occurs.
  int av_append_packet(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    return _av_append_packet(
      s,
      pkt,
      size,
    );
  }

  late final _av_append_packetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<AVPacket>,
              ffi.Int)>>('av_append_packet');
  late final _av_append_packet = _av_append_packetPtr.asFunction<
      int Function(ffi.Pointer<AVIOContext>, ffi.Pointer<AVPacket>, int)>();

  /// @return The AV_DISPOSITION_* flag corresponding to disp or a negative error
  /// code if disp does not correspond to a known stream disposition.
  int av_disposition_from_string(
    ffi.Pointer<ffi.Char> disp,
  ) {
    return _av_disposition_from_string(
      disp,
    );
  }

  late final _av_disposition_from_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_disposition_from_string');
  late final _av_disposition_from_string = _av_disposition_from_stringPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @param disposition a combination of AV_DISPOSITION_* values
  /// @return The string description corresponding to the lowest set bit in
  /// disposition. NULL when the lowest set bit does not correspond
  /// to a known disposition or when disposition is 0.
  ffi.Pointer<ffi.Char> av_disposition_to_string(
    int disposition,
  ) {
    return _av_disposition_to_string(
      disposition,
    );
  }

  late final _av_disposition_to_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'av_disposition_to_string');
  late final _av_disposition_to_string = _av_disposition_to_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  ffi.Pointer<AVCodecParserContext> av_stream_get_parser(
    ffi.Pointer<AVStream> s,
  ) {
    return _av_stream_get_parser(
      s,
    );
  }

  late final _av_stream_get_parserPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVCodecParserContext> Function(
              ffi.Pointer<AVStream>)>>('av_stream_get_parser');
  late final _av_stream_get_parser = _av_stream_get_parserPtr.asFunction<
      ffi.Pointer<AVCodecParserContext> Function(ffi.Pointer<AVStream>)>();

  int av_stream_get_first_dts(
    ffi.Pointer<AVStream> st,
  ) {
    return _av_stream_get_first_dts(
      st,
    );
  }

  late final _av_stream_get_first_dtsPtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function(ffi.Pointer<AVStream>)>>(
          'av_stream_get_first_dts');
  late final _av_stream_get_first_dts = _av_stream_get_first_dtsPtr
      .asFunction<int Function(ffi.Pointer<AVStream>)>();

  /// This function will cause global side data to be injected in the next packet
  /// of each stream as well as after any subsequent seek.
  ///
  /// @note global side data is always available in every AVStream's
  /// @ref AVCodecParameters.coded_side_data "codecpar side data" array, and
  /// in a @ref AVCodecContext.coded_side_data "decoder's side data" array if
  /// initialized with said stream's codecpar.
  /// @see av_packet_side_data_get()
  void av_format_inject_global_side_data(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _av_format_inject_global_side_data(
      s,
    );
  }

  late final _av_format_inject_global_side_dataPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFormatContext>)>>(
      'av_format_inject_global_side_data');
  late final _av_format_inject_global_side_data =
      _av_format_inject_global_side_dataPtr
          .asFunction<void Function(ffi.Pointer<AVFormatContext>)>();

  /// Returns the method used to set ctx->duration.
  ///
  /// @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
  /// @deprecated duration_estimation_method is public and can be read directly.
  AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(
    ffi.Pointer<AVFormatContext> ctx,
  ) {
    return AVDurationEstimationMethod.fromValue(
        _av_fmt_ctx_get_duration_estimation_method(
      ctx,
    ));
  }

  late final _av_fmt_ctx_get_duration_estimation_methodPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<AVFormatContext>)>>(
      'av_fmt_ctx_get_duration_estimation_method');
  late final _av_fmt_ctx_get_duration_estimation_method =
      _av_fmt_ctx_get_duration_estimation_methodPtr
          .asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// Return the LIBAVFORMAT_VERSION_INT constant.
  int avformat_version() {
    return _avformat_version();
  }

  late final _avformat_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'avformat_version');
  late final _avformat_version =
      _avformat_versionPtr.asFunction<int Function()>();

  /// Return the libavformat build-time configuration.
  ffi.Pointer<ffi.Char> avformat_configuration() {
    return _avformat_configuration();
  }

  late final _avformat_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avformat_configuration');
  late final _avformat_configuration =
      _avformat_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libavformat license.
  ffi.Pointer<ffi.Char> avformat_license() {
    return _avformat_license();
  }

  late final _avformat_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avformat_license');
  late final _avformat_license =
      _avformat_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Do global initialization of network libraries. This is optional,
  /// and not recommended anymore.
  ///
  /// This functions only exists to work around thread-safety issues
  /// with older GnuTLS or OpenSSL libraries. If libavformat is linked
  /// to newer versions of those libraries, or if you do not use them,
  /// calling this function is unnecessary. Otherwise, you need to call
  /// this function before any other threads using them are started.
  ///
  /// This function will be deprecated once support for older GnuTLS and
  /// OpenSSL libraries is removed, and this function has no purpose
  /// anymore.
  int avformat_network_init() {
    return _avformat_network_init();
  }

  late final _avformat_network_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('avformat_network_init');
  late final _avformat_network_init =
      _avformat_network_initPtr.asFunction<int Function()>();

  /// Undo the initialization done by avformat_network_init. Call it only
  /// once for each time you called avformat_network_init.
  int avformat_network_deinit() {
    return _avformat_network_deinit();
  }

  late final _avformat_network_deinitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'avformat_network_deinit');
  late final _avformat_network_deinit =
      _avformat_network_deinitPtr.asFunction<int Function()>();

  /// Iterate over all registered muxers.
  ///
  /// @param opaque a pointer where libavformat will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered muxer or NULL when the iteration is
  /// finished
  ffi.Pointer<AVOutputFormat> av_muxer_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_muxer_iterate(
      opaque,
    );
  }

  late final _av_muxer_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOutputFormat> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_muxer_iterate');
  late final _av_muxer_iterate = _av_muxer_iteratePtr.asFunction<
      ffi.Pointer<AVOutputFormat> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Iterate over all registered demuxers.
  ///
  /// @param opaque a pointer where libavformat will store the iteration state.
  /// Must point to NULL to start the iteration.
  ///
  /// @return the next registered demuxer or NULL when the iteration is
  /// finished
  ffi.Pointer<AVInputFormat> av_demuxer_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_demuxer_iterate(
      opaque,
    );
  }

  late final _av_demuxer_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_demuxer_iterate');
  late final _av_demuxer_iterate = _av_demuxer_iteratePtr.asFunction<
      ffi.Pointer<AVInputFormat> Function(
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Allocate an AVFormatContext.
  /// avformat_free_context() can be used to free the context and everything
  /// allocated by the framework within it.
  ffi.Pointer<AVFormatContext> avformat_alloc_context() {
    return _avformat_alloc_context();
  }

  late final _avformat_alloc_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVFormatContext> Function()>>(
          'avformat_alloc_context');
  late final _avformat_alloc_context = _avformat_alloc_contextPtr
      .asFunction<ffi.Pointer<AVFormatContext> Function()>();

  /// Free an AVFormatContext and all its streams.
  /// @param s context to free
  void avformat_free_context(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _avformat_free_context(
      s,
    );
  }

  late final _avformat_free_contextPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFormatContext>)>>(
      'avformat_free_context');
  late final _avformat_free_context = _avformat_free_contextPtr
      .asFunction<void Function(ffi.Pointer<AVFormatContext>)>();

  /// Get the AVClass for AVFormatContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avformat_get_class() {
    return _avformat_get_class();
  }

  late final _avformat_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'avformat_get_class');
  late final _avformat_get_class =
      _avformat_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Get the AVClass for AVStream. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> av_stream_get_class() {
    return _av_stream_get_class();
  }

  late final _av_stream_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'av_stream_get_class');
  late final _av_stream_get_class =
      _av_stream_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Get the AVClass for AVStreamGroup. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> av_stream_group_get_class() {
    return _av_stream_group_get_class();
  }

  late final _av_stream_group_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'av_stream_group_get_class');
  late final _av_stream_group_get_class = _av_stream_group_get_classPtr
      .asFunction<ffi.Pointer<AVClass> Function()>();

  /// @return a string identifying the stream group type, or NULL if unknown
  ffi.Pointer<ffi.Char> avformat_stream_group_name(
    AVStreamGroupParamsType type,
  ) {
    return _avformat_stream_group_name(
      type.value,
    );
  }

  late final _avformat_stream_group_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'avformat_stream_group_name');
  late final _avformat_stream_group_name = _avformat_stream_group_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Add a new empty stream group to a media file.
  ///
  /// When demuxing, it may be called by the demuxer in read_header(). If the
  /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
  /// be called in read_packet().
  ///
  /// When muxing, may be called by the user before avformat_write_header().
  ///
  /// User is required to call avformat_free_context() to clean up the allocation
  /// by avformat_stream_group_create().
  ///
  /// New streams can be added to the group with avformat_stream_group_add_stream().
  ///
  /// @param s media file handle
  ///
  /// @return newly created group or NULL on error.
  /// @see avformat_new_stream, avformat_stream_group_add_stream.
  ffi.Pointer<AVStreamGroup> avformat_stream_group_create(
    ffi.Pointer<AVFormatContext> s,
    AVStreamGroupParamsType type,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avformat_stream_group_create(
      s,
      type.value,
      options,
    );
  }

  late final _avformat_stream_group_createPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVStreamGroup> Function(ffi.Pointer<AVFormatContext>,
                  ffi.UnsignedInt, ffi.Pointer<ffi.Pointer<AVDictionary>>)>>(
      'avformat_stream_group_create');
  late final _avformat_stream_group_create =
      _avformat_stream_group_createPtr.asFunction<
          ffi.Pointer<AVStreamGroup> Function(ffi.Pointer<AVFormatContext>, int,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Add a new stream to a media file.
  ///
  /// When demuxing, it is called by the demuxer in read_header(). If the
  /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
  /// be called in read_packet().
  ///
  /// When muxing, should be called by the user before avformat_write_header().
  ///
  /// User is required to call avformat_free_context() to clean up the allocation
  /// by avformat_new_stream().
  ///
  /// @param s media file handle
  /// @param c unused, does nothing
  ///
  /// @return newly created stream or NULL on error.
  ffi.Pointer<AVStream> avformat_new_stream(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVCodec> c,
  ) {
    return _avformat_new_stream(
      s,
      c,
    );
  }

  late final _avformat_new_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVStream> Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVCodec>)>>('avformat_new_stream');
  late final _avformat_new_stream = _avformat_new_streamPtr.asFunction<
      ffi.Pointer<AVStream> Function(
          ffi.Pointer<AVFormatContext>, ffi.Pointer<AVCodec>)>();

  /// Add an already allocated stream to a stream group.
  ///
  /// When demuxing, it may be called by the demuxer in read_header(). If the
  /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
  /// be called in read_packet().
  ///
  /// When muxing, may be called by the user before avformat_write_header() after
  /// having allocated a new group with avformat_stream_group_create() and stream with
  /// avformat_new_stream().
  ///
  /// User is required to call avformat_free_context() to clean up the allocation
  /// by avformat_stream_group_add_stream().
  ///
  /// @param stg stream group belonging to a media file.
  /// @param st  stream in the media file to add to the group.
  ///
  /// @retval 0                 success
  /// @retval AVERROR(EEXIST)   the stream was already in the group
  /// @retval "another negative error code" legitimate errors
  ///
  /// @see avformat_new_stream, avformat_stream_group_create.
  int avformat_stream_group_add_stream(
    ffi.Pointer<AVStreamGroup> stg,
    ffi.Pointer<AVStream> st,
  ) {
    return _avformat_stream_group_add_stream(
      stg,
      st,
    );
  }

  late final _avformat_stream_group_add_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVStreamGroup>,
              ffi.Pointer<AVStream>)>>('avformat_stream_group_add_stream');
  late final _avformat_stream_group_add_stream =
      _avformat_stream_group_add_streamPtr.asFunction<
          int Function(ffi.Pointer<AVStreamGroup>, ffi.Pointer<AVStream>)>();

  /// Wrap an existing array as stream side data.
  ///
  /// @param st   stream
  /// @param type side information type
  /// @param data the side data array. It must be allocated with the av_malloc()
  /// family of functions. The ownership of the data is transferred to
  /// st.
  /// @param size side information size
  ///
  /// @return zero on success, a negative AVERROR code on failure. On failure,
  /// the stream is unchanged and the data remains owned by the caller.
  /// @deprecated use av_packet_side_data_add() with the stream's
  /// @ref AVCodecParameters.coded_side_data "codecpar side data"
  int av_stream_add_side_data(
    ffi.Pointer<AVStream> st,
    AVPacketSideDataType type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _av_stream_add_side_data(
      st,
      type.value,
      data,
      size,
    );
  }

  late final _av_stream_add_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVStream>, ffi.UnsignedInt,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('av_stream_add_side_data');
  late final _av_stream_add_side_data = _av_stream_add_side_dataPtr.asFunction<
      int Function(ffi.Pointer<AVStream>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate new information from stream.
  ///
  /// @param stream stream
  /// @param type   desired side information type
  /// @param size   side information size
  ///
  /// @return pointer to fresh allocated data or NULL otherwise
  /// @deprecated use av_packet_side_data_new() with the stream's
  /// @ref AVCodecParameters.coded_side_data "codecpar side data"
  ffi.Pointer<ffi.Uint8> av_stream_new_side_data(
    ffi.Pointer<AVStream> stream,
    AVPacketSideDataType type,
    int size,
  ) {
    return _av_stream_new_side_data(
      stream,
      type.value,
      size,
    );
  }

  late final _av_stream_new_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVStream>,
              ffi.UnsignedInt, ffi.Size)>>('av_stream_new_side_data');
  late final _av_stream_new_side_data = _av_stream_new_side_dataPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVStream>, int, int)>();

  /// Get side information from stream.
  ///
  /// @param stream stream
  /// @param type   desired side information type
  /// @param size   If supplied, *size will be set to the size of the side data
  /// or to zero if the desired side data is not present.
  ///
  /// @return pointer to data if present or NULL otherwise
  /// @deprecated use av_packet_side_data_get() with the stream's
  /// @ref AVCodecParameters.coded_side_data "codecpar side data"
  ffi.Pointer<ffi.Uint8> av_stream_get_side_data(
    ffi.Pointer<AVStream> stream,
    AVPacketSideDataType type,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_stream_get_side_data(
      stream,
      type.value,
      size,
    );
  }

  late final _av_stream_get_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<AVStream>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Size>)>>('av_stream_get_side_data');
  late final _av_stream_get_side_data = _av_stream_get_side_dataPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(
          ffi.Pointer<AVStream>, int, ffi.Pointer<ffi.Size>)>();

  ffi.Pointer<AVProgram> av_new_program(
    ffi.Pointer<AVFormatContext> s,
    int id,
  ) {
    return _av_new_program(
      s,
      id,
    );
  }

  late final _av_new_programPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVProgram> Function(
              ffi.Pointer<AVFormatContext>, ffi.Int)>>('av_new_program');
  late final _av_new_program = _av_new_programPtr.asFunction<
      ffi.Pointer<AVProgram> Function(ffi.Pointer<AVFormatContext>, int)>();

  /// Allocate an AVFormatContext for an output format.
  /// avformat_free_context() can be used to free the context and
  /// everything allocated by the framework within it.
  ///
  /// @param ctx           pointee is set to the created format context,
  /// or to NULL in case of failure
  /// @param oformat       format to use for allocating the context, if NULL
  /// format_name and filename are used instead
  /// @param format_name   the name of output format to use for allocating the
  /// context, if NULL filename is used instead
  /// @param filename      the name of the filename to use for allocating the
  /// context, may be NULL
  ///
  /// @return  >= 0 in case of success, a negative AVERROR code in case of
  /// failure
  int avformat_alloc_output_context2(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> ctx,
    ffi.Pointer<AVOutputFormat> oformat,
    ffi.Pointer<ffi.Char> format_name,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _avformat_alloc_output_context2(
      ctx,
      oformat,
      format_name,
      filename,
    );
  }

  late final _avformat_alloc_output_context2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVFormatContext>>,
              ffi.Pointer<AVOutputFormat>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('avformat_alloc_output_context2');
  late final _avformat_alloc_output_context2 =
      _avformat_alloc_output_context2Ptr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<AVFormatContext>>,
              ffi.Pointer<AVOutputFormat>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Find AVInputFormat based on the short name of the input format.
  ffi.Pointer<AVInputFormat> av_find_input_format(
    ffi.Pointer<ffi.Char> short_name,
  ) {
    return _av_find_input_format(
      short_name,
    );
  }

  late final _av_find_input_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(
              ffi.Pointer<ffi.Char>)>>('av_find_input_format');
  late final _av_find_input_format = _av_find_input_formatPtr
      .asFunction<ffi.Pointer<AVInputFormat> Function(ffi.Pointer<ffi.Char>)>();

  /// Guess the file format.
  ///
  /// @param pd        data to be probed
  /// @param is_opened Whether the file is already opened; determines whether
  /// demuxers with or without AVFMT_NOFILE are probed.
  ffi.Pointer<AVInputFormat> av_probe_input_format(
    ffi.Pointer<AVProbeData> pd,
    int is_opened,
  ) {
    return _av_probe_input_format(
      pd,
      is_opened,
    );
  }

  late final _av_probe_input_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(
              ffi.Pointer<AVProbeData>, ffi.Int)>>('av_probe_input_format');
  late final _av_probe_input_format = _av_probe_input_formatPtr.asFunction<
      ffi.Pointer<AVInputFormat> Function(ffi.Pointer<AVProbeData>, int)>();

  /// Guess the file format.
  ///
  /// @param pd        data to be probed
  /// @param is_opened Whether the file is already opened; determines whether
  /// demuxers with or without AVFMT_NOFILE are probed.
  /// @param score_max A probe score larger that this is required to accept a
  /// detection, the variable is set to the actual detection
  /// score afterwards.
  /// If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
  /// to retry with a larger probe buffer.
  ffi.Pointer<AVInputFormat> av_probe_input_format2(
    ffi.Pointer<AVProbeData> pd,
    int is_opened,
    ffi.Pointer<ffi.Int> score_max,
  ) {
    return _av_probe_input_format2(
      pd,
      is_opened,
      score_max,
    );
  }

  late final _av_probe_input_format2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(ffi.Pointer<AVProbeData>, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('av_probe_input_format2');
  late final _av_probe_input_format2 = _av_probe_input_format2Ptr.asFunction<
      ffi.Pointer<AVInputFormat> Function(
          ffi.Pointer<AVProbeData>, int, ffi.Pointer<ffi.Int>)>();

  /// Guess the file format.
  ///
  /// @param is_opened Whether the file is already opened; determines whether
  /// demuxers with or without AVFMT_NOFILE are probed.
  /// @param score_ret The score of the best detection.
  ffi.Pointer<AVInputFormat> av_probe_input_format3(
    ffi.Pointer<AVProbeData> pd,
    int is_opened,
    ffi.Pointer<ffi.Int> score_ret,
  ) {
    return _av_probe_input_format3(
      pd,
      is_opened,
      score_ret,
    );
  }

  late final _av_probe_input_format3Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(ffi.Pointer<AVProbeData>, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('av_probe_input_format3');
  late final _av_probe_input_format3 = _av_probe_input_format3Ptr.asFunction<
      ffi.Pointer<AVInputFormat> Function(
          ffi.Pointer<AVProbeData>, int, ffi.Pointer<ffi.Int>)>();

  /// Probe a bytestream to determine the input format. Each time a probe returns
  /// with a score that is too low, the probe buffer size is increased and another
  /// attempt is made. When the maximum probe size is reached, the input format
  /// with the highest score is returned.
  ///
  /// @param pb             the bytestream to probe
  /// @param fmt            the input format is put here
  /// @param url            the url of the stream
  /// @param logctx         the log context
  /// @param offset         the offset within the bytestream to probe from
  /// @param max_probe_size the maximum probe buffer size (zero for default)
  ///
  /// @return the score in case of success, a negative value corresponding to an
  /// the maximal score is AVPROBE_SCORE_MAX
  /// AVERROR code otherwise
  int av_probe_input_buffer2(
    ffi.Pointer<AVIOContext> pb,
    ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Void> logctx,
    int offset,
    int max_probe_size,
  ) {
    return _av_probe_input_buffer2(
      pb,
      fmt,
      url,
      logctx,
      offset,
      max_probe_size,
    );
  }

  late final _av_probe_input_buffer2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Pointer<AVInputFormat>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('av_probe_input_buffer2');
  late final _av_probe_input_buffer2 = _av_probe_input_buffer2Ptr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>,
          ffi.Pointer<ffi.Pointer<AVInputFormat>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Like av_probe_input_buffer2() but returns 0 on success
  int av_probe_input_buffer(
    ffi.Pointer<AVIOContext> pb,
    ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Void> logctx,
    int offset,
    int max_probe_size,
  ) {
    return _av_probe_input_buffer(
      pb,
      fmt,
      url,
      logctx,
      offset,
      max_probe_size,
    );
  }

  late final _av_probe_input_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVIOContext>,
              ffi.Pointer<ffi.Pointer<AVInputFormat>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('av_probe_input_buffer');
  late final _av_probe_input_buffer = _av_probe_input_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<AVIOContext>,
          ffi.Pointer<ffi.Pointer<AVInputFormat>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          int)>();

  /// Open an input stream and read the header. The codecs are not opened.
  /// The stream must be closed with avformat_close_input().
  ///
  /// @param ps       Pointer to user-supplied AVFormatContext (allocated by
  /// avformat_alloc_context). May be a pointer to NULL, in
  /// which case an AVFormatContext is allocated by this
  /// function and written into ps.
  /// Note that a user-supplied AVFormatContext will be freed
  /// on failure.
  /// @param url      URL of the stream to open.
  /// @param fmt      If non-NULL, this parameter forces a specific input format.
  /// Otherwise the format is autodetected.
  /// @param options  A dictionary filled with AVFormatContext and demuxer-private
  /// options.
  /// On return this parameter will be destroyed and replaced with
  /// a dict containing options that were not found. May be NULL.
  ///
  /// @return 0 on success, a negative AVERROR on failure.
  ///
  /// @note If you want to use custom IO, preallocate the format context and set its pb field.
  int avformat_open_input(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> ps,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<AVInputFormat> fmt,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avformat_open_input(
      ps,
      url,
      fmt,
      options,
    );
  }

  late final _avformat_open_inputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVFormatContext>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVInputFormat>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('avformat_open_input');
  late final _avformat_open_input = _avformat_open_inputPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVFormatContext>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<AVInputFormat>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Read packets of a media file to get stream information. This
  /// is useful for file formats with no headers such as MPEG. This
  /// function also computes the real framerate in case of MPEG-2 repeat
  /// frame mode.
  /// The logical file position is not changed by this function;
  /// examined packets may be buffered for later processing.
  ///
  /// @param ic media file handle
  /// @param options  If non-NULL, an ic.nb_streams long array of pointers to
  /// dictionaries, where i-th member contains options for
  /// codec corresponding to i-th stream.
  /// On return each dictionary will be filled with options that were not found.
  /// @return >=0 if OK, AVERROR_xxx on error
  ///
  /// @note this function isn't guaranteed to open all the codecs, so
  /// options being non-empty at return is a perfectly normal behavior.
  ///
  /// @todo Let the user decide somehow what information is needed so that
  /// we do not waste time getting stuff the user does not need.
  int avformat_find_stream_info(
    ffi.Pointer<AVFormatContext> ic,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avformat_find_stream_info(
      ic,
      options,
    );
  }

  late final _avformat_find_stream_infoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<AVFormatContext>,
                  ffi.Pointer<ffi.Pointer<AVDictionary>>)>>(
      'avformat_find_stream_info');
  late final _avformat_find_stream_info =
      _avformat_find_stream_infoPtr.asFunction<
          int Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Find the programs which belong to a given stream.
  ///
  /// @param ic    media file handle
  /// @param last  the last found program, the search will start after this
  /// program, or from the beginning if it is NULL
  /// @param s     stream index
  ///
  /// @return the next program which belongs to s, NULL if no program is found or
  /// the last program is not among the programs of ic.
  ffi.Pointer<AVProgram> av_find_program_from_stream(
    ffi.Pointer<AVFormatContext> ic,
    ffi.Pointer<AVProgram> last,
    int s,
  ) {
    return _av_find_program_from_stream(
      ic,
      last,
      s,
    );
  }

  late final _av_find_program_from_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVProgram> Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVProgram>, ffi.Int)>>('av_find_program_from_stream');
  late final _av_find_program_from_stream =
      _av_find_program_from_streamPtr.asFunction<
          ffi.Pointer<AVProgram> Function(
              ffi.Pointer<AVFormatContext>, ffi.Pointer<AVProgram>, int)>();

  void av_program_add_stream_index(
    ffi.Pointer<AVFormatContext> ac,
    int progid,
    int idx,
  ) {
    return _av_program_add_stream_index(
      ac,
      progid,
      idx,
    );
  }

  late final _av_program_add_stream_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVFormatContext>, ffi.Int,
              ffi.UnsignedInt)>>('av_program_add_stream_index');
  late final _av_program_add_stream_index = _av_program_add_stream_indexPtr
      .asFunction<void Function(ffi.Pointer<AVFormatContext>, int, int)>();

  /// Find the "best" stream in the file.
  /// The best stream is determined according to various heuristics as the most
  /// likely to be what the user expects.
  /// If the decoder parameter is non-NULL, av_find_best_stream will find the
  /// default decoder for the stream's codec; streams for which no decoder can
  /// be found are ignored.
  ///
  /// @param ic                media file handle
  /// @param type              stream type: video, audio, subtitles, etc.
  /// @param wanted_stream_nb  user-requested stream number,
  /// or -1 for automatic selection
  /// @param related_stream    try to find a stream related (eg. in the same
  /// program) to this one, or -1 if none
  /// @param decoder_ret       if non-NULL, returns the decoder for the
  /// selected stream
  /// @param flags             flags; none are currently defined
  ///
  /// @return  the non-negative stream number in case of success,
  /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
  /// could be found,
  /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
  ///
  /// @note  If av_find_best_stream returns successfully and decoder_ret is not
  /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
  int av_find_best_stream(
    ffi.Pointer<AVFormatContext> ic,
    AVMediaType type,
    int wanted_stream_nb,
    int related_stream,
    ffi.Pointer<ffi.Pointer<AVCodec>> decoder_ret,
    int flags,
  ) {
    return _av_find_best_stream(
      ic,
      type.value,
      wanted_stream_nb,
      related_stream,
      decoder_ret,
      flags,
    );
  }

  late final _av_find_best_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFormatContext>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<AVCodec>>,
              ffi.Int)>>('av_find_best_stream');
  late final _av_find_best_stream = _av_find_best_streamPtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>, int, int, int,
          ffi.Pointer<ffi.Pointer<AVCodec>>, int)>();

  /// Return the next frame of a stream.
  /// This function returns what is stored in the file, and does not validate
  /// that what is there are valid frames for the decoder. It will split what is
  /// stored in the file into frames and return one for each call. It will not
  /// omit invalid data between valid frames so as to give the decoder the maximum
  /// information possible for decoding.
  ///
  /// On success, the returned packet is reference-counted (pkt->buf is set) and
  /// valid indefinitely. The packet must be freed with av_packet_unref() when
  /// it is no longer needed. For video, the packet contains exactly one frame.
  /// For audio, it contains an integer number of frames if each frame has
  /// a known fixed size (e.g. PCM or ADPCM data). If the audio frames have
  /// a variable size (e.g. MPEG audio), then it contains one frame.
  ///
  /// pkt->pts, pkt->dts and pkt->duration are always set to correct
  /// values in AVStream.time_base units (and guessed if the format cannot
  /// provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
  /// has B-frames, so it is better to rely on pkt->dts if you do not
  /// decompress the payload.
  ///
  /// @return 0 if OK, < 0 on error or end of file. On error, pkt will be blank
  /// (as if it came from av_packet_alloc()).
  ///
  /// @note pkt will be initialized, so it may be uninitialized, but it must not
  /// contain data that needs to be freed.
  int av_read_frame(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_read_frame(
      s,
      pkt,
    );
  }

  late final _av_read_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVPacket>)>>('av_read_frame');
  late final _av_read_frame = _av_read_framePtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>, ffi.Pointer<AVPacket>)>();

  /// Seek to the keyframe at timestamp.
  /// 'timestamp' in 'stream_index'.
  ///
  /// @param s            media file handle
  /// @param stream_index If stream_index is (-1), a default stream is selected,
  /// and timestamp is automatically converted from
  /// AV_TIME_BASE units to the stream specific time_base.
  /// @param timestamp    Timestamp in AVStream.time_base units or, if no stream
  /// is specified, in AV_TIME_BASE units.
  /// @param flags        flags which select direction and seeking mode
  ///
  /// @return >= 0 on success
  int av_seek_frame(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    int timestamp,
    int flags,
  ) {
    return _av_seek_frame(
      s,
      stream_index,
      timestamp,
      flags,
    );
  }

  late final _av_seek_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>, ffi.Int, ffi.Int64,
              ffi.Int)>>('av_seek_frame');
  late final _av_seek_frame = _av_seek_framePtr
      .asFunction<int Function(ffi.Pointer<AVFormatContext>, int, int, int)>();

  /// Seek to timestamp ts.
  /// Seeking will be done so that the point from which all active streams
  /// can be presented successfully will be closest to ts and within min/max_ts.
  /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
  ///
  /// If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
  /// are the file position (this may not be supported by all demuxers).
  /// If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
  /// in the stream with stream_index (this may not be supported by all demuxers).
  /// Otherwise all timestamps are in units of the stream selected by stream_index
  /// or if stream_index is -1, in AV_TIME_BASE units.
  /// If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
  /// keyframes (this may not be supported by all demuxers).
  /// If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
  ///
  /// @param s            media file handle
  /// @param stream_index index of the stream which is used as time base reference
  /// @param min_ts       smallest acceptable timestamp
  /// @param ts           target timestamp
  /// @param max_ts       largest acceptable timestamp
  /// @param flags        flags
  /// @return >=0 on success, error code otherwise
  ///
  /// @note This is part of the new seek API which is still under construction.
  int avformat_seek_file(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    int min_ts,
    int ts,
    int max_ts,
    int flags,
  ) {
    return _avformat_seek_file(
      s,
      stream_index,
      min_ts,
      ts,
      max_ts,
      flags,
    );
  }

  late final _avformat_seek_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>, ffi.Int, ffi.Int64,
              ffi.Int64, ffi.Int64, ffi.Int)>>('avformat_seek_file');
  late final _avformat_seek_file = _avformat_seek_filePtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>, int, int, int, int, int)>();

  /// Discard all internally buffered data. This can be useful when dealing with
  /// discontinuities in the byte stream. Generally works only with formats that
  /// can resync. This includes headerless formats like MPEG-TS/TS but should also
  /// work with NUT, Ogg and in a limited way AVI for example.
  ///
  /// The set of streams, the detected duration, stream parameters and codecs do
  /// not change when calling this function. If you want a complete reset, it's
  /// better to open a new AVFormatContext.
  ///
  /// This does not flush the AVIOContext (s->pb). If necessary, call
  /// avio_flush(s->pb) before calling this function.
  ///
  /// @param s media file handle
  /// @return >=0 on success, error code otherwise
  int avformat_flush(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _avformat_flush(
      s,
    );
  }

  late final _avformat_flushPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFormatContext>)>>(
      'avformat_flush');
  late final _avformat_flush = _avformat_flushPtr
      .asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// Start playing a network-based stream (e.g. RTSP stream) at the
  /// current position.
  int av_read_play(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _av_read_play(
      s,
    );
  }

  late final _av_read_playPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFormatContext>)>>(
      'av_read_play');
  late final _av_read_play =
      _av_read_playPtr.asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// Pause a network-based stream (e.g. RTSP stream).
  ///
  /// Use av_read_play() to resume it.
  int av_read_pause(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _av_read_pause(
      s,
    );
  }

  late final _av_read_pausePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFormatContext>)>>(
      'av_read_pause');
  late final _av_read_pause = _av_read_pausePtr
      .asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// Close an opened input AVFormatContext. Free it and all its contents
  /// and set *s to NULL.
  void avformat_close_input(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> s,
  ) {
    return _avformat_close_input(
      s,
    );
  }

  late final _avformat_close_inputPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVFormatContext>>)>>(
      'avformat_close_input');
  late final _avformat_close_input = _avformat_close_inputPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVFormatContext>>)>();

  /// Allocate the stream private data and write the stream header to
  /// an output media file.
  ///
  /// @param s        Media file handle, must be allocated with
  /// avformat_alloc_context().
  /// Its \ref AVFormatContext.oformat "oformat" field must be set
  /// to the desired output format;
  /// Its \ref AVFormatContext.pb "pb" field must be set to an
  /// already opened ::AVIOContext.
  /// @param options  An ::AVDictionary filled with AVFormatContext and
  /// muxer-private options.
  /// On return this parameter will be destroyed and replaced with
  /// a dict containing options that were not found. May be NULL.
  ///
  /// @retval AVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec had not already been
  /// fully initialized in avformat_init_output().
  /// @retval AVSTREAM_INIT_IN_INIT_OUTPUT  On success, if the codec had already been fully
  /// initialized in avformat_init_output().
  /// @retval AVERROR                       A negative AVERROR on failure.
  ///
  /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
  int avformat_write_header(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avformat_write_header(
      s,
      options,
    );
  }

  late final _avformat_write_headerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<AVFormatContext>,
                  ffi.Pointer<ffi.Pointer<AVDictionary>>)>>(
      'avformat_write_header');
  late final _avformat_write_header = _avformat_write_headerPtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Allocate the stream private data and initialize the codec, but do not write the header.
  /// May optionally be used before avformat_write_header() to initialize stream parameters
  /// before actually writing the header.
  /// If using this function, do not pass the same options to avformat_write_header().
  ///
  /// @param s        Media file handle, must be allocated with
  /// avformat_alloc_context().
  /// Its \ref AVFormatContext.oformat "oformat" field must be set
  /// to the desired output format;
  /// Its \ref AVFormatContext.pb "pb" field must be set to an
  /// already opened ::AVIOContext.
  /// @param options  An ::AVDictionary filled with AVFormatContext and
  /// muxer-private options.
  /// On return this parameter will be destroyed and replaced with
  /// a dict containing options that were not found. May be NULL.
  ///
  /// @retval AVSTREAM_INIT_IN_WRITE_HEADER On success, if the codec requires
  /// avformat_write_header to fully initialize.
  /// @retval AVSTREAM_INIT_IN_INIT_OUTPUT  On success, if the codec has been fully
  /// initialized.
  /// @retval AVERROR                       Anegative AVERROR on failure.
  ///
  /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
  int avformat_init_output(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avformat_init_output(
      s,
      options,
    );
  }

  late final _avformat_init_outputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('avformat_init_output');
  late final _avformat_init_output = _avformat_init_outputPtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Write a packet to an output media file.
  ///
  /// This function passes the packet directly to the muxer, without any buffering
  /// or reordering. The caller is responsible for correctly interleaving the
  /// packets if the format requires it. Callers that want libavformat to handle
  /// the interleaving should call av_interleaved_write_frame() instead of this
  /// function.
  ///
  /// @param s media file handle
  /// @param pkt The packet containing the data to be written. Note that unlike
  /// av_interleaved_write_frame(), this function does not take
  /// ownership of the packet passed to it (though some muxers may make
  /// an internal reference to the input packet).
  /// <br>
  /// This parameter can be NULL (at any time, not just at the end), in
  /// order to immediately flush data buffered within the muxer, for
  /// muxers that buffer up data internally before writing it to the
  /// output.
  /// <br>
  /// Packet's @ref AVPacket.stream_index "stream_index" field must be
  /// set to the index of the corresponding stream in @ref
  /// AVFormatContext.streams "s->streams".
  /// <br>
  /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
  /// must be set to correct values in the stream's timebase (unless the
  /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
  /// they can be set to AV_NOPTS_VALUE).
  /// The dts for subsequent packets passed to this function must be strictly
  /// increasing when compared in their respective timebases (unless the
  /// output format is flagged with the AVFMT_TS_NONSTRICT, then they
  /// merely have to be nondecreasing).  @ref AVPacket.duration
  /// "duration") should also be set if known.
  /// @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
  ///
  /// @see av_interleaved_write_frame()
  int av_write_frame(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_write_frame(
      s,
      pkt,
    );
  }

  late final _av_write_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVPacket>)>>('av_write_frame');
  late final _av_write_frame = _av_write_framePtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>, ffi.Pointer<AVPacket>)>();

  /// Write a packet to an output media file ensuring correct interleaving.
  ///
  /// This function will buffer the packets internally as needed to make sure the
  /// packets in the output file are properly interleaved, usually ordered by
  /// increasing dts. Callers doing their own interleaving should call
  /// av_write_frame() instead of this function.
  ///
  /// Using this function instead of av_write_frame() can give muxers advance
  /// knowledge of future packets, improving e.g. the behaviour of the mp4
  /// muxer for VFR content in fragmenting mode.
  ///
  /// @param s media file handle
  /// @param pkt The packet containing the data to be written.
  /// <br>
  /// If the packet is reference-counted, this function will take
  /// ownership of this reference and unreference it later when it sees
  /// fit. If the packet is not reference-counted, libavformat will
  /// make a copy.
  /// The returned packet will be blank (as if returned from
  /// av_packet_alloc()), even on error.
  /// <br>
  /// This parameter can be NULL (at any time, not just at the end), to
  /// flush the interleaving queues.
  /// <br>
  /// Packet's @ref AVPacket.stream_index "stream_index" field must be
  /// set to the index of the corresponding stream in @ref
  /// AVFormatContext.streams "s->streams".
  /// <br>
  /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
  /// must be set to correct values in the stream's timebase (unless the
  /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
  /// they can be set to AV_NOPTS_VALUE).
  /// The dts for subsequent packets in one stream must be strictly
  /// increasing (unless the output format is flagged with the
  /// AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).
  /// @ref AVPacket.duration "duration" should also be set if known.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  ///
  /// @see av_write_frame(), AVFormatContext.max_interleave_delta
  int av_interleaved_write_frame(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVPacket> pkt,
  ) {
    return _av_interleaved_write_frame(
      s,
      pkt,
    );
  }

  late final _av_interleaved_write_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVPacket>)>>('av_interleaved_write_frame');
  late final _av_interleaved_write_frame =
      _av_interleaved_write_framePtr.asFunction<
          int Function(ffi.Pointer<AVFormatContext>, ffi.Pointer<AVPacket>)>();

  /// Write an uncoded frame to an output media file.
  ///
  /// The frame must be correctly interleaved according to the container
  /// specification; if not, av_interleaved_write_uncoded_frame() must be used.
  ///
  /// See av_interleaved_write_uncoded_frame() for details.
  int av_write_uncoded_frame(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_write_uncoded_frame(
      s,
      stream_index,
      frame,
    );
  }

  late final _av_write_uncoded_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>, ffi.Int,
              ffi.Pointer<AVFrame>)>>('av_write_uncoded_frame');
  late final _av_write_uncoded_frame = _av_write_uncoded_framePtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>, int, ffi.Pointer<AVFrame>)>();

  /// Write an uncoded frame to an output media file.
  ///
  /// If the muxer supports it, this function makes it possible to write an AVFrame
  /// structure directly, without encoding it into a packet.
  /// It is mostly useful for devices and similar special muxers that use raw
  /// video or PCM data and will not serialize it into a byte stream.
  ///
  /// To test whether it is possible to use it with a given muxer and stream,
  /// use av_write_uncoded_frame_query().
  ///
  /// The caller gives up ownership of the frame and must not access it
  /// afterwards.
  ///
  /// @return  >=0 for success, a negative code on error
  int av_interleaved_write_uncoded_frame(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_interleaved_write_uncoded_frame(
      s,
      stream_index,
      frame,
    );
  }

  late final _av_interleaved_write_uncoded_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>, ffi.Int,
              ffi.Pointer<AVFrame>)>>('av_interleaved_write_uncoded_frame');
  late final _av_interleaved_write_uncoded_frame =
      _av_interleaved_write_uncoded_framePtr.asFunction<
          int Function(
              ffi.Pointer<AVFormatContext>, int, ffi.Pointer<AVFrame>)>();

  /// Test whether a muxer supports uncoded frame.
  ///
  /// @return  >=0 if an uncoded frame can be written to that muxer and stream,
  /// <0 if not
  int av_write_uncoded_frame_query(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
  ) {
    return _av_write_uncoded_frame_query(
      s,
      stream_index,
    );
  }

  late final _av_write_uncoded_frame_queryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>,
              ffi.Int)>>('av_write_uncoded_frame_query');
  late final _av_write_uncoded_frame_query = _av_write_uncoded_frame_queryPtr
      .asFunction<int Function(ffi.Pointer<AVFormatContext>, int)>();

  /// Write the stream trailer to an output media file and free the
  /// file private data.
  ///
  /// May only be called after a successful call to avformat_write_header.
  ///
  /// @param s media file handle
  /// @return 0 if OK, AVERROR_xxx on error
  int av_write_trailer(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _av_write_trailer(
      s,
    );
  }

  late final _av_write_trailerPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFormatContext>)>>(
      'av_write_trailer');
  late final _av_write_trailer = _av_write_trailerPtr
      .asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// Return the output format in the list of registered output formats
  /// which best matches the provided parameters, or return NULL if
  /// there is no match.
  ///
  /// @param short_name if non-NULL checks if short_name matches with the
  /// names of the registered formats
  /// @param filename   if non-NULL checks if filename terminates with the
  /// extensions of the registered formats
  /// @param mime_type  if non-NULL checks if mime_type matches with the
  /// MIME type of the registered formats
  ffi.Pointer<AVOutputFormat> av_guess_format(
    ffi.Pointer<ffi.Char> short_name,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Char> mime_type,
  ) {
    return _av_guess_format(
      short_name,
      filename,
      mime_type,
    );
  }

  late final _av_guess_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOutputFormat> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('av_guess_format');
  late final _av_guess_format = _av_guess_formatPtr.asFunction<
      ffi.Pointer<AVOutputFormat> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Guess the codec ID based upon muxer and filename.
  AVCodecID av_guess_codec(
    ffi.Pointer<AVOutputFormat> fmt,
    ffi.Pointer<ffi.Char> short_name,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Char> mime_type,
    AVMediaType type,
  ) {
    return AVCodecID.fromValue(_av_guess_codec(
      fmt,
      short_name,
      filename,
      mime_type,
      type.value,
    ));
  }

  late final _av_guess_codecPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<AVOutputFormat>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_guess_codec');
  late final _av_guess_codec = _av_guess_codecPtr.asFunction<
      int Function(ffi.Pointer<AVOutputFormat>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Get timing information for the data currently output.
  /// The exact meaning of "currently output" depends on the format.
  /// It is mostly relevant for devices that have an internal buffer and/or
  /// work in real time.
  /// @param s          media file handle
  /// @param stream     stream in the media file
  /// @param[out] dts   DTS of the last packet output for the stream, in stream
  /// time_base units
  /// @param[out] wall  absolute time when that packet whas output,
  /// in microsecond
  /// @retval  0               Success
  /// @retval  AVERROR(ENOSYS) The format does not support it
  ///
  /// @note Some formats or devices may not allow to measure dts and wall
  /// atomically.
  int av_get_output_timestamp(
    ffi.Pointer<AVFormatContext> s,
    int stream,
    ffi.Pointer<ffi.Int64> dts,
    ffi.Pointer<ffi.Int64> wall,
  ) {
    return _av_get_output_timestamp(
      s,
      stream,
      dts,
      wall,
    );
  }

  late final _av_get_output_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFormatContext>,
              ffi.Int,
              ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Int64>)>>('av_get_output_timestamp');
  late final _av_get_output_timestamp = _av_get_output_timestampPtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>, int, ffi.Pointer<ffi.Int64>,
          ffi.Pointer<ffi.Int64>)>();

  /// Send a nice hexadecimal dump of a buffer to the specified file stream.
  ///
  /// @param f The file stream pointer where the dump should be sent to.
  /// @param buf buffer
  /// @param size buffer size
  ///
  /// @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
  void av_hex_dump(
    ffi.Pointer<FILE> f,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    return _av_hex_dump(
      f,
      buf,
      size,
    );
  }

  late final _av_hex_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_hex_dump');
  late final _av_hex_dump = _av_hex_dumpPtr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Send a nice hexadecimal dump of a buffer to the log.
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message, lower values signifying
  /// higher importance.
  /// @param buf buffer
  /// @param size buffer size
  ///
  /// @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
  void av_hex_dump_log(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    return _av_hex_dump_log(
      avcl,
      level,
      buf,
      size,
    );
  }

  late final _av_hex_dump_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('av_hex_dump_log');
  late final _av_hex_dump_log = _av_hex_dump_logPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Send a nice dump of a packet to the specified file stream.
  ///
  /// @param f The file stream pointer where the dump should be sent to.
  /// @param pkt packet to dump
  /// @param dump_payload True if the payload must be displayed, too.
  /// @param st AVStream that the packet belongs to
  void av_pkt_dump2(
    ffi.Pointer<FILE> f,
    ffi.Pointer<AVPacket> pkt,
    int dump_payload,
    ffi.Pointer<AVStream> st,
  ) {
    return _av_pkt_dump2(
      f,
      pkt,
      dump_payload,
      st,
    );
  }

  late final _av_pkt_dump2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<AVPacket>, ffi.Int,
              ffi.Pointer<AVStream>)>>('av_pkt_dump2');
  late final _av_pkt_dump2 = _av_pkt_dump2Ptr.asFunction<
      void Function(ffi.Pointer<FILE>, ffi.Pointer<AVPacket>, int,
          ffi.Pointer<AVStream>)>();

  /// Send a nice dump of a packet to the log.
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message, lower values signifying
  /// higher importance.
  /// @param pkt packet to dump
  /// @param dump_payload True if the payload must be displayed, too.
  /// @param st AVStream that the packet belongs to
  void av_pkt_dump_log2(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<AVPacket> pkt,
    int dump_payload,
    ffi.Pointer<AVStream> st,
  ) {
    return _av_pkt_dump_log2(
      avcl,
      level,
      pkt,
      dump_payload,
      st,
    );
  }

  late final _av_pkt_dump_log2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<AVPacket>,
              ffi.Int,
              ffi.Pointer<AVStream>)>>('av_pkt_dump_log2');
  late final _av_pkt_dump_log2 = _av_pkt_dump_log2Ptr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<AVPacket>, int,
          ffi.Pointer<AVStream>)>();

  /// Get the AVCodecID for the given codec tag tag.
  /// If no codec id is found returns AV_CODEC_ID_NONE.
  ///
  /// @param tags list of supported codec_id-codec_tag pairs, as stored
  /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
  /// @param tag  codec tag to match to a codec ID
  AVCodecID av_codec_get_id(
    ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
    int tag,
  ) {
    return AVCodecID.fromValue(_av_codec_get_id(
      tags,
      tag,
    ));
  }

  late final _av_codec_get_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ffi.Pointer<AVCodecTag>>,
              ffi.UnsignedInt)>>('av_codec_get_id');
  late final _av_codec_get_id = _av_codec_get_idPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVCodecTag>>, int)>();

  /// Get the codec tag for the given codec id id.
  /// If no codec tag is found returns 0.
  ///
  /// @param tags list of supported codec_id-codec_tag pairs, as stored
  /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
  /// @param id   codec ID to match to a codec tag
  int av_codec_get_tag(
    ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
    AVCodecID id,
  ) {
    return _av_codec_get_tag(
      tags,
      id.value,
    );
  }

  late final _av_codec_get_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<ffi.Pointer<AVCodecTag>>,
              ffi.UnsignedInt)>>('av_codec_get_tag');
  late final _av_codec_get_tag = _av_codec_get_tagPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<AVCodecTag>>, int)>();

  /// Get the codec tag for the given codec id.
  ///
  /// @param tags list of supported codec_id - codec_tag pairs, as stored
  /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
  /// @param id codec id that should be searched for in the list
  /// @param tag A pointer to the found tag
  /// @return 0 if id was not found in tags, > 0 if it was found
  int av_codec_get_tag2(
    ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
    AVCodecID id,
    ffi.Pointer<ffi.UnsignedInt> tag,
  ) {
    return _av_codec_get_tag2(
      tags,
      id.value,
      tag,
    );
  }

  late final _av_codec_get_tag2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVCodecTag>>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.UnsignedInt>)>>('av_codec_get_tag2');
  late final _av_codec_get_tag2 = _av_codec_get_tag2Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVCodecTag>>, int,
          ffi.Pointer<ffi.UnsignedInt>)>();

  int av_find_default_stream_index(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _av_find_default_stream_index(
      s,
    );
  }

  late final _av_find_default_stream_indexPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFormatContext>)>>(
      'av_find_default_stream_index');
  late final _av_find_default_stream_index = _av_find_default_stream_indexPtr
      .asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// Get the index for a specific timestamp.
  ///
  /// @param st        stream that the timestamp belongs to
  /// @param timestamp timestamp to retrieve the index for
  /// @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
  /// to the timestamp which is <= the requested one, if backward
  /// is 0, then it will be >=
  /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
  /// @return < 0 if no such timestamp could be found
  int av_index_search_timestamp(
    ffi.Pointer<AVStream> st,
    int timestamp,
    int flags,
  ) {
    return _av_index_search_timestamp(
      st,
      timestamp,
      flags,
    );
  }

  late final _av_index_search_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVStream>, ffi.Int64,
              ffi.Int)>>('av_index_search_timestamp');
  late final _av_index_search_timestamp = _av_index_search_timestampPtr
      .asFunction<int Function(ffi.Pointer<AVStream>, int, int)>();

  /// Get the index entry count for the given AVStream.
  ///
  /// @param st stream
  /// @return the number of index entries in the stream
  int avformat_index_get_entries_count(
    ffi.Pointer<AVStream> st,
  ) {
    return _avformat_index_get_entries_count(
      st,
    );
  }

  late final _avformat_index_get_entries_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVStream>)>>(
          'avformat_index_get_entries_count');
  late final _avformat_index_get_entries_count =
      _avformat_index_get_entries_countPtr
          .asFunction<int Function(ffi.Pointer<AVStream>)>();

  /// Get the AVIndexEntry corresponding to the given index.
  ///
  /// @param st          Stream containing the requested AVIndexEntry.
  /// @param idx         The desired index.
  /// @return A pointer to the requested AVIndexEntry if it exists, NULL otherwise.
  ///
  /// @note The pointer returned by this function is only guaranteed to be valid
  /// until any function that takes the stream or the parent AVFormatContext
  /// as input argument is called.
  ffi.Pointer<AVIndexEntry> avformat_index_get_entry(
    ffi.Pointer<AVStream> st,
    int idx,
  ) {
    return _avformat_index_get_entry(
      st,
      idx,
    );
  }

  late final _avformat_index_get_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVIndexEntry> Function(
              ffi.Pointer<AVStream>, ffi.Int)>>('avformat_index_get_entry');
  late final _avformat_index_get_entry =
      _avformat_index_get_entryPtr.asFunction<
          ffi.Pointer<AVIndexEntry> Function(ffi.Pointer<AVStream>, int)>();

  /// Get the AVIndexEntry corresponding to the given timestamp.
  ///
  /// @param st          Stream containing the requested AVIndexEntry.
  /// @param wanted_timestamp   Timestamp to retrieve the index entry for.
  /// @param flags       If AVSEEK_FLAG_BACKWARD then the returned entry will correspond
  /// to the timestamp which is <= the requested one, if backward
  /// is 0, then it will be >=
  /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise.
  /// @return A pointer to the requested AVIndexEntry if it exists, NULL otherwise.
  ///
  /// @note The pointer returned by this function is only guaranteed to be valid
  /// until any function that takes the stream or the parent AVFormatContext
  /// as input argument is called.
  ffi.Pointer<AVIndexEntry> avformat_index_get_entry_from_timestamp(
    ffi.Pointer<AVStream> st,
    int wanted_timestamp,
    int flags,
  ) {
    return _avformat_index_get_entry_from_timestamp(
      st,
      wanted_timestamp,
      flags,
    );
  }

  late final _avformat_index_get_entry_from_timestampPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVIndexEntry> Function(ffi.Pointer<AVStream>, ffi.Int64,
              ffi.Int)>>('avformat_index_get_entry_from_timestamp');
  late final _avformat_index_get_entry_from_timestamp =
      _avformat_index_get_entry_from_timestampPtr.asFunction<
          ffi.Pointer<AVIndexEntry> Function(
              ffi.Pointer<AVStream>, int, int)>();

  /// Add an index entry into a sorted list. Update the entry if the list
  /// already contains it.
  ///
  /// @param timestamp timestamp in the time base of the given stream
  int av_add_index_entry(
    ffi.Pointer<AVStream> st,
    int pos,
    int timestamp,
    int size,
    int distance,
    int flags,
  ) {
    return _av_add_index_entry(
      st,
      pos,
      timestamp,
      size,
      distance,
      flags,
    );
  }

  late final _av_add_index_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVStream>, ffi.Int64, ffi.Int64, ffi.Int,
              ffi.Int, ffi.Int)>>('av_add_index_entry');
  late final _av_add_index_entry = _av_add_index_entryPtr.asFunction<
      int Function(ffi.Pointer<AVStream>, int, int, int, int, int)>();

  /// Split a URL string into components.
  ///
  /// The pointers to buffers for storing individual components may be null,
  /// in order to ignore that component. Buffers for components not found are
  /// set to empty strings. If the port is not found, it is set to a negative
  /// value.
  ///
  /// @param proto the buffer for the protocol
  /// @param proto_size the size of the proto buffer
  /// @param authorization the buffer for the authorization
  /// @param authorization_size the size of the authorization buffer
  /// @param hostname the buffer for the host name
  /// @param hostname_size the size of the hostname buffer
  /// @param port_ptr a pointer to store the port number in
  /// @param path the buffer for the path
  /// @param path_size the size of the path buffer
  /// @param url the URL to split
  void av_url_split(
    ffi.Pointer<ffi.Char> proto,
    int proto_size,
    ffi.Pointer<ffi.Char> authorization,
    int authorization_size,
    ffi.Pointer<ffi.Char> hostname,
    int hostname_size,
    ffi.Pointer<ffi.Int> port_ptr,
    ffi.Pointer<ffi.Char> path,
    int path_size,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _av_url_split(
      proto,
      proto_size,
      authorization,
      authorization_size,
      hostname,
      hostname_size,
      port_ptr,
      path,
      path_size,
      url,
    );
  }

  late final _av_url_splitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('av_url_split');
  late final _av_url_split = _av_url_splitPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>)>();

  /// Print detailed information about the input or output format, such as
  /// duration, bitrate, streams, container, programs, metadata, side data,
  /// codec and time base.
  ///
  /// @param ic        the context to analyze
  /// @param index     index of the stream to dump information about
  /// @param url       the URL to print, such as source or destination file
  /// @param is_output Select whether the specified context is an input(0) or output(1)
  void av_dump_format(
    ffi.Pointer<AVFormatContext> ic,
    int index,
    ffi.Pointer<ffi.Char> url,
    int is_output,
  ) {
    return _av_dump_format(
      ic,
      index,
      url,
      is_output,
    );
  }

  late final _av_dump_formatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVFormatContext>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('av_dump_format');
  late final _av_dump_format = _av_dump_formatPtr.asFunction<
      void Function(
          ffi.Pointer<AVFormatContext>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Return in 'buf' the path with '%d' replaced by a number.
  ///
  /// Also handles the '%0nd' format where 'n' is the total number
  /// of digits and '%%'.
  ///
  /// @param buf destination buffer
  /// @param buf_size destination buffer size
  /// @param path numbered sequence string
  /// @param number frame number
  /// @param flags AV_FRAME_FILENAME_FLAGS_*
  /// @return 0 if OK, -1 on format error
  int av_get_frame_filename2(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    ffi.Pointer<ffi.Char> path,
    int number,
    int flags,
  ) {
    return _av_get_frame_filename2(
      buf,
      buf_size,
      path,
      number,
      flags,
    );
  }

  late final _av_get_frame_filename2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('av_get_frame_filename2');
  late final _av_get_frame_filename2 = _av_get_frame_filename2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int, int)>();

  int av_get_frame_filename(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    ffi.Pointer<ffi.Char> path,
    int number,
  ) {
    return _av_get_frame_filename(
      buf,
      buf_size,
      path,
      number,
    );
  }

  late final _av_get_frame_filenamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('av_get_frame_filename');
  late final _av_get_frame_filename = _av_get_frame_filenamePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Check whether filename actually is a numbered sequence generator.
  ///
  /// @param filename possible numbered sequence string
  /// @return 1 if a valid numbered sequence string, 0 otherwise
  int av_filename_number_test(
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _av_filename_number_test(
      filename,
    );
  }

  late final _av_filename_number_testPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_filename_number_test');
  late final _av_filename_number_test = _av_filename_number_testPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Generate an SDP for an RTP session.
  ///
  /// Note, this overwrites the id values of AVStreams in the muxer contexts
  /// for getting unique dynamic payload types.
  ///
  /// @param ac array of AVFormatContexts describing the RTP streams. If the
  /// array is composed by only one context, such context can contain
  /// multiple AVStreams (one AVStream per RTP stream). Otherwise,
  /// all the contexts in the array (an AVCodecContext per RTP stream)
  /// must contain only one AVStream.
  /// @param n_files number of AVCodecContexts contained in ac
  /// @param buf buffer where the SDP will be stored (must be allocated by
  /// the caller)
  /// @param size the size of the buffer
  /// @return 0 if OK, AVERROR_xxx on error
  int av_sdp_create(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> ac,
    int n_files,
    ffi.Pointer<ffi.Char> buf,
    int size,
  ) {
    return _av_sdp_create(
      ac,
      n_files,
      buf,
      size,
    );
  }

  late final _av_sdp_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVFormatContext>>, ffi.Int,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('av_sdp_create');
  late final _av_sdp_create = _av_sdp_createPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVFormatContext>>, int,
          ffi.Pointer<ffi.Char>, int)>();

  /// Return a positive value if the given filename has one of the given
  /// extensions, 0 otherwise.
  ///
  /// @param filename   file name to check against the given extensions
  /// @param extensions a comma-separated list of filename extensions
  int av_match_ext(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Char> extensions,
  ) {
    return _av_match_ext(
      filename,
      extensions,
    );
  }

  late final _av_match_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('av_match_ext');
  late final _av_match_ext = _av_match_extPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Test if the given container can store a codec.
  ///
  /// @param ofmt           container to check for compatibility
  /// @param codec_id       codec to potentially store in container
  /// @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
  ///
  /// @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
  /// A negative number if this information is not available.
  int avformat_query_codec(
    ffi.Pointer<AVOutputFormat> ofmt,
    AVCodecID codec_id,
    int std_compliance,
  ) {
    return _avformat_query_codec(
      ofmt,
      codec_id.value,
      std_compliance,
    );
  }

  late final _avformat_query_codecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVOutputFormat>, ffi.UnsignedInt,
              ffi.Int)>>('avformat_query_codec');
  late final _avformat_query_codec = _avformat_query_codecPtr
      .asFunction<int Function(ffi.Pointer<AVOutputFormat>, int, int)>();

  /// @defgroup riff_fourcc RIFF FourCCs
  /// @{
  /// Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
  /// meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
  /// following code:
  /// @code
  /// uint32_t tag = MKTAG('H', '2', '6', '4');
  /// const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
  /// enum AVCodecID id = av_codec_get_id(table, tag);
  /// @endcode
  /// /
  /// /**
  /// @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_riff_video_tags() {
    return _avformat_get_riff_video_tags();
  }

  late final _avformat_get_riff_video_tagsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCodecTag> Function()>>(
          'avformat_get_riff_video_tags');
  late final _avformat_get_riff_video_tags = _avformat_get_riff_video_tagsPtr
      .asFunction<ffi.Pointer<AVCodecTag> Function()>();

  /// @return the table mapping RIFF FourCCs for audio to AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_riff_audio_tags() {
    return _avformat_get_riff_audio_tags();
  }

  late final _avformat_get_riff_audio_tagsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCodecTag> Function()>>(
          'avformat_get_riff_audio_tags');
  late final _avformat_get_riff_audio_tags = _avformat_get_riff_audio_tagsPtr
      .asFunction<ffi.Pointer<AVCodecTag> Function()>();

  /// @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_mov_video_tags() {
    return _avformat_get_mov_video_tags();
  }

  late final _avformat_get_mov_video_tagsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCodecTag> Function()>>(
          'avformat_get_mov_video_tags');
  late final _avformat_get_mov_video_tags = _avformat_get_mov_video_tagsPtr
      .asFunction<ffi.Pointer<AVCodecTag> Function()>();

  /// @return the table mapping MOV FourCCs for audio to AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_mov_audio_tags() {
    return _avformat_get_mov_audio_tags();
  }

  late final _avformat_get_mov_audio_tagsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCodecTag> Function()>>(
          'avformat_get_mov_audio_tags');
  late final _avformat_get_mov_audio_tags = _avformat_get_mov_audio_tagsPtr
      .asFunction<ffi.Pointer<AVCodecTag> Function()>();

  /// Guess the sample aspect ratio of a frame, based on both the stream and the
  /// frame aspect ratio.
  ///
  /// Since the frame aspect ratio is set by the codec but the stream aspect ratio
  /// is set by the demuxer, these two may not be equal. This function tries to
  /// return the value that you should use if you would like to display the frame.
  ///
  /// Basic logic is to use the stream aspect ratio if it is set to something sane
  /// otherwise use the frame aspect ratio. This way a container setting, which is
  /// usually easy to modify can override the coded value in the frames.
  ///
  /// @param format the format context which the stream is part of
  /// @param stream the stream which the frame is part of
  /// @param frame the frame with the aspect ratio to be determined
  /// @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
  AVRational av_guess_sample_aspect_ratio(
    ffi.Pointer<AVFormatContext> format,
    ffi.Pointer<AVStream> stream,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_guess_sample_aspect_ratio(
      format,
      stream,
      frame,
    );
  }

  late final _av_guess_sample_aspect_ratioPtr = _lookup<
      ffi.NativeFunction<
          AVRational Function(
              ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVStream>,
              ffi.Pointer<AVFrame>)>>('av_guess_sample_aspect_ratio');
  late final _av_guess_sample_aspect_ratio =
      _av_guess_sample_aspect_ratioPtr.asFunction<
          AVRational Function(ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVStream>, ffi.Pointer<AVFrame>)>();

  /// Guess the frame rate, based on both the container and codec information.
  ///
  /// @param ctx the format context which the stream is part of
  /// @param stream the stream which the frame is part of
  /// @param frame the frame for which the frame rate should be determined, may be NULL
  /// @return the guessed (valid) frame rate, 0/1 if no idea
  AVRational av_guess_frame_rate(
    ffi.Pointer<AVFormatContext> ctx,
    ffi.Pointer<AVStream> stream,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_guess_frame_rate(
      ctx,
      stream,
      frame,
    );
  }

  late final _av_guess_frame_ratePtr = _lookup<
      ffi.NativeFunction<
          AVRational Function(
              ffi.Pointer<AVFormatContext>,
              ffi.Pointer<AVStream>,
              ffi.Pointer<AVFrame>)>>('av_guess_frame_rate');
  late final _av_guess_frame_rate = _av_guess_frame_ratePtr.asFunction<
      AVRational Function(ffi.Pointer<AVFormatContext>, ffi.Pointer<AVStream>,
          ffi.Pointer<AVFrame>)>();

  /// Check if the stream st contained in s is matched by the stream specifier
  /// spec.
  ///
  /// See the "stream specifiers" chapter in the documentation for the syntax
  /// of spec.
  ///
  /// @return  >0 if st is matched by spec;
  /// 0  if st is not matched by spec;
  /// AVERROR code if spec is invalid
  ///
  /// @note  A stream specifier can match several streams in the format.
  int avformat_match_stream_specifier(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVStream> st,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _avformat_match_stream_specifier(
      s,
      st,
      spec,
    );
  }

  late final _avformat_match_stream_specifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFormatContext>, ffi.Pointer<AVStream>,
              ffi.Pointer<ffi.Char>)>>('avformat_match_stream_specifier');
  late final _avformat_match_stream_specifier =
      _avformat_match_stream_specifierPtr.asFunction<
          int Function(ffi.Pointer<AVFormatContext>, ffi.Pointer<AVStream>,
              ffi.Pointer<ffi.Char>)>();

  int avformat_queue_attached_pictures(
    ffi.Pointer<AVFormatContext> s,
  ) {
    return _avformat_queue_attached_pictures(
      s,
    );
  }

  late final _avformat_queue_attached_picturesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFormatContext>)>>(
      'avformat_queue_attached_pictures');
  late final _avformat_queue_attached_pictures =
      _avformat_queue_attached_picturesPtr
          .asFunction<int Function(ffi.Pointer<AVFormatContext>)>();

  /// @deprecated do not call this function
  int avformat_transfer_internal_stream_timing_info(
    ffi.Pointer<AVOutputFormat> ofmt,
    ffi.Pointer<AVStream> ost,
    ffi.Pointer<AVStream> ist,
    AVTimebaseSource copy_tb,
  ) {
    return _avformat_transfer_internal_stream_timing_info(
      ofmt,
      ost,
      ist,
      copy_tb.value,
    );
  }

  late final _avformat_transfer_internal_stream_timing_infoPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVOutputFormat>,
              ffi.Pointer<AVStream>,
              ffi.Pointer<AVStream>,
              ffi.Int)>>('avformat_transfer_internal_stream_timing_info');
  late final _avformat_transfer_internal_stream_timing_info =
      _avformat_transfer_internal_stream_timing_infoPtr.asFunction<
          int Function(ffi.Pointer<AVOutputFormat>, ffi.Pointer<AVStream>,
              ffi.Pointer<AVStream>, int)>();

  /// @deprecated do not call this function
  AVRational av_stream_get_codec_timebase(
    ffi.Pointer<AVStream> st,
  ) {
    return _av_stream_get_codec_timebase(
      st,
    );
  }

  late final _av_stream_get_codec_timebasePtr =
      _lookup<ffi.NativeFunction<AVRational Function(ffi.Pointer<AVStream>)>>(
          'av_stream_get_codec_timebase');
  late final _av_stream_get_codec_timebase = _av_stream_get_codec_timebasePtr
      .asFunction<AVRational Function(ffi.Pointer<AVStream>)>();

  /// Return the LIBAVDEVICE_VERSION_INT constant.
  int avdevice_version() {
    return _avdevice_version();
  }

  late final _avdevice_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'avdevice_version');
  late final _avdevice_version =
      _avdevice_versionPtr.asFunction<int Function()>();

  /// Return the libavdevice build-time configuration.
  ffi.Pointer<ffi.Char> avdevice_configuration() {
    return _avdevice_configuration();
  }

  late final _avdevice_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avdevice_configuration');
  late final _avdevice_configuration =
      _avdevice_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libavdevice license.
  ffi.Pointer<ffi.Char> avdevice_license() {
    return _avdevice_license();
  }

  late final _avdevice_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avdevice_license');
  late final _avdevice_license =
      _avdevice_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Initialize libavdevice and register all the input and output devices.
  void avdevice_register_all() {
    return _avdevice_register_all();
  }

  late final _avdevice_register_allPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('avdevice_register_all');
  late final _avdevice_register_all =
      _avdevice_register_allPtr.asFunction<void Function()>();

  /// Audio input devices iterator.
  ///
  /// If d is NULL, returns the first registered input audio/video device,
  /// if d is non-NULL, returns the next registered input audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVInputFormat> av_input_audio_device_next(
    ffi.Pointer<AVInputFormat> d,
  ) {
    return _av_input_audio_device_next(
      d,
    );
  }

  late final _av_input_audio_device_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(
              ffi.Pointer<AVInputFormat>)>>('av_input_audio_device_next');
  late final _av_input_audio_device_next =
      _av_input_audio_device_nextPtr.asFunction<
          ffi.Pointer<AVInputFormat> Function(ffi.Pointer<AVInputFormat>)>();

  /// Video input devices iterator.
  ///
  /// If d is NULL, returns the first registered input audio/video device,
  /// if d is non-NULL, returns the next registered input audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVInputFormat> av_input_video_device_next(
    ffi.Pointer<AVInputFormat> d,
  ) {
    return _av_input_video_device_next(
      d,
    );
  }

  late final _av_input_video_device_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVInputFormat> Function(
              ffi.Pointer<AVInputFormat>)>>('av_input_video_device_next');
  late final _av_input_video_device_next =
      _av_input_video_device_nextPtr.asFunction<
          ffi.Pointer<AVInputFormat> Function(ffi.Pointer<AVInputFormat>)>();

  /// Audio output devices iterator.
  ///
  /// If d is NULL, returns the first registered output audio/video device,
  /// if d is non-NULL, returns the next registered output audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVOutputFormat> av_output_audio_device_next(
    ffi.Pointer<AVOutputFormat> d,
  ) {
    return _av_output_audio_device_next(
      d,
    );
  }

  late final _av_output_audio_device_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOutputFormat> Function(
              ffi.Pointer<AVOutputFormat>)>>('av_output_audio_device_next');
  late final _av_output_audio_device_next =
      _av_output_audio_device_nextPtr.asFunction<
          ffi.Pointer<AVOutputFormat> Function(ffi.Pointer<AVOutputFormat>)>();

  /// Video output devices iterator.
  ///
  /// If d is NULL, returns the first registered output audio/video device,
  /// if d is non-NULL, returns the next registered output audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVOutputFormat> av_output_video_device_next(
    ffi.Pointer<AVOutputFormat> d,
  ) {
    return _av_output_video_device_next(
      d,
    );
  }

  late final _av_output_video_device_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVOutputFormat> Function(
              ffi.Pointer<AVOutputFormat>)>>('av_output_video_device_next');
  late final _av_output_video_device_next =
      _av_output_video_device_nextPtr.asFunction<
          ffi.Pointer<AVOutputFormat> Function(ffi.Pointer<AVOutputFormat>)>();

  /// Send control message from application to device.
  ///
  /// @param s         device context.
  /// @param type      message type.
  /// @param data      message data. Exact type depends on message type.
  /// @param data_size size of message data.
  /// @return >= 0 on success, negative on error.
  /// AVERROR(ENOSYS) when device doesn't implement handler of the message.
  int avdevice_app_to_dev_control_message(
    ffi.Pointer<AVFormatContext> s,
    AVAppToDevMessageType type,
    ffi.Pointer<ffi.Void> data,
    int data_size,
  ) {
    return _avdevice_app_to_dev_control_message(
      s,
      type.value,
      data,
      data_size,
    );
  }

  late final _avdevice_app_to_dev_control_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFormatContext>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('avdevice_app_to_dev_control_message');
  late final _avdevice_app_to_dev_control_message =
      _avdevice_app_to_dev_control_messagePtr.asFunction<
          int Function(
              ffi.Pointer<AVFormatContext>, int, ffi.Pointer<ffi.Void>, int)>();

  /// Send control message from device to application.
  ///
  /// @param s         device context.
  /// @param type      message type.
  /// @param data      message data. Can be NULL.
  /// @param data_size size of message data.
  /// @return >= 0 on success, negative on error.
  /// AVERROR(ENOSYS) when application doesn't implement handler of the message.
  int avdevice_dev_to_app_control_message(
    ffi.Pointer<AVFormatContext> s,
    AVDevToAppMessageType type,
    ffi.Pointer<ffi.Void> data,
    int data_size,
  ) {
    return _avdevice_dev_to_app_control_message(
      s,
      type.value,
      data,
      data_size,
    );
  }

  late final _avdevice_dev_to_app_control_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFormatContext>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              ffi.Size)>>('avdevice_dev_to_app_control_message');
  late final _avdevice_dev_to_app_control_message =
      _avdevice_dev_to_app_control_messagePtr.asFunction<
          int Function(
              ffi.Pointer<AVFormatContext>, int, ffi.Pointer<ffi.Void>, int)>();

  /// List devices.
  ///
  /// Returns available device names and their parameters.
  ///
  /// @note: Some devices may accept system-dependent device names that cannot be
  /// autodetected. The list returned by this function cannot be assumed to
  /// be always completed.
  ///
  /// @param s                device context.
  /// @param[out] device_list list of autodetected devices.
  /// @return count of autodetected devices, negative on error.
  int avdevice_list_devices(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    return _avdevice_list_devices(
      s,
      device_list,
    );
  }

  late final _avdevice_list_devicesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<AVFormatContext>,
                  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>>(
      'avdevice_list_devices');
  late final _avdevice_list_devices = _avdevice_list_devicesPtr.asFunction<
      int Function(ffi.Pointer<AVFormatContext>,
          ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>();

  /// Convenient function to free result of avdevice_list_devices().
  ///
  /// @param device_list device list to be freed.
  void avdevice_free_list_devices(
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    return _avdevice_free_list_devices(
      device_list,
    );
  }

  late final _avdevice_free_list_devicesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>>(
      'avdevice_free_list_devices');
  late final _avdevice_free_list_devices = _avdevice_free_list_devicesPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>();

  /// List devices.
  ///
  /// Returns available device names and their parameters.
  /// These are convinient wrappers for avdevice_list_devices().
  /// Device context is allocated and deallocated internally.
  ///
  /// @param device           device format. May be NULL if device name is set.
  /// @param device_name      device name. May be NULL if device format is set.
  /// @param device_options   An AVDictionary filled with device-private options. May be NULL.
  /// The same options must be passed later to avformat_write_header() for output
  /// devices or avformat_open_input() for input devices, or at any other place
  /// that affects device-private options.
  /// @param[out] device_list list of autodetected devices
  /// @return count of autodetected devices, negative on error.
  /// @note device argument takes precedence over device_name when both are set.
  int avdevice_list_input_sources(
    ffi.Pointer<AVInputFormat> device,
    ffi.Pointer<ffi.Char> device_name,
    ffi.Pointer<AVDictionary> device_options,
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    return _avdevice_list_input_sources(
      device,
      device_name,
      device_options,
      device_list,
    );
  }

  late final _avdevice_list_input_sourcesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVInputFormat>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<AVDictionary>,
                  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>>(
      'avdevice_list_input_sources');
  late final _avdevice_list_input_sources =
      _avdevice_list_input_sourcesPtr.asFunction<
          int Function(
              ffi.Pointer<AVInputFormat>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVDictionary>,
              ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>();

  int avdevice_list_output_sinks(
    ffi.Pointer<AVOutputFormat> device,
    ffi.Pointer<ffi.Char> device_name,
    ffi.Pointer<AVDictionary> device_options,
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    return _avdevice_list_output_sinks(
      device,
      device_name,
      device_options,
      device_list,
    );
  }

  late final _avdevice_list_output_sinksPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVOutputFormat>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<AVDictionary>,
                  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>>(
      'avdevice_list_output_sinks');
  late final _avdevice_list_output_sinks =
      _avdevice_list_output_sinksPtr.asFunction<
          int Function(
              ffi.Pointer<AVOutputFormat>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVDictionary>,
              ffi.Pointer<ffi.Pointer<AVDeviceInfoList>>)>();

  /// Return the LIBAVFILTER_VERSION_INT constant.
  int avfilter_version() {
    return _avfilter_version();
  }

  late final _avfilter_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'avfilter_version');
  late final _avfilter_version =
      _avfilter_versionPtr.asFunction<int Function()>();

  /// Return the libavfilter build-time configuration.
  ffi.Pointer<ffi.Char> avfilter_configuration() {
    return _avfilter_configuration();
  }

  late final _avfilter_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avfilter_configuration');
  late final _avfilter_configuration =
      _avfilter_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libavfilter license.
  ffi.Pointer<ffi.Char> avfilter_license() {
    return _avfilter_license();
  }

  late final _avfilter_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'avfilter_license');
  late final _avfilter_license =
      _avfilter_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Get the name of an AVFilterPad.
  ///
  /// @param pads an array of AVFilterPads
  /// @param pad_idx index of the pad in the array; it is the caller's
  /// responsibility to ensure the index is valid
  ///
  /// @return name of the pad_idx'th pad in pads
  ffi.Pointer<ffi.Char> avfilter_pad_get_name(
    ffi.Pointer<AVFilterPad> pads,
    int pad_idx,
  ) {
    return _avfilter_pad_get_name(
      pads,
      pad_idx,
    );
  }

  late final _avfilter_pad_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<AVFilterPad>, ffi.Int)>>('avfilter_pad_get_name');
  late final _avfilter_pad_get_name = _avfilter_pad_get_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<AVFilterPad>, int)>();

  /// Get the type of an AVFilterPad.
  ///
  /// @param pads an array of AVFilterPads
  /// @param pad_idx index of the pad in the array; it is the caller's
  /// responsibility to ensure the index is valid
  ///
  /// @return type of the pad_idx'th pad in pads
  AVMediaType avfilter_pad_get_type(
    ffi.Pointer<AVFilterPad> pads,
    int pad_idx,
  ) {
    return AVMediaType.fromValue(_avfilter_pad_get_type(
      pads,
      pad_idx,
    ));
  }

  late final _avfilter_pad_get_typePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterPad>, ffi.Int)>>(
      'avfilter_pad_get_type');
  late final _avfilter_pad_get_type = _avfilter_pad_get_typePtr
      .asFunction<int Function(ffi.Pointer<AVFilterPad>, int)>();

  /// Get the number of elements in an AVFilter's inputs or outputs array.
  int avfilter_filter_pad_count(
    ffi.Pointer<AVFilter> filter,
    int is_output,
  ) {
    return _avfilter_filter_pad_count(
      filter,
      is_output,
    );
  }

  late final _avfilter_filter_pad_countPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<AVFilter>, ffi.Int)>>('avfilter_filter_pad_count');
  late final _avfilter_filter_pad_count = _avfilter_filter_pad_countPtr
      .asFunction<int Function(ffi.Pointer<AVFilter>, int)>();

  /// Link two filters together.
  ///
  /// @param src    the source filter
  /// @param srcpad index of the output pad on the source filter
  /// @param dst    the destination filter
  /// @param dstpad index of the input pad on the destination filter
  /// @return       zero on success
  int avfilter_link(
    ffi.Pointer<AVFilterContext> src,
    int srcpad,
    ffi.Pointer<AVFilterContext> dst,
    int dstpad,
  ) {
    return _avfilter_link(
      src,
      srcpad,
      dst,
      dstpad,
    );
  }

  late final _avfilter_linkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>, ffi.UnsignedInt,
              ffi.Pointer<AVFilterContext>, ffi.UnsignedInt)>>('avfilter_link');
  late final _avfilter_link = _avfilter_linkPtr.asFunction<
      int Function(ffi.Pointer<AVFilterContext>, int,
          ffi.Pointer<AVFilterContext>, int)>();

  /// @deprecated this function should never be called by users
  void avfilter_link_free(
    ffi.Pointer<ffi.Pointer<AVFilterLink>> link,
  ) {
    return _avfilter_link_free(
      link,
    );
  }

  late final _avfilter_link_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVFilterLink>>)>>('avfilter_link_free');
  late final _avfilter_link_free = _avfilter_link_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVFilterLink>>)>();

  /// @deprecated this function should never be called by users
  int avfilter_config_links(
    ffi.Pointer<AVFilterContext> filter,
  ) {
    return _avfilter_config_links(
      filter,
    );
  }

  late final _avfilter_config_linksPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'avfilter_config_links');
  late final _avfilter_config_links = _avfilter_config_linksPtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  /// Make the filter instance process a command.
  /// It is recommended to use avfilter_graph_send_command().
  int avfilter_process_command(
    ffi.Pointer<AVFilterContext> filter,
    ffi.Pointer<ffi.Char> cmd,
    ffi.Pointer<ffi.Char> arg,
    ffi.Pointer<ffi.Char> res,
    int res_len,
    int flags,
  ) {
    return _avfilter_process_command(
      filter,
      cmd,
      arg,
      res,
      res_len,
      flags,
    );
  }

  late final _avfilter_process_commandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterContext>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('avfilter_process_command');
  late final _avfilter_process_command =
      _avfilter_process_commandPtr.asFunction<
          int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Iterate over all registered filters.
  ///
  /// @param opaque a pointer where libavfilter will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered filter or NULL when the iteration is
  /// finished
  ffi.Pointer<AVFilter> av_filter_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    return _av_filter_iterate(
      opaque,
    );
  }

  late final _av_filter_iteratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilter> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_filter_iterate');
  late final _av_filter_iterate = _av_filter_iteratePtr.asFunction<
      ffi.Pointer<AVFilter> Function(ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Get a filter definition matching the given name.
  ///
  /// @param name the filter name to find
  /// @return     the filter definition, if any matching one is registered.
  /// NULL if none found.
  ffi.Pointer<AVFilter> avfilter_get_by_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avfilter_get_by_name(
      name,
    );
  }

  late final _avfilter_get_by_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilter> Function(
              ffi.Pointer<ffi.Char>)>>('avfilter_get_by_name');
  late final _avfilter_get_by_name = _avfilter_get_by_namePtr
      .asFunction<ffi.Pointer<AVFilter> Function(ffi.Pointer<ffi.Char>)>();

  /// Initialize a filter with the supplied parameters.
  ///
  /// @param ctx  uninitialized filter context to initialize
  /// @param args Options to initialize the filter with. This must be a
  /// ':'-separated list of options in the 'key=value' form.
  /// May be NULL if the options have been set directly using the
  /// AVOptions API or there are no options that need to be set.
  /// @return 0 on success, a negative AVERROR on failure
  int avfilter_init_str(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<ffi.Char> args,
  ) {
    return _avfilter_init_str(
      ctx,
      args,
    );
  }

  late final _avfilter_init_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<ffi.Char>)>>('avfilter_init_str');
  late final _avfilter_init_str = _avfilter_init_strPtr.asFunction<
      int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<ffi.Char>)>();

  /// Initialize a filter with the supplied dictionary of options.
  ///
  /// @param ctx     uninitialized filter context to initialize
  /// @param options An AVDictionary filled with options for this filter. On
  /// return this parameter will be destroyed and replaced with
  /// a dict containing options that were not found. This dictionary
  /// must be freed by the caller.
  /// May be NULL, then this function is equivalent to
  /// avfilter_init_str() with the second parameter set to NULL.
  /// @return 0 on success, a negative AVERROR on failure
  ///
  /// @note This function and avfilter_init_str() do essentially the same thing,
  /// the difference is in manner in which the options are passed. It is up to the
  /// calling code to choose whichever is more preferable. The two functions also
  /// behave differently when some of the provided options are not declared as
  /// supported by the filter. In such a case, avfilter_init_str() will fail, but
  /// this function will leave those extra options in the options AVDictionary and
  /// continue as usual.
  int avfilter_init_dict(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    return _avfilter_init_dict(
      ctx,
      options,
    );
  }

  late final _avfilter_init_dictPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<ffi.Pointer<AVDictionary>>)>>('avfilter_init_dict');
  late final _avfilter_init_dict = _avfilter_init_dictPtr.asFunction<
      int Function(ffi.Pointer<AVFilterContext>,
          ffi.Pointer<ffi.Pointer<AVDictionary>>)>();

  /// Free a filter context. This will also remove the filter from its
  /// filtergraph's list of filters.
  ///
  /// @param filter the filter to free
  void avfilter_free(
    ffi.Pointer<AVFilterContext> filter,
  ) {
    return _avfilter_free(
      filter,
    );
  }

  late final _avfilter_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFilterContext>)>>(
      'avfilter_free');
  late final _avfilter_free = _avfilter_freePtr
      .asFunction<void Function(ffi.Pointer<AVFilterContext>)>();

  /// Insert a filter in the middle of an existing link.
  ///
  /// @param link the link into which the filter should be inserted
  /// @param filt the filter to be inserted
  /// @param filt_srcpad_idx the input pad on the filter to connect
  /// @param filt_dstpad_idx the output pad on the filter to connect
  /// @return     zero on success
  int avfilter_insert_filter(
    ffi.Pointer<AVFilterLink> link,
    ffi.Pointer<AVFilterContext> filt,
    int filt_srcpad_idx,
    int filt_dstpad_idx,
  ) {
    return _avfilter_insert_filter(
      link,
      filt,
      filt_srcpad_idx,
      filt_dstpad_idx,
    );
  }

  late final _avfilter_insert_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterLink>,
              ffi.Pointer<AVFilterContext>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('avfilter_insert_filter');
  late final _avfilter_insert_filter = _avfilter_insert_filterPtr.asFunction<
      int Function(
          ffi.Pointer<AVFilterLink>, ffi.Pointer<AVFilterContext>, int, int)>();

  /// @return AVClass for AVFilterContext.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avfilter_get_class() {
    return _avfilter_get_class();
  }

  late final _avfilter_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'avfilter_get_class');
  late final _avfilter_get_class =
      _avfilter_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Allocate a filter graph.
  ///
  /// @return the allocated filter graph on success or NULL.
  ffi.Pointer<AVFilterGraph> avfilter_graph_alloc() {
    return _avfilter_graph_alloc();
  }

  late final _avfilter_graph_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVFilterGraph> Function()>>(
          'avfilter_graph_alloc');
  late final _avfilter_graph_alloc = _avfilter_graph_allocPtr
      .asFunction<ffi.Pointer<AVFilterGraph> Function()>();

  /// Create a new filter instance in a filter graph.
  ///
  /// @param graph graph in which the new filter will be used
  /// @param filter the filter to create an instance of
  /// @param name Name to give to the new instance (will be copied to
  /// AVFilterContext.name). This may be used by the caller to identify
  /// different filters, libavfilter itself assigns no semantics to
  /// this parameter. May be NULL.
  ///
  /// @return the context of the newly created filter instance (note that it is
  /// also retrievable directly through AVFilterGraph.filters or with
  /// avfilter_graph_get_filter()) on success or NULL on failure.
  ffi.Pointer<AVFilterContext> avfilter_graph_alloc_filter(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<AVFilter> filter,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avfilter_graph_alloc_filter(
      graph,
      filter,
      name,
    );
  }

  late final _avfilter_graph_alloc_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilterContext> Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<AVFilter>,
              ffi.Pointer<ffi.Char>)>>('avfilter_graph_alloc_filter');
  late final _avfilter_graph_alloc_filter =
      _avfilter_graph_alloc_filterPtr.asFunction<
          ffi.Pointer<AVFilterContext> Function(ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<AVFilter>, ffi.Pointer<ffi.Char>)>();

  /// Get a filter instance identified by instance name from graph.
  ///
  /// @param graph filter graph to search through.
  /// @param name filter instance name (should be unique in the graph).
  /// @return the pointer to the found filter instance or NULL if it
  /// cannot be found.
  ffi.Pointer<AVFilterContext> avfilter_graph_get_filter(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _avfilter_graph_get_filter(
      graph,
      name,
    );
  }

  late final _avfilter_graph_get_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilterContext> Function(ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>)>>('avfilter_graph_get_filter');
  late final _avfilter_graph_get_filter =
      _avfilter_graph_get_filterPtr.asFunction<
          ffi.Pointer<AVFilterContext> Function(
              ffi.Pointer<AVFilterGraph>, ffi.Pointer<ffi.Char>)>();

  /// Create and add a filter instance into an existing graph.
  /// The filter instance is created from the filter filt and inited
  /// with the parameter args. opaque is currently ignored.
  ///
  /// In case of success put in *filt_ctx the pointer to the created
  /// filter instance, otherwise set *filt_ctx to NULL.
  ///
  /// @param name the instance name to give to the created filter instance
  /// @param graph_ctx the filter graph
  /// @return a negative AVERROR error code in case of failure, a non
  /// negative value otherwise
  int avfilter_graph_create_filter(
    ffi.Pointer<ffi.Pointer<AVFilterContext>> filt_ctx,
    ffi.Pointer<AVFilter> filt,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> args,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<AVFilterGraph> graph_ctx,
  ) {
    return _avfilter_graph_create_filter(
      filt_ctx,
      filt,
      name,
      args,
      opaque,
      graph_ctx,
    );
  }

  late final _avfilter_graph_create_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVFilterContext>>,
              ffi.Pointer<AVFilter>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVFilterGraph>)>>('avfilter_graph_create_filter');
  late final _avfilter_graph_create_filter =
      _avfilter_graph_create_filterPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<AVFilterContext>>,
              ffi.Pointer<AVFilter>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<AVFilterGraph>)>();

  /// Enable or disable automatic format conversion inside the graph.
  ///
  /// Note that format conversion can still happen inside explicitly inserted
  /// scale and aresample filters.
  ///
  /// @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
  void avfilter_graph_set_auto_convert(
    ffi.Pointer<AVFilterGraph> graph,
    int flags,
  ) {
    return _avfilter_graph_set_auto_convert(
      graph,
      flags,
    );
  }

  late final _avfilter_graph_set_auto_convertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVFilterGraph>,
              ffi.UnsignedInt)>>('avfilter_graph_set_auto_convert');
  late final _avfilter_graph_set_auto_convert =
      _avfilter_graph_set_auto_convertPtr
          .asFunction<void Function(ffi.Pointer<AVFilterGraph>, int)>();

  /// Check validity and configure all the links and formats in the graph.
  ///
  /// @param graphctx the filter graph
  /// @param log_ctx context used for logging
  /// @return >= 0 in case of success, a negative AVERROR code otherwise
  int avfilter_graph_config(
    ffi.Pointer<AVFilterGraph> graphctx,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _avfilter_graph_config(
      graphctx,
      log_ctx,
    );
  }

  late final _avfilter_graph_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Void>)>>('avfilter_graph_config');
  late final _avfilter_graph_config = _avfilter_graph_configPtr.asFunction<
      int Function(ffi.Pointer<AVFilterGraph>, ffi.Pointer<ffi.Void>)>();

  /// Free a graph, destroy its links, and set *graph to NULL.
  /// If *graph is NULL, do nothing.
  void avfilter_graph_free(
    ffi.Pointer<ffi.Pointer<AVFilterGraph>> graph,
  ) {
    return _avfilter_graph_free(
      graph,
    );
  }

  late final _avfilter_graph_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVFilterGraph>>)>>('avfilter_graph_free');
  late final _avfilter_graph_free = _avfilter_graph_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVFilterGraph>>)>();

  /// Allocate a single AVFilterInOut entry.
  /// Must be freed with avfilter_inout_free().
  /// @return allocated AVFilterInOut on success, NULL on failure.
  ffi.Pointer<AVFilterInOut> avfilter_inout_alloc() {
    return _avfilter_inout_alloc();
  }

  late final _avfilter_inout_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVFilterInOut> Function()>>(
          'avfilter_inout_alloc');
  late final _avfilter_inout_alloc = _avfilter_inout_allocPtr
      .asFunction<ffi.Pointer<AVFilterInOut> Function()>();

  /// Free the supplied list of AVFilterInOut and set *inout to NULL.
  /// If *inout is NULL, do nothing.
  void avfilter_inout_free(
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inout,
  ) {
    return _avfilter_inout_free(
      inout,
    );
  }

  late final _avfilter_inout_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>>('avfilter_inout_free');
  late final _avfilter_inout_free = _avfilter_inout_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>();

  /// Add a graph described by a string to a graph.
  ///
  /// @note The caller must provide the lists of inputs and outputs,
  /// which therefore must be known before calling the function.
  ///
  /// @note The inputs parameter describes inputs of the already existing
  /// part of the graph; i.e. from the point of view of the newly created
  /// part, they are outputs. Similarly the outputs parameter describes
  /// outputs of the already existing filters, which are provided as
  /// inputs to the parsed filters.
  ///
  /// @param graph   the filter graph where to link the parsed graph context
  /// @param filters string to be parsed
  /// @param inputs  linked list to the inputs of the graph
  /// @param outputs linked list to the outputs of the graph
  /// @return zero on success, a negative AVERROR code on error
  int avfilter_graph_parse(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> filters,
    ffi.Pointer<AVFilterInOut> inputs,
    ffi.Pointer<AVFilterInOut> outputs,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _avfilter_graph_parse(
      graph,
      filters,
      inputs,
      outputs,
      log_ctx,
    );
  }

  late final _avfilter_graph_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<AVFilterInOut>,
              ffi.Pointer<AVFilterInOut>,
              ffi.Pointer<ffi.Void>)>>('avfilter_graph_parse');
  late final _avfilter_graph_parse = _avfilter_graph_parsePtr.asFunction<
      int Function(
          ffi.Pointer<AVFilterGraph>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<AVFilterInOut>,
          ffi.Pointer<AVFilterInOut>,
          ffi.Pointer<ffi.Void>)>();

  /// Add a graph described by a string to a graph.
  ///
  /// In the graph filters description, if the input label of the first
  /// filter is not specified, "in" is assumed; if the output label of
  /// the last filter is not specified, "out" is assumed.
  ///
  /// @param graph   the filter graph where to link the parsed graph context
  /// @param filters string to be parsed
  /// @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.
  /// If non-NULL, *inputs is updated to contain the list of open inputs
  /// after the parsing, should be freed with avfilter_inout_free().
  /// @param outputs pointer to a linked list to the outputs of the graph, may be NULL.
  /// If non-NULL, *outputs is updated to contain the list of open outputs
  /// after the parsing, should be freed with avfilter_inout_free().
  /// @return non negative on success, a negative AVERROR code on error
  int avfilter_graph_parse_ptr(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> filters,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _avfilter_graph_parse_ptr(
      graph,
      filters,
      inputs,
      outputs,
      log_ctx,
    );
  }

  late final _avfilter_graph_parse_ptrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
              ffi.Pointer<ffi.Void>)>>('avfilter_graph_parse_ptr');
  late final _avfilter_graph_parse_ptr =
      _avfilter_graph_parse_ptrPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
              ffi.Pointer<ffi.Void>)>();

  /// Add a graph described by a string to a graph.
  ///
  /// @param[in]  graph   the filter graph where to link the parsed graph context
  /// @param[in]  filters string to be parsed
  /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
  /// parsed graph will be returned here. It is to be freed
  /// by the caller using avfilter_inout_free().
  /// @param[out] outputs a linked list of all free (unlinked) outputs of the
  /// parsed graph will be returned here. It is to be freed by the
  /// caller using avfilter_inout_free().
  /// @return zero on success, a negative AVERROR code on error
  ///
  /// @note This function returns the inputs and outputs that are left
  /// unlinked after parsing the graph and the caller then deals with
  /// them.
  /// @note This function makes no reference whatsoever to already
  /// existing parts of the graph and the inputs parameter will on return
  /// contain inputs of the newly parsed part of the graph.  Analogously
  /// the outputs parameter will contain outputs of the newly created
  /// filters.
  int avfilter_graph_parse2(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> filters,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
  ) {
    return _avfilter_graph_parse2(
      graph,
      filters,
      inputs,
      outputs,
    );
  }

  late final _avfilter_graph_parse2Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVFilterGraph>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
                  ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>>(
      'avfilter_graph_parse2');
  late final _avfilter_graph_parse2 = _avfilter_graph_parse2Ptr.asFunction<
      int Function(
          ffi.Pointer<AVFilterGraph>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
          ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>();

  /// Parse a textual filtergraph description into an intermediate form.
  ///
  /// This intermediate representation is intended to be modified by the caller as
  /// described in the documentation of AVFilterGraphSegment and its children, and
  /// then applied to the graph either manually or with other
  /// avfilter_graph_segment_*() functions. See the documentation for
  /// avfilter_graph_segment_apply() for the canonical way to apply
  /// AVFilterGraphSegment.
  ///
  /// @param graph Filter graph the parsed segment is associated with. Will only be
  /// used for logging and similar auxiliary purposes. The graph will
  /// not be actually modified by this function - the parsing results
  /// are instead stored in seg for further processing.
  /// @param graph_str a string describing the filtergraph segment
  /// @param flags reserved for future use, caller must set to 0 for now
  /// @param seg A pointer to the newly-created AVFilterGraphSegment is written
  /// here on success. The graph segment is owned by the caller and must
  /// be freed with avfilter_graph_segment_free() before graph itself is
  /// freed.
  ///
  /// @retval "non-negative number" success
  /// @retval "negative error code" failure
  int avfilter_graph_segment_parse(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> graph_str,
    int flags,
    ffi.Pointer<ffi.Pointer<AVFilterGraphSegment>> seg,
  ) {
    return _avfilter_graph_segment_parse(
      graph,
      graph_str,
      flags,
      seg,
    );
  }

  late final _avfilter_graph_segment_parsePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVFilterGraph>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<AVFilterGraphSegment>>)>>(
      'avfilter_graph_segment_parse');
  late final _avfilter_graph_segment_parse =
      _avfilter_graph_segment_parsePtr.asFunction<
          int Function(ffi.Pointer<AVFilterGraph>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<ffi.Pointer<AVFilterGraphSegment>>)>();

  /// Create filters specified in a graph segment.
  ///
  /// Walk through the creation-pending AVFilterParams in the segment and create
  /// new filter instances for them.
  /// Creation-pending params are those where AVFilterParams.filter_name is
  /// non-NULL (and hence AVFilterParams.filter is NULL). All other AVFilterParams
  /// instances are ignored.
  ///
  /// For any filter created by this function, the corresponding
  /// AVFilterParams.filter is set to the newly-created filter context,
  /// AVFilterParams.filter_name and AVFilterParams.instance_name are freed and set
  /// to NULL.
  ///
  /// @param seg the filtergraph segment to process
  /// @param flags reserved for future use, caller must set to 0 for now
  ///
  /// @retval "non-negative number" Success, all creation-pending filters were
  /// successfully created
  /// @retval AVERROR_FILTER_NOT_FOUND some filter's name did not correspond to a
  /// known filter
  /// @retval "another negative error code" other failures
  ///
  /// @note Calling this function multiple times is safe, as it is idempotent.
  int avfilter_graph_segment_create_filters(
    ffi.Pointer<AVFilterGraphSegment> seg,
    int flags,
  ) {
    return _avfilter_graph_segment_create_filters(
      seg,
      flags,
    );
  }

  late final _avfilter_graph_segment_create_filtersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterGraphSegment>,
              ffi.Int)>>('avfilter_graph_segment_create_filters');
  late final _avfilter_graph_segment_create_filters =
      _avfilter_graph_segment_create_filtersPtr
          .asFunction<int Function(ffi.Pointer<AVFilterGraphSegment>, int)>();

  /// Apply parsed options to filter instances in a graph segment.
  ///
  /// Walk through all filter instances in the graph segment that have option
  /// dictionaries associated with them and apply those options with
  /// av_opt_set_dict2(..., AV_OPT_SEARCH_CHILDREN). AVFilterParams.opts is
  /// replaced by the dictionary output by av_opt_set_dict2(), which should be
  /// empty (NULL) if all options were successfully applied.
  ///
  /// If any options could not be found, this function will continue processing all
  /// other filters and finally return AVERROR_OPTION_NOT_FOUND (unless another
  /// error happens). The calling program may then deal with unapplied options as
  /// it wishes.
  ///
  /// Any creation-pending filters (see avfilter_graph_segment_create_filters())
  /// present in the segment will cause this function to fail. AVFilterParams with
  /// no associated filter context are simply skipped.
  ///
  /// @param seg the filtergraph segment to process
  /// @param flags reserved for future use, caller must set to 0 for now
  ///
  /// @retval "non-negative number" Success, all options were successfully applied.
  /// @retval AVERROR_OPTION_NOT_FOUND some options were not found in a filter
  /// @retval "another negative error code" other failures
  ///
  /// @note Calling this function multiple times is safe, as it is idempotent.
  int avfilter_graph_segment_apply_opts(
    ffi.Pointer<AVFilterGraphSegment> seg,
    int flags,
  ) {
    return _avfilter_graph_segment_apply_opts(
      seg,
      flags,
    );
  }

  late final _avfilter_graph_segment_apply_optsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterGraphSegment>,
              ffi.Int)>>('avfilter_graph_segment_apply_opts');
  late final _avfilter_graph_segment_apply_opts =
      _avfilter_graph_segment_apply_optsPtr
          .asFunction<int Function(ffi.Pointer<AVFilterGraphSegment>, int)>();

  /// Initialize all filter instances in a graph segment.
  ///
  /// Walk through all filter instances in the graph segment and call
  /// avfilter_init_dict(..., NULL) on those that have not been initialized yet.
  ///
  /// Any creation-pending filters (see avfilter_graph_segment_create_filters())
  /// present in the segment will cause this function to fail. AVFilterParams with
  /// no associated filter context or whose filter context is already initialized,
  /// are simply skipped.
  ///
  /// @param seg the filtergraph segment to process
  /// @param flags reserved for future use, caller must set to 0 for now
  ///
  /// @retval "non-negative number" Success, all filter instances were successfully
  /// initialized
  /// @retval "negative error code" failure
  ///
  /// @note Calling this function multiple times is safe, as it is idempotent.
  int avfilter_graph_segment_init(
    ffi.Pointer<AVFilterGraphSegment> seg,
    int flags,
  ) {
    return _avfilter_graph_segment_init(
      seg,
      flags,
    );
  }

  late final _avfilter_graph_segment_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterGraphSegment>,
              ffi.Int)>>('avfilter_graph_segment_init');
  late final _avfilter_graph_segment_init = _avfilter_graph_segment_initPtr
      .asFunction<int Function(ffi.Pointer<AVFilterGraphSegment>, int)>();

  /// Link filters in a graph segment.
  ///
  /// Walk through all filter instances in the graph segment and try to link all
  /// unlinked input and output pads. Any creation-pending filters (see
  /// avfilter_graph_segment_create_filters()) present in the segment will cause
  /// this function to fail. Disabled filters and already linked pads are skipped.
  ///
  /// Every filter output pad that has a corresponding AVFilterPadParams with a
  /// non-NULL label is
  /// - linked to the input with the matching label, if one exists;
  /// - exported in the outputs linked list otherwise, with the label preserved.
  /// Unlabeled outputs are
  /// - linked to the first unlinked unlabeled input in the next non-disabled
  /// filter in the chain, if one exists
  /// - exported in the ouputs linked list otherwise, with NULL label
  ///
  /// Similarly, unlinked input pads are exported in the inputs linked list.
  ///
  /// @param seg the filtergraph segment to process
  /// @param flags reserved for future use, caller must set to 0 for now
  /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
  /// filters in this graph segment will be returned here. It
  /// is to be freed by the caller using avfilter_inout_free().
  /// @param[out] outputs a linked list of all free (unlinked) outputs of the
  /// filters in this graph segment will be returned here. It
  /// is to be freed by the caller using avfilter_inout_free().
  ///
  /// @retval "non-negative number" success
  /// @retval "negative error code" failure
  ///
  /// @note Calling this function multiple times is safe, as it is idempotent.
  int avfilter_graph_segment_link(
    ffi.Pointer<AVFilterGraphSegment> seg,
    int flags,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
  ) {
    return _avfilter_graph_segment_link(
      seg,
      flags,
      inputs,
      outputs,
    );
  }

  late final _avfilter_graph_segment_linkPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVFilterGraphSegment>,
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
                  ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>>(
      'avfilter_graph_segment_link');
  late final _avfilter_graph_segment_link =
      _avfilter_graph_segment_linkPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterGraphSegment>,
              int,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>();

  /// Apply all filter/link descriptions from a graph segment to the associated filtergraph.
  ///
  /// This functions is currently equivalent to calling the following in sequence:
  /// - avfilter_graph_segment_create_filters();
  /// - avfilter_graph_segment_apply_opts();
  /// - avfilter_graph_segment_init();
  /// - avfilter_graph_segment_link();
  /// failing if any of them fails. This list may be extended in the future.
  ///
  /// Since the above functions are idempotent, the caller may call some of them
  /// manually, then do some custom processing on the filtergraph, then call this
  /// function to do the rest.
  ///
  /// @param seg the filtergraph segment to process
  /// @param flags reserved for future use, caller must set to 0 for now
  /// @param[out] inputs passed to avfilter_graph_segment_link()
  /// @param[out] outputs passed to avfilter_graph_segment_link()
  ///
  /// @retval "non-negative number" success
  /// @retval "negative error code" failure
  ///
  /// @note Calling this function multiple times is safe, as it is idempotent.
  int avfilter_graph_segment_apply(
    ffi.Pointer<AVFilterGraphSegment> seg,
    int flags,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
  ) {
    return _avfilter_graph_segment_apply(
      seg,
      flags,
      inputs,
      outputs,
    );
  }

  late final _avfilter_graph_segment_applyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVFilterGraphSegment>,
                  ffi.Int,
                  ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
                  ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>>(
      'avfilter_graph_segment_apply');
  late final _avfilter_graph_segment_apply =
      _avfilter_graph_segment_applyPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterGraphSegment>,
              int,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>,
              ffi.Pointer<ffi.Pointer<AVFilterInOut>>)>();

  /// Free the provided AVFilterGraphSegment and everything associated with it.
  ///
  /// @param seg double pointer to the AVFilterGraphSegment to be freed. NULL will
  /// be written to this pointer on exit from this function.
  ///
  /// @note
  /// The filter contexts (AVFilterParams.filter) are owned by AVFilterGraph rather
  /// than AVFilterGraphSegment, so they are not freed.
  void avfilter_graph_segment_free(
    ffi.Pointer<ffi.Pointer<AVFilterGraphSegment>> seg,
  ) {
    return _avfilter_graph_segment_free(
      seg,
    );
  }

  late final _avfilter_graph_segment_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Pointer<AVFilterGraphSegment>>)>>(
      'avfilter_graph_segment_free');
  late final _avfilter_graph_segment_free =
      _avfilter_graph_segment_freePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<AVFilterGraphSegment>>)>();

  /// Send a command to one or more filter instances.
  ///
  /// @param graph  the filter graph
  /// @param target the filter(s) to which the command should be sent
  /// "all" sends to all filters
  /// otherwise it can be a filter or filter instance name
  /// which will send the command to all matching filters.
  /// @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only
  /// @param arg    the argument for the command
  /// @param res    a buffer with size res_size where the filter(s) can return a response.
  ///
  /// @returns >=0 on success otherwise an error code.
  /// AVERROR(ENOSYS) on unsupported commands
  int avfilter_graph_send_command(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> cmd,
    ffi.Pointer<ffi.Char> arg,
    ffi.Pointer<ffi.Char> res,
    int res_len,
    int flags,
  ) {
    return _avfilter_graph_send_command(
      graph,
      target,
      cmd,
      arg,
      res,
      res_len,
      flags,
    );
  }

  late final _avfilter_graph_send_commandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('avfilter_graph_send_command');
  late final _avfilter_graph_send_command =
      _avfilter_graph_send_commandPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              int)>();

  /// Queue a command for one or more filter instances.
  ///
  /// @param graph  the filter graph
  /// @param target the filter(s) to which the command should be sent
  /// "all" sends to all filters
  /// otherwise it can be a filter or filter instance name
  /// which will send the command to all matching filters.
  /// @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only
  /// @param arg    the argument for the command
  /// @param ts     time at which the command should be sent to the filter
  ///
  /// @note As this executes commands after this function returns, no return code
  /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.
  int avfilter_graph_queue_command(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> cmd,
    ffi.Pointer<ffi.Char> arg,
    int flags,
    double ts,
  ) {
    return _avfilter_graph_queue_command(
      graph,
      target,
      cmd,
      arg,
      flags,
      ts,
    );
  }

  late final _avfilter_graph_queue_commandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Double)>>('avfilter_graph_queue_command');
  late final _avfilter_graph_queue_command =
      _avfilter_graph_queue_commandPtr.asFunction<
          int Function(ffi.Pointer<AVFilterGraph>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, double)>();

  /// Dump a graph into a human-readable string representation.
  ///
  /// @param graph    the graph to dump
  /// @param options  formatting options; currently ignored
  /// @return  a string, or NULL in case of memory allocation failure;
  /// the string must be freed using av_free
  ffi.Pointer<ffi.Char> avfilter_graph_dump(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Char> options,
  ) {
    return _avfilter_graph_dump(
      graph,
      options,
    );
  }

  late final _avfilter_graph_dumpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<AVFilterGraph>,
              ffi.Pointer<ffi.Char>)>>('avfilter_graph_dump');
  late final _avfilter_graph_dump = _avfilter_graph_dumpPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<AVFilterGraph>, ffi.Pointer<ffi.Char>)>();

  /// Request a frame on the oldest sink link.
  ///
  /// If the request returns AVERROR_EOF, try the next.
  ///
  /// Note that this function is not meant to be the sole scheduling mechanism
  /// of a filtergraph, only a convenience function to help drain a filtergraph
  /// in a balanced way under normal circumstances.
  ///
  /// Also note that AVERROR_EOF does not mean that frames did not arrive on
  /// some of the sinks during the process.
  /// When there are multiple sink links, in case the requested link
  /// returns an EOF, this may cause a filter to flush pending frames
  /// which are sent to another sink link, although unrequested.
  ///
  /// @return  the return value of ff_request_frame(),
  /// or AVERROR_EOF if all links returned AVERROR_EOF
  int avfilter_graph_request_oldest(
    ffi.Pointer<AVFilterGraph> graph,
  ) {
    return _avfilter_graph_request_oldest(
      graph,
    );
  }

  late final _avfilter_graph_request_oldestPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterGraph>)>>(
          'avfilter_graph_request_oldest');
  late final _avfilter_graph_request_oldest = _avfilter_graph_request_oldestPtr
      .asFunction<int Function(ffi.Pointer<AVFilterGraph>)>();

  /// Get the number of failed requests.
  ///
  /// A failed request is when the request_frame method is called while no
  /// frame is present in the buffer.
  /// The number is reset when a frame is added.
  int av_buffersrc_get_nb_failed_requests(
    ffi.Pointer<AVFilterContext> buffer_src,
  ) {
    return _av_buffersrc_get_nb_failed_requests(
      buffer_src,
    );
  }

  late final _av_buffersrc_get_nb_failed_requestsPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersrc_get_nb_failed_requests');
  late final _av_buffersrc_get_nb_failed_requests =
      _av_buffersrc_get_nb_failed_requestsPtr
          .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  /// Allocate a new AVBufferSrcParameters instance. It should be freed by the
  /// caller with av_free().
  ffi.Pointer<AVBufferSrcParameters> av_buffersrc_parameters_alloc() {
    return _av_buffersrc_parameters_alloc();
  }

  late final _av_buffersrc_parameters_allocPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<AVBufferSrcParameters> Function()>>(
      'av_buffersrc_parameters_alloc');
  late final _av_buffersrc_parameters_alloc = _av_buffersrc_parameters_allocPtr
      .asFunction<ffi.Pointer<AVBufferSrcParameters> Function()>();

  /// Initialize the buffersrc or abuffersrc filter with the provided parameters.
  /// This function may be called multiple times, the later calls override the
  /// previous ones. Some of the parameters may also be set through AVOptions, then
  /// whatever method is used last takes precedence.
  ///
  /// @param ctx an instance of the buffersrc or abuffersrc filter
  /// @param param the stream parameters. The frames later passed to this filter
  /// must conform to those parameters. All the allocated fields in
  /// param remain owned by the caller, libavfilter will make internal
  /// copies or references when necessary.
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_buffersrc_parameters_set(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVBufferSrcParameters> param,
  ) {
    return _av_buffersrc_parameters_set(
      ctx,
      param,
    );
  }

  late final _av_buffersrc_parameters_setPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<AVFilterContext>,
                  ffi.Pointer<AVBufferSrcParameters>)>>(
      'av_buffersrc_parameters_set');
  late final _av_buffersrc_parameters_set =
      _av_buffersrc_parameters_setPtr.asFunction<
          int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<AVBufferSrcParameters>)>();

  /// Add a frame to the buffer source.
  ///
  /// @param ctx   an instance of the buffersrc filter
  /// @param frame frame to be added. If the frame is reference counted, this
  /// function will make a new reference to it. Otherwise the frame data will be
  /// copied.
  ///
  /// @return 0 on success, a negative AVERROR on error
  ///
  /// This function is equivalent to av_buffersrc_add_frame_flags() with the
  /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
  int av_buffersrc_write_frame(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_buffersrc_write_frame(
      ctx,
      frame,
    );
  }

  late final _av_buffersrc_write_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<AVFrame>)>>('av_buffersrc_write_frame');
  late final _av_buffersrc_write_frame =
      _av_buffersrc_write_framePtr.asFunction<
          int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>)>();

  /// Add a frame to the buffer source.
  ///
  /// @param ctx   an instance of the buffersrc filter
  /// @param frame frame to be added. If the frame is reference counted, this
  /// function will take ownership of the reference(s) and reset the frame.
  /// Otherwise the frame data will be copied. If this function returns an error,
  /// the input frame is not touched.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  ///
  /// @note the difference between this function and av_buffersrc_write_frame() is
  /// that av_buffersrc_write_frame() creates a new reference to the input frame,
  /// while this function takes ownership of the reference passed to it.
  ///
  /// This function is equivalent to av_buffersrc_add_frame_flags() without the
  /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
  int av_buffersrc_add_frame(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_buffersrc_add_frame(
      ctx,
      frame,
    );
  }

  late final _av_buffersrc_add_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<AVFrame>)>>('av_buffersrc_add_frame');
  late final _av_buffersrc_add_frame = _av_buffersrc_add_framePtr.asFunction<
      int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>)>();

  /// Add a frame to the buffer source.
  ///
  /// By default, if the frame is reference-counted, this function will take
  /// ownership of the reference(s) and reset the frame. This can be controlled
  /// using the flags.
  ///
  /// If this function returns an error, the input frame is not touched.
  ///
  /// @param buffer_src  pointer to a buffer source context
  /// @param frame       a frame, or NULL to mark EOF
  /// @param flags       a combination of AV_BUFFERSRC_FLAG_*
  /// @return            >= 0 in case of success, a negative AVERROR code
  /// in case of failure
  int av_buffersrc_add_frame_flags(
    ffi.Pointer<AVFilterContext> buffer_src,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    return _av_buffersrc_add_frame_flags(
      buffer_src,
      frame,
      flags,
    );
  }

  late final _av_buffersrc_add_frame_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('av_buffersrc_add_frame_flags');
  late final _av_buffersrc_add_frame_flags =
      _av_buffersrc_add_frame_flagsPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>, int)>();

  /// Close the buffer source after EOF.
  ///
  /// This is similar to passing NULL to av_buffersrc_add_frame_flags()
  /// except it takes the timestamp of the EOF, i.e. the timestamp of the end
  /// of the last frame.
  int av_buffersrc_close(
    ffi.Pointer<AVFilterContext> ctx,
    int pts,
    int flags,
  ) {
    return _av_buffersrc_close(
      ctx,
      pts,
      flags,
    );
  }

  late final _av_buffersrc_closePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>, ffi.Int64,
              ffi.UnsignedInt)>>('av_buffersrc_close');
  late final _av_buffersrc_close = _av_buffersrc_closePtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>, int, int)>();

  /// Get a frame with filtered data from sink and put it in frame.
  ///
  /// @param ctx    pointer to a buffersink or abuffersink filter context.
  /// @param frame  pointer to an allocated frame that will be filled with data.
  /// The data must be freed using av_frame_unref() / av_frame_free()
  /// @param flags  a combination of AV_BUFFERSINK_FLAG_* flags
  ///
  /// @return  >= 0 in for success, a negative AVERROR code for failure.
  int av_buffersink_get_frame_flags(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    return _av_buffersink_get_frame_flags(
      ctx,
      frame,
      flags,
    );
  }

  late final _av_buffersink_get_frame_flagsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('av_buffersink_get_frame_flags');
  late final _av_buffersink_get_frame_flags =
      _av_buffersink_get_frame_flagsPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>, int)>();

  /// Set the frame size for an audio buffer sink.
  ///
  /// All calls to av_buffersink_get_buffer_ref will return a buffer with
  /// exactly the specified number of samples, or AVERROR(EAGAIN) if there is
  /// not enough. The last buffer at EOF will be padded with 0.
  void av_buffersink_set_frame_size(
    ffi.Pointer<AVFilterContext> ctx,
    int frame_size,
  ) {
    return _av_buffersink_set_frame_size(
      ctx,
      frame_size,
    );
  }

  late final _av_buffersink_set_frame_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVFilterContext>,
              ffi.UnsignedInt)>>('av_buffersink_set_frame_size');
  late final _av_buffersink_set_frame_size = _av_buffersink_set_frame_sizePtr
      .asFunction<void Function(ffi.Pointer<AVFilterContext>, int)>();

  /// @defgroup lavfi_buffersink_accessors Buffer sink accessors
  /// Get the properties of the stream
  /// @{
  AVMediaType av_buffersink_get_type(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return AVMediaType.fromValue(_av_buffersink_get_type(
      ctx,
    ));
  }

  late final _av_buffersink_get_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_type');
  late final _av_buffersink_get_type = _av_buffersink_get_typePtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  AVRational av_buffersink_get_time_base(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_time_base(
      ctx,
    );
  }

  late final _av_buffersink_get_time_basePtr = _lookup<
          ffi
          .NativeFunction<AVRational Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_time_base');
  late final _av_buffersink_get_time_base = _av_buffersink_get_time_basePtr
      .asFunction<AVRational Function(ffi.Pointer<AVFilterContext>)>();

  int av_buffersink_get_format(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_format(
      ctx,
    );
  }

  late final _av_buffersink_get_formatPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_format');
  late final _av_buffersink_get_format = _av_buffersink_get_formatPtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  AVRational av_buffersink_get_frame_rate(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_frame_rate(
      ctx,
    );
  }

  late final _av_buffersink_get_frame_ratePtr = _lookup<
          ffi
          .NativeFunction<AVRational Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_frame_rate');
  late final _av_buffersink_get_frame_rate = _av_buffersink_get_frame_ratePtr
      .asFunction<AVRational Function(ffi.Pointer<AVFilterContext>)>();

  int av_buffersink_get_w(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_w(
      ctx,
    );
  }

  late final _av_buffersink_get_wPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_w');
  late final _av_buffersink_get_w = _av_buffersink_get_wPtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  int av_buffersink_get_h(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_h(
      ctx,
    );
  }

  late final _av_buffersink_get_hPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_h');
  late final _av_buffersink_get_h = _av_buffersink_get_hPtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  AVRational av_buffersink_get_sample_aspect_ratio(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_sample_aspect_ratio(
      ctx,
    );
  }

  late final _av_buffersink_get_sample_aspect_ratioPtr = _lookup<
          ffi
          .NativeFunction<AVRational Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_sample_aspect_ratio');
  late final _av_buffersink_get_sample_aspect_ratio =
      _av_buffersink_get_sample_aspect_ratioPtr
          .asFunction<AVRational Function(ffi.Pointer<AVFilterContext>)>();

  AVColorSpace av_buffersink_get_colorspace(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return AVColorSpace.fromValue(_av_buffersink_get_colorspace(
      ctx,
    ));
  }

  late final _av_buffersink_get_colorspacePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<AVFilterContext>)>>('av_buffersink_get_colorspace');
  late final _av_buffersink_get_colorspace = _av_buffersink_get_colorspacePtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  AVColorRange av_buffersink_get_color_range(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return AVColorRange.fromValue(_av_buffersink_get_color_range(
      ctx,
    ));
  }

  late final _av_buffersink_get_color_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<AVFilterContext>)>>('av_buffersink_get_color_range');
  late final _av_buffersink_get_color_range = _av_buffersink_get_color_rangePtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  int av_buffersink_get_channels(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_channels(
      ctx,
    );
  }

  late final _av_buffersink_get_channelsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_channels');
  late final _av_buffersink_get_channels = _av_buffersink_get_channelsPtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  int av_buffersink_get_ch_layout(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVChannelLayout> ch_layout,
  ) {
    return _av_buffersink_get_ch_layout(
      ctx,
      ch_layout,
    );
  }

  late final _av_buffersink_get_ch_layoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<AVChannelLayout>)>>('av_buffersink_get_ch_layout');
  late final _av_buffersink_get_ch_layout =
      _av_buffersink_get_ch_layoutPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterContext>, ffi.Pointer<AVChannelLayout>)>();

  int av_buffersink_get_sample_rate(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_sample_rate(
      ctx,
    );
  }

  late final _av_buffersink_get_sample_ratePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_sample_rate');
  late final _av_buffersink_get_sample_rate = _av_buffersink_get_sample_ratePtr
      .asFunction<int Function(ffi.Pointer<AVFilterContext>)>();

  ffi.Pointer<AVBufferRef> av_buffersink_get_hw_frames_ctx(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    return _av_buffersink_get_hw_frames_ctx(
      ctx,
    );
  }

  late final _av_buffersink_get_hw_frames_ctxPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVBufferRef> Function(ffi.Pointer<AVFilterContext>)>>(
      'av_buffersink_get_hw_frames_ctx');
  late final _av_buffersink_get_hw_frames_ctx =
      _av_buffersink_get_hw_frames_ctxPtr.asFunction<
          ffi.Pointer<AVBufferRef> Function(ffi.Pointer<AVFilterContext>)>();

  /// Get a frame with filtered data from sink and put it in frame.
  ///
  /// @param ctx pointer to a context of a buffersink or abuffersink AVFilter.
  /// @param frame pointer to an allocated frame that will be filled with data.
  /// The data must be freed using av_frame_unref() / av_frame_free()
  ///
  /// @return
  /// - >= 0 if a frame was successfully returned.
  /// - AVERROR(EAGAIN) if no frames are available at this point; more
  /// input frames must be added to the filtergraph to get more output.
  /// - AVERROR_EOF if there will be no more output frames on this sink.
  /// - A different negative AVERROR code in other failure cases.
  int av_buffersink_get_frame(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_buffersink_get_frame(
      ctx,
      frame,
    );
  }

  late final _av_buffersink_get_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>,
              ffi.Pointer<AVFrame>)>>('av_buffersink_get_frame');
  late final _av_buffersink_get_frame = _av_buffersink_get_framePtr.asFunction<
      int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>)>();

  /// Same as av_buffersink_get_frame(), but with the ability to specify the number
  /// of samples read. This function is less efficient than
  /// av_buffersink_get_frame(), because it copies the data around.
  ///
  /// @param ctx pointer to a context of the abuffersink AVFilter.
  /// @param frame pointer to an allocated frame that will be filled with data.
  /// The data must be freed using av_frame_unref() / av_frame_free()
  /// frame will contain exactly nb_samples audio samples, except at
  /// the end of stream, when it can contain less than nb_samples.
  ///
  /// @return The return codes have the same meaning as for
  /// av_buffersink_get_frame().
  ///
  /// @warning do not mix this function with av_buffersink_get_frame(). Use only one or
  /// the other with a single sink, not both.
  int av_buffersink_get_samples(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
    int nb_samples,
  ) {
    return _av_buffersink_get_samples(
      ctx,
      frame,
      nb_samples,
    );
  }

  late final _av_buffersink_get_samplesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>,
              ffi.Int)>>('av_buffersink_get_samples');
  late final _av_buffersink_get_samples =
      _av_buffersink_get_samplesPtr.asFunction<
          int Function(
              ffi.Pointer<AVFilterContext>, ffi.Pointer<AVFrame>, int)>();

  /// Get the current time in microseconds.
  int av_gettime() {
    return _av_gettime();
  }

  late final _av_gettimePtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function()>>('av_gettime');
  late final _av_gettime = _av_gettimePtr.asFunction<int Function()>();

  /// Get the current time in microseconds since some unspecified starting point.
  /// On platforms that support it, the time comes from a monotonic clock
  /// This property makes this time source ideal for measuring relative time.
  /// The returned values may not be monotonic on platforms where a monotonic
  /// clock is not available.
  int av_gettime_relative() {
    return _av_gettime_relative();
  }

  late final _av_gettime_relativePtr =
      _lookup<ffi.NativeFunction<ffi.Int64 Function()>>('av_gettime_relative');
  late final _av_gettime_relative =
      _av_gettime_relativePtr.asFunction<int Function()>();

  /// Indicates with a boolean result if the av_gettime_relative() time source
  /// is monotonic.
  int av_gettime_relative_is_monotonic() {
    return _av_gettime_relative_is_monotonic();
  }

  late final _av_gettime_relative_is_monotonicPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'av_gettime_relative_is_monotonic');
  late final _av_gettime_relative_is_monotonic =
      _av_gettime_relative_is_monotonicPtr.asFunction<int Function()>();

  /// Sleep for a period of time.  Although the duration is expressed in
  /// microseconds, the actual delay may be rounded to the precision of the
  /// system timer.
  ///
  /// @param  usec Number of microseconds to sleep.
  /// @return zero on success or (negative) error code.
  int av_usleep(
    int usec,
  ) {
    return _av_usleep(
      usec,
    );
  }

  late final _av_usleepPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.UnsignedInt)>>(
          'av_usleep');
  late final _av_usleep = _av_usleepPtr.asFunction<int Function(int)>();

  /// Assert that floating point operations can be executed.
  ///
  /// This will av_assert0() that the cpu is not in MMX state on X86
  void av_assert0_fpu() {
    return _av_assert0_fpu();
  }

  late final _av_assert0_fpuPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('av_assert0_fpu');
  late final _av_assert0_fpu = _av_assert0_fpuPtr.asFunction<void Function()>();

  ffi.Pointer<AVClass> av_iamf_param_definition_get_class() {
    return _av_iamf_param_definition_get_class();
  }

  late final _av_iamf_param_definition_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'av_iamf_param_definition_get_class');
  late final _av_iamf_param_definition_get_class =
      _av_iamf_param_definition_get_classPtr
          .asFunction<ffi.Pointer<AVClass> Function()>();

  /// Allocates memory for AVIAMFParamDefinition, plus an array of {@code nb_subblocks}
  /// amount of subblocks of the given type and initializes the variables. Can be
  /// freed with a normal av_free() call.
  ///
  /// @param size if non-NULL, the size in bytes of the resulting data array is written here.
  ffi.Pointer<AVIAMFParamDefinition> av_iamf_param_definition_alloc(
    AVIAMFParamDefinitionType type,
    int nb_subblocks,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_iamf_param_definition_alloc(
      type.value,
      nb_subblocks,
      size,
    );
  }

  late final _av_iamf_param_definition_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVIAMFParamDefinition> Function(
              ffi.UnsignedInt,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Size>)>>('av_iamf_param_definition_alloc');
  late final _av_iamf_param_definition_alloc =
      _av_iamf_param_definition_allocPtr.asFunction<
          ffi.Pointer<AVIAMFParamDefinition> Function(
              int, int, ffi.Pointer<ffi.Size>)>();

  ffi.Pointer<AVClass> av_iamf_audio_element_get_class() {
    return _av_iamf_audio_element_get_class();
  }

  late final _av_iamf_audio_element_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'av_iamf_audio_element_get_class');
  late final _av_iamf_audio_element_get_class =
      _av_iamf_audio_element_get_classPtr
          .asFunction<ffi.Pointer<AVClass> Function()>();

  /// Allocates a AVIAMFAudioElement, and initializes its fields with default values.
  /// No layers are allocated. Must be freed with av_iamf_audio_element_free().
  ///
  /// @see av_iamf_audio_element_add_layer()
  ffi.Pointer<AVIAMFAudioElement> av_iamf_audio_element_alloc() {
    return _av_iamf_audio_element_alloc();
  }

  late final _av_iamf_audio_element_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVIAMFAudioElement> Function()>>(
          'av_iamf_audio_element_alloc');
  late final _av_iamf_audio_element_alloc = _av_iamf_audio_element_allocPtr
      .asFunction<ffi.Pointer<AVIAMFAudioElement> Function()>();

  /// Allocate a layer and add it to a given AVIAMFAudioElement.
  /// It is freed by av_iamf_audio_element_free() alongside the rest of the parent
  /// AVIAMFAudioElement.
  ///
  /// @return a pointer to the allocated layer.
  ffi.Pointer<AVIAMFLayer> av_iamf_audio_element_add_layer(
    ffi.Pointer<AVIAMFAudioElement> audio_element,
  ) {
    return _av_iamf_audio_element_add_layer(
      audio_element,
    );
  }

  late final _av_iamf_audio_element_add_layerPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVIAMFLayer> Function(
                  ffi.Pointer<AVIAMFAudioElement>)>>(
      'av_iamf_audio_element_add_layer');
  late final _av_iamf_audio_element_add_layer =
      _av_iamf_audio_element_add_layerPtr.asFunction<
          ffi.Pointer<AVIAMFLayer> Function(ffi.Pointer<AVIAMFAudioElement>)>();

  /// Free an AVIAMFAudioElement and all its contents.
  ///
  /// @param audio_element pointer to pointer to an allocated AVIAMFAudioElement.
  /// upon return, *audio_element will be set to NULL.
  void av_iamf_audio_element_free(
    ffi.Pointer<ffi.Pointer<AVIAMFAudioElement>> audio_element,
  ) {
    return _av_iamf_audio_element_free(
      audio_element,
    );
  }

  late final _av_iamf_audio_element_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Pointer<AVIAMFAudioElement>>)>>(
      'av_iamf_audio_element_free');
  late final _av_iamf_audio_element_free =
      _av_iamf_audio_element_freePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<AVIAMFAudioElement>>)>();

  ffi.Pointer<AVClass> av_iamf_mix_presentation_get_class() {
    return _av_iamf_mix_presentation_get_class();
  }

  late final _av_iamf_mix_presentation_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'av_iamf_mix_presentation_get_class');
  late final _av_iamf_mix_presentation_get_class =
      _av_iamf_mix_presentation_get_classPtr
          .asFunction<ffi.Pointer<AVClass> Function()>();

  /// Allocates a AVIAMFMixPresentation, and initializes its fields with default
  /// values. No submixes are allocated.
  /// Must be freed with av_iamf_mix_presentation_free().
  ///
  /// @see av_iamf_mix_presentation_add_submix()
  ffi.Pointer<AVIAMFMixPresentation> av_iamf_mix_presentation_alloc() {
    return _av_iamf_mix_presentation_alloc();
  }

  late final _av_iamf_mix_presentation_allocPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<AVIAMFMixPresentation> Function()>>(
      'av_iamf_mix_presentation_alloc');
  late final _av_iamf_mix_presentation_alloc =
      _av_iamf_mix_presentation_allocPtr
          .asFunction<ffi.Pointer<AVIAMFMixPresentation> Function()>();

  /// Allocate a submix and add it to a given AVIAMFMixPresentation.
  /// It is freed by av_iamf_mix_presentation_free() alongside the rest of the
  /// parent AVIAMFMixPresentation.
  ///
  /// @return a pointer to the allocated submix.
  ffi.Pointer<AVIAMFSubmix> av_iamf_mix_presentation_add_submix(
    ffi.Pointer<AVIAMFMixPresentation> mix_presentation,
  ) {
    return _av_iamf_mix_presentation_add_submix(
      mix_presentation,
    );
  }

  late final _av_iamf_mix_presentation_add_submixPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVIAMFSubmix> Function(
                  ffi.Pointer<AVIAMFMixPresentation>)>>(
      'av_iamf_mix_presentation_add_submix');
  late final _av_iamf_mix_presentation_add_submix =
      _av_iamf_mix_presentation_add_submixPtr.asFunction<
          ffi.Pointer<AVIAMFSubmix> Function(
              ffi.Pointer<AVIAMFMixPresentation>)>();

  /// Allocate a submix element and add it to a given AVIAMFSubmix.
  /// It is freed by av_iamf_mix_presentation_free() alongside the rest of the
  /// parent AVIAMFSubmix.
  ///
  /// @return a pointer to the allocated submix.
  ffi.Pointer<AVIAMFSubmixElement> av_iamf_submix_add_element(
    ffi.Pointer<AVIAMFSubmix> submix,
  ) {
    return _av_iamf_submix_add_element(
      submix,
    );
  }

  late final _av_iamf_submix_add_elementPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVIAMFSubmixElement> Function(
              ffi.Pointer<AVIAMFSubmix>)>>('av_iamf_submix_add_element');
  late final _av_iamf_submix_add_element =
      _av_iamf_submix_add_elementPtr.asFunction<
          ffi.Pointer<AVIAMFSubmixElement> Function(
              ffi.Pointer<AVIAMFSubmix>)>();

  /// Allocate a submix layout and add it to a given AVIAMFSubmix.
  /// It is freed by av_iamf_mix_presentation_free() alongside the rest of the
  /// parent AVIAMFSubmix.
  ///
  /// @return a pointer to the allocated submix.
  ffi.Pointer<AVIAMFSubmixLayout> av_iamf_submix_add_layout(
    ffi.Pointer<AVIAMFSubmix> submix,
  ) {
    return _av_iamf_submix_add_layout(
      submix,
    );
  }

  late final _av_iamf_submix_add_layoutPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVIAMFSubmixLayout> Function(
              ffi.Pointer<AVIAMFSubmix>)>>('av_iamf_submix_add_layout');
  late final _av_iamf_submix_add_layout =
      _av_iamf_submix_add_layoutPtr.asFunction<
          ffi.Pointer<AVIAMFSubmixLayout> Function(
              ffi.Pointer<AVIAMFSubmix>)>();

  /// Free an AVIAMFMixPresentation and all its contents.
  ///
  /// @param mix_presentation pointer to pointer to an allocated AVIAMFMixPresentation.
  /// upon return, *mix_presentation will be set to NULL.
  void av_iamf_mix_presentation_free(
    ffi.Pointer<ffi.Pointer<AVIAMFMixPresentation>> mix_presentation,
  ) {
    return _av_iamf_mix_presentation_free(
      mix_presentation,
    );
  }

  late final _av_iamf_mix_presentation_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Pointer<AVIAMFMixPresentation>>)>>(
      'av_iamf_mix_presentation_free');
  late final _av_iamf_mix_presentation_free =
      _av_iamf_mix_presentation_freePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<AVIAMFMixPresentation>>)>();

  /// Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}
  /// AVDetectionBBox, and initializes the variables.
  /// Can be freed with a normal av_free() call.
  ///
  /// @param nb_bboxes number of AVDetectionBBox structures to allocate
  /// @param out_size if non-NULL, the size in bytes of the resulting data array is
  /// written here.
  ffi.Pointer<AVDetectionBBoxHeader> av_detection_bbox_alloc(
    int nb_bboxes,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _av_detection_bbox_alloc(
      nb_bboxes,
      out_size,
    );
  }

  late final _av_detection_bbox_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDetectionBBoxHeader> Function(
              ffi.Uint32, ffi.Pointer<ffi.Size>)>>('av_detection_bbox_alloc');
  late final _av_detection_bbox_alloc = _av_detection_bbox_allocPtr.asFunction<
      ffi.Pointer<AVDetectionBBoxHeader> Function(
          int, ffi.Pointer<ffi.Size>)>();

  /// Allocates memory for AVDetectionBBoxHeader, plus an array of {@code nb_bboxes}
  /// AVDetectionBBox, in the given AVFrame {@code frame} as AVFrameSideData of type
  /// AV_FRAME_DATA_DETECTION_BBOXES and initializes the variables.
  ffi.Pointer<AVDetectionBBoxHeader> av_detection_bbox_create_side_data(
    ffi.Pointer<AVFrame> frame,
    int nb_bboxes,
  ) {
    return _av_detection_bbox_create_side_data(
      frame,
      nb_bboxes,
    );
  }

  late final _av_detection_bbox_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDetectionBBoxHeader> Function(ffi.Pointer<AVFrame>,
              ffi.Uint32)>>('av_detection_bbox_create_side_data');
  late final _av_detection_bbox_create_side_data =
      _av_detection_bbox_create_side_dataPtr.asFunction<
          ffi.Pointer<AVDetectionBBoxHeader> Function(
              ffi.Pointer<AVFrame>, int)>();

  /// Allocate an AVAmbientViewingEnvironment structure.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVAmbientViewingEnvironment> av_ambient_viewing_environment_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_ambient_viewing_environment_alloc(
      size,
    );
  }

  late final _av_ambient_viewing_environment_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVAmbientViewingEnvironment> Function(
              ffi.Pointer<ffi.Size>)>>('av_ambient_viewing_environment_alloc');
  late final _av_ambient_viewing_environment_alloc =
      _av_ambient_viewing_environment_allocPtr.asFunction<
          ffi.Pointer<AVAmbientViewingEnvironment> Function(
              ffi.Pointer<ffi.Size>)>();

  /// Allocate and add an AVAmbientViewingEnvironment structure to an existing
  /// AVFrame as side data.
  ///
  /// @return the newly allocated struct, or NULL on failure
  ffi.Pointer<AVAmbientViewingEnvironment>
      av_ambient_viewing_environment_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_ambient_viewing_environment_create_side_data(
      frame,
    );
  }

  late final _av_ambient_viewing_environment_create_side_dataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVAmbientViewingEnvironment> Function(
                  ffi.Pointer<AVFrame>)>>(
      'av_ambient_viewing_environment_create_side_data');
  late final _av_ambient_viewing_environment_create_side_data =
      _av_ambient_viewing_environment_create_side_dataPtr.asFunction<
          ffi.Pointer<AVAmbientViewingEnvironment> Function(
              ffi.Pointer<AVFrame>)>();

  /// Allocate and initialize an AVFifo with a given element size.
  ///
  /// @param elems     initial number of elements that can be stored in the FIFO
  /// @param elem_size Size in bytes of a single element. Further operations on
  /// the returned FIFO will implicitly use this element size.
  /// @param flags a combination of AV_FIFO_FLAG_*
  ///
  /// @return newly-allocated AVFifo on success, a negative error code on failure
  ffi.Pointer<AVFifo> av_fifo_alloc2(
    int elems,
    int elem_size,
    int flags,
  ) {
    return _av_fifo_alloc2(
      elems,
      elem_size,
      flags,
    );
  }

  late final _av_fifo_alloc2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFifo> Function(
              ffi.Size, ffi.Size, ffi.UnsignedInt)>>('av_fifo_alloc2');
  late final _av_fifo_alloc2 = _av_fifo_alloc2Ptr
      .asFunction<ffi.Pointer<AVFifo> Function(int, int, int)>();

  /// @return Element size for FIFO operations. This element size is set at
  /// FIFO allocation and remains constant during its lifetime
  int av_fifo_elem_size(
    ffi.Pointer<AVFifo> f,
  ) {
    return _av_fifo_elem_size(
      f,
    );
  }

  late final _av_fifo_elem_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<AVFifo>)>>(
          'av_fifo_elem_size');
  late final _av_fifo_elem_size =
      _av_fifo_elem_sizePtr.asFunction<int Function(ffi.Pointer<AVFifo>)>();

  /// Set the maximum size (in elements) to which the FIFO can be resized
  /// automatically. Has no effect unless AV_FIFO_FLAG_AUTO_GROW is used.
  void av_fifo_auto_grow_limit(
    ffi.Pointer<AVFifo> f,
    int max_elems,
  ) {
    return _av_fifo_auto_grow_limit(
      f,
      max_elems,
    );
  }

  late final _av_fifo_auto_grow_limitPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFifo>, ffi.Size)>>(
      'av_fifo_auto_grow_limit');
  late final _av_fifo_auto_grow_limit = _av_fifo_auto_grow_limitPtr
      .asFunction<void Function(ffi.Pointer<AVFifo>, int)>();

  /// @return number of elements available for reading from the given FIFO.
  int av_fifo_can_read(
    ffi.Pointer<AVFifo> f,
  ) {
    return _av_fifo_can_read(
      f,
    );
  }

  late final _av_fifo_can_readPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<AVFifo>)>>(
          'av_fifo_can_read');
  late final _av_fifo_can_read =
      _av_fifo_can_readPtr.asFunction<int Function(ffi.Pointer<AVFifo>)>();

  /// @return Number of elements that can be written into the given FIFO without
  /// growing it.
  ///
  /// In other words, this number of elements or less is guaranteed to fit
  /// into the FIFO. More data may be written when the
  /// AV_FIFO_FLAG_AUTO_GROW flag was specified at FIFO creation, but this
  /// may involve memory allocation, which can fail.
  int av_fifo_can_write(
    ffi.Pointer<AVFifo> f,
  ) {
    return _av_fifo_can_write(
      f,
    );
  }

  late final _av_fifo_can_writePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<AVFifo>)>>(
          'av_fifo_can_write');
  late final _av_fifo_can_write =
      _av_fifo_can_writePtr.asFunction<int Function(ffi.Pointer<AVFifo>)>();

  /// Enlarge an AVFifo.
  ///
  /// On success, the FIFO will be large enough to hold exactly
  /// inc + av_fifo_can_read() + av_fifo_can_write()
  /// elements. In case of failure, the old FIFO is kept unchanged.
  ///
  /// @param f AVFifo to resize
  /// @param inc number of elements to allocate for, in addition to the current
  /// allocated size
  /// @return a non-negative number on success, a negative error code on failure
  int av_fifo_grow2(
    ffi.Pointer<AVFifo> f,
    int inc,
  ) {
    return _av_fifo_grow2(
      f,
      inc,
    );
  }

  late final _av_fifo_grow2Ptr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFifo>, ffi.Size)>>(
      'av_fifo_grow2');
  late final _av_fifo_grow2 =
      _av_fifo_grow2Ptr.asFunction<int Function(ffi.Pointer<AVFifo>, int)>();

  /// Write data into a FIFO.
  ///
  /// In case nb_elems > av_fifo_can_write(f) and the AV_FIFO_FLAG_AUTO_GROW flag
  /// was not specified at FIFO creation, nothing is written and an error
  /// is returned.
  ///
  /// Calling function is guaranteed to succeed if nb_elems <= av_fifo_can_write(f).
  ///
  /// @param f the FIFO buffer
  /// @param buf Data to be written. nb_elems * av_fifo_elem_size(f) bytes will be
  /// read from buf on success.
  /// @param nb_elems number of elements to write into FIFO
  ///
  /// @return a non-negative number on success, a negative error code on failure
  int av_fifo_write(
    ffi.Pointer<AVFifo> f,
    ffi.Pointer<ffi.Void> buf,
    int nb_elems,
  ) {
    return _av_fifo_write(
      f,
      buf,
      nb_elems,
    );
  }

  late final _av_fifo_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFifo>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('av_fifo_write');
  late final _av_fifo_write = _av_fifo_writePtr.asFunction<
      int Function(ffi.Pointer<AVFifo>, ffi.Pointer<ffi.Void>, int)>();

  /// Write data from a user-provided callback into a FIFO.
  ///
  /// @param f the FIFO buffer
  /// @param read_cb Callback supplying the data to the FIFO. May be called
  /// multiple times.
  /// @param opaque opaque user data to be provided to read_cb
  /// @param nb_elems Should point to the maximum number of elements that can be
  /// written. Will be updated to contain the number of elements
  /// actually written.
  ///
  /// @return non-negative number on success, a negative error code on failure
  int av_fifo_write_from_cb(
    ffi.Pointer<AVFifo> f,
    ffi.Pointer<AVFifoCB> read_cb,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.Size> nb_elems,
  ) {
    return _av_fifo_write_from_cb(
      f,
      read_cb,
      opaque,
      nb_elems,
    );
  }

  late final _av_fifo_write_from_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFifo>,
              ffi.Pointer<AVFifoCB>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Size>)>>('av_fifo_write_from_cb');
  late final _av_fifo_write_from_cb = _av_fifo_write_from_cbPtr.asFunction<
      int Function(ffi.Pointer<AVFifo>, ffi.Pointer<AVFifoCB>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Size>)>();

  /// Read data from a FIFO.
  ///
  /// In case nb_elems > av_fifo_can_read(f), nothing is read and an error
  /// is returned.
  ///
  /// @param f the FIFO buffer
  /// @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes
  /// will be written into buf on success.
  /// @param nb_elems number of elements to read from FIFO
  ///
  /// @return a non-negative number on success, a negative error code on failure
  int av_fifo_read(
    ffi.Pointer<AVFifo> f,
    ffi.Pointer<ffi.Void> buf,
    int nb_elems,
  ) {
    return _av_fifo_read(
      f,
      buf,
      nb_elems,
    );
  }

  late final _av_fifo_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFifo>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('av_fifo_read');
  late final _av_fifo_read = _av_fifo_readPtr.asFunction<
      int Function(ffi.Pointer<AVFifo>, ffi.Pointer<ffi.Void>, int)>();

  /// Feed data from a FIFO into a user-provided callback.
  ///
  /// @param f the FIFO buffer
  /// @param write_cb Callback the data will be supplied to. May be called
  /// multiple times.
  /// @param opaque opaque user data to be provided to write_cb
  /// @param nb_elems Should point to the maximum number of elements that can be
  /// read. Will be updated to contain the total number of elements
  /// actually sent to the callback.
  ///
  /// @return non-negative number on success, a negative error code on failure
  int av_fifo_read_to_cb(
    ffi.Pointer<AVFifo> f,
    ffi.Pointer<AVFifoCB> write_cb,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.Size> nb_elems,
  ) {
    return _av_fifo_read_to_cb(
      f,
      write_cb,
      opaque,
      nb_elems,
    );
  }

  late final _av_fifo_read_to_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFifo>,
              ffi.Pointer<AVFifoCB>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Size>)>>('av_fifo_read_to_cb');
  late final _av_fifo_read_to_cb = _av_fifo_read_to_cbPtr.asFunction<
      int Function(ffi.Pointer<AVFifo>, ffi.Pointer<AVFifoCB>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Size>)>();

  /// Read data from a FIFO without modifying FIFO state.
  ///
  /// Returns an error if an attempt is made to peek to nonexistent elements
  /// (i.e. if offset + nb_elems is larger than av_fifo_can_read(f)).
  ///
  /// @param f the FIFO buffer
  /// @param buf Buffer to store the data. nb_elems * av_fifo_elem_size(f) bytes
  /// will be written into buf.
  /// @param nb_elems number of elements to read from FIFO
  /// @param offset number of initial elements to skip.
  ///
  /// @return a non-negative number on success, a negative error code on failure
  int av_fifo_peek(
    ffi.Pointer<AVFifo> f,
    ffi.Pointer<ffi.Void> buf,
    int nb_elems,
    int offset,
  ) {
    return _av_fifo_peek(
      f,
      buf,
      nb_elems,
      offset,
    );
  }

  late final _av_fifo_peekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVFifo>, ffi.Pointer<ffi.Void>, ffi.Size,
              ffi.Size)>>('av_fifo_peek');
  late final _av_fifo_peek = _av_fifo_peekPtr.asFunction<
      int Function(ffi.Pointer<AVFifo>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Feed data from a FIFO into a user-provided callback.
  ///
  /// @param f the FIFO buffer
  /// @param write_cb Callback the data will be supplied to. May be called
  /// multiple times.
  /// @param opaque opaque user data to be provided to write_cb
  /// @param nb_elems Should point to the maximum number of elements that can be
  /// read. Will be updated to contain the total number of elements
  /// actually sent to the callback.
  /// @param offset number of initial elements to skip; offset + *nb_elems must not
  /// be larger than av_fifo_can_read(f).
  ///
  /// @return a non-negative number on success, a negative error code on failure
  int av_fifo_peek_to_cb(
    ffi.Pointer<AVFifo> f,
    ffi.Pointer<AVFifoCB> write_cb,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.Size> nb_elems,
    int offset,
  ) {
    return _av_fifo_peek_to_cb(
      f,
      write_cb,
      opaque,
      nb_elems,
      offset,
    );
  }

  late final _av_fifo_peek_to_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFifo>,
              ffi.Pointer<AVFifoCB>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Size>,
              ffi.Size)>>('av_fifo_peek_to_cb');
  late final _av_fifo_peek_to_cb = _av_fifo_peek_to_cbPtr.asFunction<
      int Function(ffi.Pointer<AVFifo>, ffi.Pointer<AVFifoCB>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Size>, int)>();

  /// Discard the specified amount of data from an AVFifo.
  /// @param size number of elements to discard, MUST NOT be larger than
  /// av_fifo_can_read(f)
  void av_fifo_drain2(
    ffi.Pointer<AVFifo> f,
    int size,
  ) {
    return _av_fifo_drain2(
      f,
      size,
    );
  }

  late final _av_fifo_drain2Ptr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFifo>, ffi.Size)>>(
      'av_fifo_drain2');
  late final _av_fifo_drain2 =
      _av_fifo_drain2Ptr.asFunction<void Function(ffi.Pointer<AVFifo>, int)>();

  void av_fifo_reset2(
    ffi.Pointer<AVFifo> f,
  ) {
    return _av_fifo_reset2(
      f,
    );
  }

  late final _av_fifo_reset2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVFifo>)>>(
          'av_fifo_reset2');
  late final _av_fifo_reset2 =
      _av_fifo_reset2Ptr.asFunction<void Function(ffi.Pointer<AVFifo>)>();

  /// Free an AVFifo and reset pointer to NULL.
  /// @param f Pointer to an AVFifo to free. *f == NULL is allowed.
  void av_fifo_freep2(
    ffi.Pointer<ffi.Pointer<AVFifo>> f,
  ) {
    return _av_fifo_freep2(
      f,
    );
  }

  late final _av_fifo_freep2Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Pointer<AVFifo>>)>>(
      'av_fifo_freep2');
  late final _av_fifo_freep2 = _av_fifo_freep2Ptr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVFifo>>)>();

  /// Allocate an AVBlowfish context.
  ffi.Pointer<AVBlowfish> av_blowfish_alloc() {
    return _av_blowfish_alloc();
  }

  late final _av_blowfish_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVBlowfish> Function()>>(
          'av_blowfish_alloc');
  late final _av_blowfish_alloc =
      _av_blowfish_allocPtr.asFunction<ffi.Pointer<AVBlowfish> Function()>();

  /// Initialize an AVBlowfish context.
  ///
  /// @param ctx an AVBlowfish context
  /// @param key a key
  /// @param key_len length of the key
  void av_blowfish_init(
    ffi.Pointer<AVBlowfish> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_len,
  ) {
    return _av_blowfish_init(
      ctx,
      key,
      key_len,
    );
  }

  late final _av_blowfish_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBlowfish>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_blowfish_init');
  late final _av_blowfish_init = _av_blowfish_initPtr.asFunction<
      void Function(ffi.Pointer<AVBlowfish>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param ctx an AVBlowfish context
  /// @param xl left four bytes halves of input to be encrypted
  /// @param xr right four bytes halves of input to be encrypted
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_blowfish_crypt_ecb(
    ffi.Pointer<AVBlowfish> ctx,
    ffi.Pointer<ffi.Uint32> xl,
    ffi.Pointer<ffi.Uint32> xr,
    int decrypt,
  ) {
    return _av_blowfish_crypt_ecb(
      ctx,
      xl,
      xr,
      decrypt,
    );
  }

  late final _av_blowfish_crypt_ecbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBlowfish>, ffi.Pointer<ffi.Uint32>,
              ffi.Pointer<ffi.Uint32>, ffi.Int)>>('av_blowfish_crypt_ecb');
  late final _av_blowfish_crypt_ecb = _av_blowfish_crypt_ecbPtr.asFunction<
      void Function(ffi.Pointer<AVBlowfish>, ffi.Pointer<ffi.Uint32>,
          ffi.Pointer<ffi.Uint32>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param ctx an AVBlowfish context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_blowfish_crypt(
    ffi.Pointer<AVBlowfish> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_blowfish_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_blowfish_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVBlowfish>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_blowfish_crypt');
  late final _av_blowfish_crypt = _av_blowfish_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVBlowfish>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate an AVMurMur3 hash context.
  ///
  /// @return Uninitialized hash context or `NULL` in case of error
  ffi.Pointer<AVMurMur3> av_murmur3_alloc() {
    return _av_murmur3_alloc();
  }

  late final _av_murmur3_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVMurMur3> Function()>>(
          'av_murmur3_alloc');
  late final _av_murmur3_alloc =
      _av_murmur3_allocPtr.asFunction<ffi.Pointer<AVMurMur3> Function()>();

  /// Initialize or reinitialize an AVMurMur3 hash context with a seed.
  ///
  /// @param[out] c    Hash context
  /// @param[in]  seed Random seed
  ///
  /// @see av_murmur3_init()
  /// @see @ref lavu_murmur3_seedinfo "Detailed description" on a discussion of
  /// seeds for MurmurHash3.
  void av_murmur3_init_seeded(
    ffi.Pointer<AVMurMur3> c,
    int seed,
  ) {
    return _av_murmur3_init_seeded(
      c,
      seed,
    );
  }

  late final _av_murmur3_init_seededPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVMurMur3>, ffi.Uint64)>>('av_murmur3_init_seeded');
  late final _av_murmur3_init_seeded = _av_murmur3_init_seededPtr
      .asFunction<void Function(ffi.Pointer<AVMurMur3>, int)>();

  /// Initialize or reinitialize an AVMurMur3 hash context.
  ///
  /// Equivalent to av_murmur3_init_seeded() with a built-in seed.
  ///
  /// @param[out] c    Hash context
  ///
  /// @see av_murmur3_init_seeded()
  /// @see @ref lavu_murmur3_seedinfo "Detailed description" on a discussion of
  /// seeds for MurmurHash3.
  void av_murmur3_init(
    ffi.Pointer<AVMurMur3> c,
  ) {
    return _av_murmur3_init(
      c,
    );
  }

  late final _av_murmur3_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVMurMur3>)>>(
          'av_murmur3_init');
  late final _av_murmur3_init =
      _av_murmur3_initPtr.asFunction<void Function(ffi.Pointer<AVMurMur3>)>();

  /// Update hash context with new data.
  ///
  /// @param[out] c    Hash context
  /// @param[in]  src  Input data to update hash with
  /// @param[in]  len  Number of bytes to read from `src`
  void av_murmur3_update(
    ffi.Pointer<AVMurMur3> c,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    return _av_murmur3_update(
      c,
      src,
      len,
    );
  }

  late final _av_murmur3_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVMurMur3>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_murmur3_update');
  late final _av_murmur3_update = _av_murmur3_updatePtr.asFunction<
      void Function(ffi.Pointer<AVMurMur3>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finish hashing and output digest value.
  ///
  /// @param[in,out] c    Hash context
  /// @param[out]    dst  Buffer where output digest value is stored
  void av_murmur3_final(
    ffi.Pointer<AVMurMur3> c,
    ffi.Pointer<ffi.Uint8> dst,
  ) {
    return _av_murmur3_final(
      c,
      dst,
    );
  }

  late final _av_murmur3_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVMurMur3>,
              ffi.Pointer<ffi.Uint8>)>>('av_murmur3_final');
  late final _av_murmur3_final = _av_murmur3_finalPtr.asFunction<
      void Function(ffi.Pointer<AVMurMur3>, ffi.Pointer<ffi.Uint8>)>();

  /// Allocate an AVStereo3D structure and set its fields to default values.
  /// The resulting struct can be freed using av_freep().
  ///
  /// @return An AVStereo3D filled with default values or NULL on failure.
  ffi.Pointer<AVStereo3D> av_stereo3d_alloc() {
    return _av_stereo3d_alloc();
  }

  late final _av_stereo3d_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVStereo3D> Function()>>(
          'av_stereo3d_alloc');
  late final _av_stereo3d_alloc =
      _av_stereo3d_allocPtr.asFunction<ffi.Pointer<AVStereo3D> Function()>();

  /// Allocate an AVStereo3D structure and set its fields to default values.
  /// The resulting struct can be freed using av_freep().
  ///
  /// @return An AVStereo3D filled with default values or NULL on failure.
  ffi.Pointer<AVStereo3D> av_stereo3d_alloc_size(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_stereo3d_alloc_size(
      size,
    );
  }

  late final _av_stereo3d_alloc_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVStereo3D> Function(
              ffi.Pointer<ffi.Size>)>>('av_stereo3d_alloc_size');
  late final _av_stereo3d_alloc_size = _av_stereo3d_alloc_sizePtr
      .asFunction<ffi.Pointer<AVStereo3D> Function(ffi.Pointer<ffi.Size>)>();

  /// Allocate a complete AVFrameSideData and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVStereo3D structure to be filled by caller.
  ffi.Pointer<AVStereo3D> av_stereo3d_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_stereo3d_create_side_data(
      frame,
    );
  }

  late final _av_stereo3d_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVStereo3D> Function(
              ffi.Pointer<AVFrame>)>>('av_stereo3d_create_side_data');
  late final _av_stereo3d_create_side_data = _av_stereo3d_create_side_dataPtr
      .asFunction<ffi.Pointer<AVStereo3D> Function(ffi.Pointer<AVFrame>)>();

  /// Provide a human-readable name of a given stereo3d type.
  ///
  /// @param type The input stereo3d type value.
  ///
  /// @return The name of the stereo3d value, or "unknown".
  ffi.Pointer<ffi.Char> av_stereo3d_type_name(
    int type,
  ) {
    return _av_stereo3d_type_name(
      type,
    );
  }

  late final _av_stereo3d_type_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_stereo3d_type_name');
  late final _av_stereo3d_type_name = _av_stereo3d_type_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the AVStereo3DType form a human-readable name.
  ///
  /// @param name The input string.
  ///
  /// @return The AVStereo3DType value, or -1 if not found.
  int av_stereo3d_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_stereo3d_from_name(
      name,
    );
  }

  late final _av_stereo3d_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_stereo3d_from_name');
  late final _av_stereo3d_from_name = _av_stereo3d_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Provide a human-readable name of a given stereo3d view.
  ///
  /// @param type The input stereo3d view value.
  ///
  /// @return The name of the stereo3d view value, or "unknown".
  ffi.Pointer<ffi.Char> av_stereo3d_view_name(
    int view,
  ) {
    return _av_stereo3d_view_name(
      view,
    );
  }

  late final _av_stereo3d_view_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_stereo3d_view_name');
  late final _av_stereo3d_view_name = _av_stereo3d_view_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the AVStereo3DView form a human-readable name.
  ///
  /// @param name The input string.
  ///
  /// @return The AVStereo3DView value, or -1 if not found.
  int av_stereo3d_view_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_stereo3d_view_from_name(
      name,
    );
  }

  late final _av_stereo3d_view_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_stereo3d_view_from_name');
  late final _av_stereo3d_view_from_name = _av_stereo3d_view_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Provide a human-readable name of a given stereo3d primary eye.
  ///
  /// @param type The input stereo3d primary eye value.
  ///
  /// @return The name of the stereo3d primary eye value, or "unknown".
  ffi.Pointer<ffi.Char> av_stereo3d_primary_eye_name(
    int eye,
  ) {
    return _av_stereo3d_primary_eye_name(
      eye,
    );
  }

  late final _av_stereo3d_primary_eye_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_stereo3d_primary_eye_name');
  late final _av_stereo3d_primary_eye_name = _av_stereo3d_primary_eye_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the AVStereo3DPrimaryEye form a human-readable name.
  ///
  /// @param name The input string.
  ///
  /// @return The AVStereo3DPrimaryEye value, or -1 if not found.
  int av_stereo3d_primary_eye_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_stereo3d_primary_eye_from_name(
      name,
    );
  }

  late final _av_stereo3d_primary_eye_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_stereo3d_primary_eye_from_name');
  late final _av_stereo3d_primary_eye_from_name =
      _av_stereo3d_primary_eye_from_namePtr
          .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Return the number of bits per pixel used by the pixel format
  /// described by pixdesc. Note that this is not the same as the number
  /// of bits per sample.
  ///
  /// The returned number of bits refers to the number of bits actually
  /// used for storing the pixel information, that is padding bits are
  /// not counted.
  int av_get_bits_per_pixel(
    ffi.Pointer<AVPixFmtDescriptor> pixdesc,
  ) {
    return _av_get_bits_per_pixel(
      pixdesc,
    );
  }

  late final _av_get_bits_per_pixelPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVPixFmtDescriptor>)>>(
      'av_get_bits_per_pixel');
  late final _av_get_bits_per_pixel = _av_get_bits_per_pixelPtr
      .asFunction<int Function(ffi.Pointer<AVPixFmtDescriptor>)>();

  /// Return the number of bits per pixel for the pixel format
  /// described by pixdesc, including any padding or unused bits.
  int av_get_padded_bits_per_pixel(
    ffi.Pointer<AVPixFmtDescriptor> pixdesc,
  ) {
    return _av_get_padded_bits_per_pixel(
      pixdesc,
    );
  }

  late final _av_get_padded_bits_per_pixelPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVPixFmtDescriptor>)>>(
      'av_get_padded_bits_per_pixel');
  late final _av_get_padded_bits_per_pixel = _av_get_padded_bits_per_pixelPtr
      .asFunction<int Function(ffi.Pointer<AVPixFmtDescriptor>)>();

  /// @return a pixel format descriptor for provided pixel format or NULL if
  /// this pixel format is unknown.
  ffi.Pointer<AVPixFmtDescriptor> av_pix_fmt_desc_get(
    AVPixelFormat pix_fmt,
  ) {
    return _av_pix_fmt_desc_get(
      pix_fmt.value,
    );
  }

  late final _av_pix_fmt_desc_getPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<AVPixFmtDescriptor> Function(ffi.Int)>>(
      'av_pix_fmt_desc_get');
  late final _av_pix_fmt_desc_get = _av_pix_fmt_desc_getPtr
      .asFunction<ffi.Pointer<AVPixFmtDescriptor> Function(int)>();

  /// Iterate over all pixel format descriptors known to libavutil.
  ///
  /// @param prev previous descriptor. NULL to get the first descriptor.
  ///
  /// @return next descriptor or NULL after the last descriptor
  ffi.Pointer<AVPixFmtDescriptor> av_pix_fmt_desc_next(
    ffi.Pointer<AVPixFmtDescriptor> prev,
  ) {
    return _av_pix_fmt_desc_next(
      prev,
    );
  }

  late final _av_pix_fmt_desc_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVPixFmtDescriptor> Function(
              ffi.Pointer<AVPixFmtDescriptor>)>>('av_pix_fmt_desc_next');
  late final _av_pix_fmt_desc_next = _av_pix_fmt_desc_nextPtr.asFunction<
      ffi.Pointer<AVPixFmtDescriptor> Function(
          ffi.Pointer<AVPixFmtDescriptor>)>();

  /// @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc
  /// is not a valid pointer to a pixel format descriptor.
  AVPixelFormat av_pix_fmt_desc_get_id(
    ffi.Pointer<AVPixFmtDescriptor> desc,
  ) {
    return AVPixelFormat.fromValue(_av_pix_fmt_desc_get_id(
      desc,
    ));
  }

  late final _av_pix_fmt_desc_get_idPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVPixFmtDescriptor>)>>(
      'av_pix_fmt_desc_get_id');
  late final _av_pix_fmt_desc_get_id = _av_pix_fmt_desc_get_idPtr
      .asFunction<int Function(ffi.Pointer<AVPixFmtDescriptor>)>();

  /// Utility function to access log2_chroma_w log2_chroma_h from
  /// the pixel format AVPixFmtDescriptor.
  ///
  /// @param[in]  pix_fmt the pixel format
  /// @param[out] h_shift store log2_chroma_w (horizontal/width shift)
  /// @param[out] v_shift store log2_chroma_h (vertical/height shift)
  ///
  /// @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
  int av_pix_fmt_get_chroma_sub_sample(
    AVPixelFormat pix_fmt,
    ffi.Pointer<ffi.Int> h_shift,
    ffi.Pointer<ffi.Int> v_shift,
  ) {
    return _av_pix_fmt_get_chroma_sub_sample(
      pix_fmt.value,
      h_shift,
      v_shift,
    );
  }

  late final _av_pix_fmt_get_chroma_sub_samplePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('av_pix_fmt_get_chroma_sub_sample');
  late final _av_pix_fmt_get_chroma_sub_sample =
      _av_pix_fmt_get_chroma_sub_samplePtr.asFunction<
          int Function(int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
  /// valid pixel format.
  int av_pix_fmt_count_planes(
    AVPixelFormat pix_fmt,
  ) {
    return _av_pix_fmt_count_planes(
      pix_fmt.value,
    );
  }

  late final _av_pix_fmt_count_planesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'av_pix_fmt_count_planes');
  late final _av_pix_fmt_count_planes =
      _av_pix_fmt_count_planesPtr.asFunction<int Function(int)>();

  /// @return the name for provided color range or NULL if unknown.
  ffi.Pointer<ffi.Char> av_color_range_name(
    AVColorRange range,
  ) {
    return _av_color_range_name(
      range.value,
    );
  }

  late final _av_color_range_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_color_range_name');
  late final _av_color_range_name =
      _av_color_range_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @return the AVColorRange value for name or an AVError if not found.
  int av_color_range_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_color_range_from_name(
      name,
    );
  }

  late final _av_color_range_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_color_range_from_name');
  late final _av_color_range_from_name = _av_color_range_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @return the name for provided color primaries or NULL if unknown.
  ffi.Pointer<ffi.Char> av_color_primaries_name(
    AVColorPrimaries primaries,
  ) {
    return _av_color_primaries_name(
      primaries.value,
    );
  }

  late final _av_color_primaries_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_color_primaries_name');
  late final _av_color_primaries_name = _av_color_primaries_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @return the AVColorPrimaries value for name or an AVError if not found.
  int av_color_primaries_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_color_primaries_from_name(
      name,
    );
  }

  late final _av_color_primaries_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_color_primaries_from_name');
  late final _av_color_primaries_from_name = _av_color_primaries_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @return the name for provided color transfer or NULL if unknown.
  ffi.Pointer<ffi.Char> av_color_transfer_name(
    AVColorTransferCharacteristic transfer,
  ) {
    return _av_color_transfer_name(
      transfer.value,
    );
  }

  late final _av_color_transfer_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_color_transfer_name');
  late final _av_color_transfer_name = _av_color_transfer_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @return the AVColorTransferCharacteristic value for name or an AVError if not found.
  int av_color_transfer_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_color_transfer_from_name(
      name,
    );
  }

  late final _av_color_transfer_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_color_transfer_from_name');
  late final _av_color_transfer_from_name = _av_color_transfer_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @return the name for provided color space or NULL if unknown.
  ffi.Pointer<ffi.Char> av_color_space_name(
    AVColorSpace space,
  ) {
    return _av_color_space_name(
      space.value,
    );
  }

  late final _av_color_space_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_color_space_name');
  late final _av_color_space_name =
      _av_color_space_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @return the AVColorSpace value for name or an AVError if not found.
  int av_color_space_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_color_space_from_name(
      name,
    );
  }

  late final _av_color_space_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_color_space_from_name');
  late final _av_color_space_from_name = _av_color_space_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// @return the name for provided chroma location or NULL if unknown.
  ffi.Pointer<ffi.Char> av_chroma_location_name(
    AVChromaLocation location,
  ) {
    return _av_chroma_location_name(
      location.value,
    );
  }

  late final _av_chroma_location_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_chroma_location_name');
  late final _av_chroma_location_name = _av_chroma_location_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// @return the AVChromaLocation value for name or an AVError if not found.
  int av_chroma_location_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_chroma_location_from_name(
      name,
    );
  }

  late final _av_chroma_location_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_chroma_location_from_name');
  late final _av_chroma_location_from_name = _av_chroma_location_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Converts AVChromaLocation to swscale x/y chroma position.
  ///
  /// The positions represent the chroma (0,0) position in a coordinates system
  /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
  ///
  /// @param xpos  horizontal chroma sample position
  /// @param ypos  vertical   chroma sample position
  int av_chroma_location_enum_to_pos(
    ffi.Pointer<ffi.Int> xpos,
    ffi.Pointer<ffi.Int> ypos,
    AVChromaLocation pos,
  ) {
    return _av_chroma_location_enum_to_pos(
      xpos,
      ypos,
      pos.value,
    );
  }

  late final _av_chroma_location_enum_to_posPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.UnsignedInt)>>('av_chroma_location_enum_to_pos');
  late final _av_chroma_location_enum_to_pos =
      _av_chroma_location_enum_to_posPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, int)>();

  /// Converts swscale x/y chroma position to AVChromaLocation.
  ///
  /// The positions represent the chroma (0,0) position in a coordinates system
  /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
  ///
  /// @param xpos  horizontal chroma sample position
  /// @param ypos  vertical   chroma sample position
  AVChromaLocation av_chroma_location_pos_to_enum(
    int xpos,
    int ypos,
  ) {
    return AVChromaLocation.fromValue(_av_chroma_location_pos_to_enum(
      xpos,
      ypos,
    ));
  }

  late final _av_chroma_location_pos_to_enumPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int, ffi.Int)>>(
          'av_chroma_location_pos_to_enum');
  late final _av_chroma_location_pos_to_enum =
      _av_chroma_location_pos_to_enumPtr.asFunction<int Function(int, int)>();

  /// Return the pixel format corresponding to name.
  ///
  /// If there is no pixel format with name name, then looks for a
  /// pixel format with the name corresponding to the native endian
  /// format of name.
  /// For example in a little-endian system, first looks for "gray16",
  /// then for "gray16le".
  ///
  /// Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.
  AVPixelFormat av_get_pix_fmt(
    ffi.Pointer<ffi.Char> name,
  ) {
    return AVPixelFormat.fromValue(_av_get_pix_fmt(
      name,
    ));
  }

  late final _av_get_pix_fmtPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_get_pix_fmt');
  late final _av_get_pix_fmt =
      _av_get_pix_fmtPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Return the short name for a pixel format, NULL in case pix_fmt is
  /// unknown.
  ///
  /// @see av_get_pix_fmt(), av_get_pix_fmt_string()
  ffi.Pointer<ffi.Char> av_get_pix_fmt_name(
    AVPixelFormat pix_fmt,
  ) {
    return _av_get_pix_fmt_name(
      pix_fmt.value,
    );
  }

  late final _av_get_pix_fmt_namePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'av_get_pix_fmt_name');
  late final _av_get_pix_fmt_name =
      _av_get_pix_fmt_namePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Print in buf the string corresponding to the pixel format with
  /// number pix_fmt, or a header if pix_fmt is negative.
  ///
  /// @param buf the buffer where to write the string
  /// @param buf_size the size of buf
  /// @param pix_fmt the number of the pixel format to print the
  /// corresponding info string, or a negative value to print the
  /// corresponding header.
  ffi.Pointer<ffi.Char> av_get_pix_fmt_string(
    ffi.Pointer<ffi.Char> buf,
    int buf_size,
    AVPixelFormat pix_fmt,
  ) {
    return _av_get_pix_fmt_string(
      buf,
      buf_size,
      pix_fmt.value,
    );
  }

  late final _av_get_pix_fmt_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Int)>>('av_get_pix_fmt_string');
  late final _av_get_pix_fmt_string = _av_get_pix_fmt_stringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Read a line from an image, and write the values of the
  /// pixel format component c to dst.
  ///
  /// @param data the array containing the pointers to the planes of the image
  /// @param linesize the array containing the linesizes of the image
  /// @param desc the pixel format descriptor for the image
  /// @param x the horizontal coordinate of the first pixel to read
  /// @param y the vertical coordinate of the first pixel to read
  /// @param w the width of the line to read, that is the number of
  /// values to write to dst
  /// @param read_pal_component if not zero and the format is a paletted
  /// format writes the values corresponding to the palette
  /// component c in data[1] to dst, rather than the palette indexes in
  /// data[0]. The behavior is undefined if the format is not paletted.
  /// @param dst_element_size size of elements in dst array (2 or 4 byte)
  void av_read_image_line2(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
    int read_pal_component,
    int dst_element_size,
  ) {
    return _av_read_image_line2(
      dst,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
      read_pal_component,
      dst_element_size,
    );
  }

  late final _av_read_image_line2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPixFmtDescriptor>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_read_image_line2');
  late final _av_read_image_line2 = _av_read_image_line2Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<AVPixFmtDescriptor>,
          int,
          int,
          int,
          int,
          int,
          int)>();

  void av_read_image_line(
    ffi.Pointer<ffi.Uint16> dst,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
    int read_pal_component,
  ) {
    return _av_read_image_line(
      dst,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
      read_pal_component,
    );
  }

  late final _av_read_image_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPixFmtDescriptor>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_read_image_line');
  late final _av_read_image_line = _av_read_image_linePtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Uint16>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<AVPixFmtDescriptor>,
          int,
          int,
          int,
          int,
          int)>();

  /// Write the values from src to the pixel format component c of an
  /// image line.
  ///
  /// @param src array containing the values to write
  /// @param data the array containing the pointers to the planes of the
  /// image to write into. It is supposed to be zeroed.
  /// @param linesize the array containing the linesizes of the image
  /// @param desc the pixel format descriptor for the image
  /// @param x the horizontal coordinate of the first pixel to write
  /// @param y the vertical coordinate of the first pixel to write
  /// @param w the width of the line to write, that is the number of
  /// values to write to the image line
  /// @param src_element_size size of elements in src array (2 or 4 byte)
  void av_write_image_line2(
    ffi.Pointer<ffi.Void> src,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
    int src_element_size,
  ) {
    return _av_write_image_line2(
      src,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
      src_element_size,
    );
  }

  late final _av_write_image_line2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPixFmtDescriptor>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_write_image_line2');
  late final _av_write_image_line2 = _av_write_image_line2Ptr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<AVPixFmtDescriptor>,
          int,
          int,
          int,
          int,
          int)>();

  void av_write_image_line(
    ffi.Pointer<ffi.Uint16> src,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
  ) {
    return _av_write_image_line(
      src,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
    );
  }

  late final _av_write_image_linePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint16>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPixFmtDescriptor>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_write_image_line');
  late final _av_write_image_line = _av_write_image_linePtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Uint16>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<AVPixFmtDescriptor>,
          int,
          int,
          int,
          int)>();

  /// Utility function to swap the endianness of a pixel format.
  ///
  /// @param[in]  pix_fmt the pixel format
  ///
  /// @return pixel format with swapped endianness if it exists,
  /// otherwise AV_PIX_FMT_NONE
  AVPixelFormat av_pix_fmt_swap_endianness(
    AVPixelFormat pix_fmt,
  ) {
    return AVPixelFormat.fromValue(_av_pix_fmt_swap_endianness(
      pix_fmt.value,
    ));
  }

  late final _av_pix_fmt_swap_endiannessPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'av_pix_fmt_swap_endianness');
  late final _av_pix_fmt_swap_endianness =
      _av_pix_fmt_swap_endiannessPtr.asFunction<int Function(int)>();

  /// Compute what kind of losses will occur when converting from one specific
  /// pixel format to another.
  /// When converting from one pixel format to another, information loss may occur.
  /// For example, when converting from RGB24 to GRAY, the color information will
  /// be lost. Similarly, other losses occur when converting from some formats to
  /// other formats. These losses can involve loss of chroma, but also loss of
  /// resolution, loss of color depth, loss due to the color space conversion, loss
  /// of the alpha bits or loss due to color quantization.
  /// av_get_fix_fmt_loss() informs you about the various types of losses
  /// which will occur when converting from one pixel format to another.
  ///
  /// @param[in] dst_pix_fmt destination pixel format
  /// @param[in] src_pix_fmt source pixel format
  /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
  /// @return Combination of flags informing you what kind of losses will occur
  /// (maximum loss for an invalid dst_pix_fmt).
  int av_get_pix_fmt_loss(
    AVPixelFormat dst_pix_fmt,
    AVPixelFormat src_pix_fmt,
    int has_alpha,
  ) {
    return _av_get_pix_fmt_loss(
      dst_pix_fmt.value,
      src_pix_fmt.value,
      has_alpha,
    );
  }

  late final _av_get_pix_fmt_lossPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'av_get_pix_fmt_loss');
  late final _av_get_pix_fmt_loss =
      _av_get_pix_fmt_lossPtr.asFunction<int Function(int, int, int)>();

  /// Compute what kind of losses will occur when converting from one specific
  /// pixel format to another.
  /// When converting from one pixel format to another, information loss may occur.
  /// For example, when converting from RGB24 to GRAY, the color information will
  /// be lost. Similarly, other losses occur when converting from some formats to
  /// other formats. These losses can involve loss of chroma, but also loss of
  /// resolution, loss of color depth, loss due to the color space conversion, loss
  /// of the alpha bits or loss due to color quantization.
  /// av_get_fix_fmt_loss() informs you about the various types of losses
  /// which will occur when converting from one pixel format to another.
  ///
  /// @param[in] dst_pix_fmt destination pixel format
  /// @param[in] src_pix_fmt source pixel format
  /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
  /// @return Combination of flags informing you what kind of losses will occur
  /// (maximum loss for an invalid dst_pix_fmt).
  AVPixelFormat av_find_best_pix_fmt_of_2(
    AVPixelFormat dst_pix_fmt1,
    AVPixelFormat dst_pix_fmt2,
    AVPixelFormat src_pix_fmt,
    int has_alpha,
    ffi.Pointer<ffi.Int> loss_ptr,
  ) {
    return AVPixelFormat.fromValue(_av_find_best_pix_fmt_of_2(
      dst_pix_fmt1.value,
      dst_pix_fmt2.value,
      src_pix_fmt.value,
      has_alpha,
      loss_ptr,
    ));
  }

  late final _av_find_best_pix_fmt_of_2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Int>)>>('av_find_best_pix_fmt_of_2');
  late final _av_find_best_pix_fmt_of_2 = _av_find_best_pix_fmt_of_2Ptr
      .asFunction<int Function(int, int, int, int, ffi.Pointer<ffi.Int>)>();

  /// Decode a base64-encoded string.
  ///
  /// @param out      buffer for decoded data
  /// @param in       null-terminated input string
  /// @param out_size size in bytes of the out buffer, must be at
  /// least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))
  /// @return         number of bytes written, or a negative value in case of
  /// invalid input
  int av_base64_decode(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Char> in1,
    int out_size,
  ) {
    return _av_base64_decode(
      out,
      in1,
      out_size,
    );
  }

  late final _av_base64_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_base64_decode');
  late final _av_base64_decode = _av_base64_decodePtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Char>, int)>();

  /// Encode data to base64 and null-terminate.
  ///
  /// @param out      buffer for encoded data
  /// @param out_size size in bytes of the out buffer (including the
  /// null terminator), must be at least AV_BASE64_SIZE(in_size)
  /// @param in       input buffer containing the data to encode
  /// @param in_size  size in bytes of the in buffer
  /// @return         out or NULL in case of error
  ffi.Pointer<ffi.Char> av_base64_encode(
    ffi.Pointer<ffi.Char> out,
    int out_size,
    ffi.Pointer<ffi.Uint8> in1,
    int in_size,
  ) {
    return _av_base64_encode(
      out,
      out_size,
      in1,
      in_size,
    );
  }

  late final _av_base64_encodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('av_base64_encode');
  late final _av_base64_encode = _av_base64_encodePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// @defgroup lavu_sha SHA
  /// @ingroup lavu_hash
  /// SHA-1 and SHA-256 (Secure Hash Algorithm) hash function implementations.
  ///
  /// This module supports the following SHA hash functions:
  ///
  /// - SHA-1: 160 bits
  /// - SHA-224: 224 bits, as a variant of SHA-2
  /// - SHA-256: 256 bits, as a variant of SHA-2
  ///
  /// @see For SHA-384, SHA-512, and variants thereof, see @ref lavu_sha512.
  ///
  /// @{
  late final ffi.Pointer<ffi.Int> _av_sha_size =
      _lookup<ffi.Int>('av_sha_size');

  int get av_sha_size => _av_sha_size.value;

  /// Allocate an AVSHA context.
  ffi.Pointer<AVSHA> av_sha_alloc() {
    return _av_sha_alloc();
  }

  late final _av_sha_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVSHA> Function()>>(
          'av_sha_alloc');
  late final _av_sha_alloc =
      _av_sha_allocPtr.asFunction<ffi.Pointer<AVSHA> Function()>();

  /// Initialize SHA-1 or SHA-2 hashing.
  ///
  /// @param context pointer to the function context (of size av_sha_size)
  /// @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)
  /// @return        zero if initialization succeeded, -1 otherwise
  int av_sha_init(
    ffi.Pointer<AVSHA> context,
    int bits,
  ) {
    return _av_sha_init(
      context,
      bits,
    );
  }

  late final _av_sha_initPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVSHA>, ffi.Int)>>(
      'av_sha_init');
  late final _av_sha_init =
      _av_sha_initPtr.asFunction<int Function(ffi.Pointer<AVSHA>, int)>();

  /// Update hash value.
  ///
  /// @param ctx     hash function context
  /// @param data    input data to update hash with
  /// @param len     input data length
  void av_sha_update(
    ffi.Pointer<AVSHA> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _av_sha_update(
      ctx,
      data,
      len,
    );
  }

  late final _av_sha_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVSHA>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_sha_update');
  late final _av_sha_update = _av_sha_updatePtr.asFunction<
      void Function(ffi.Pointer<AVSHA>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finish hashing and output digest value.
  ///
  /// @param context hash function context
  /// @param digest  buffer where output digest value is stored
  void av_sha_final(
    ffi.Pointer<AVSHA> context,
    ffi.Pointer<ffi.Uint8> digest,
  ) {
    return _av_sha_final(
      context,
      digest,
    );
  }

  late final _av_sha_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVSHA>, ffi.Pointer<ffi.Uint8>)>>('av_sha_final');
  late final _av_sha_final = _av_sha_finalPtr
      .asFunction<void Function(ffi.Pointer<AVSHA>, ffi.Pointer<ffi.Uint8>)>();

  /// Parses a string representation of a UUID formatted according to IETF RFC 4122
  /// into an AVUUID. The parsing is case-insensitive. The string must be 37
  /// characters long, including the terminating NUL character.
  ///
  /// Example string representation: "2fceebd0-7017-433d-bafb-d073a7116696"
  ///
  /// @param[in]  in  String representation of a UUID,
  /// e.g. 2fceebd0-7017-433d-bafb-d073a7116696
  /// @param[out] uu  AVUUID
  /// @return         A non-zero value in case of an error.
  int av_uuid_parse(
    ffi.Pointer<ffi.Char> in1,
    ffi.Pointer<ffi.Uint8> uu,
  ) {
    return _av_uuid_parse(
      in1,
      uu,
    );
  }

  late final _av_uuid_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint8>)>>('av_uuid_parse');
  late final _av_uuid_parse = _av_uuid_parsePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint8>)>();

  /// Parses a URN representation of a UUID, as specified at IETF RFC 4122,
  /// into an AVUUID. The parsing is case-insensitive. The string must be 46
  /// characters long, including the terminating NUL character.
  ///
  /// Example string representation: "urn:uuid:2fceebd0-7017-433d-bafb-d073a7116696"
  ///
  /// @param[in]  in  URN UUID
  /// @param[out] uu  AVUUID
  /// @return         A non-zero value in case of an error.
  int av_uuid_urn_parse(
    ffi.Pointer<ffi.Char> in1,
    ffi.Pointer<ffi.Uint8> uu,
  ) {
    return _av_uuid_urn_parse(
      in1,
      uu,
    );
  }

  late final _av_uuid_urn_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>)>>('av_uuid_urn_parse');
  late final _av_uuid_urn_parse = _av_uuid_urn_parsePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Uint8>)>();

  /// Parses a string representation of a UUID formatted according to IETF RFC 4122
  /// into an AVUUID. The parsing is case-insensitive.
  ///
  /// @param[in]  in_start Pointer to the first character of the string representation
  /// @param[in]  in_end   Pointer to the character after the last character of the
  /// string representation. That memory location is never
  /// accessed. It is an error if `in_end - in_start != 36`.
  /// @param[out] uu       AVUUID
  /// @return              A non-zero value in case of an error.
  int av_uuid_parse_range(
    ffi.Pointer<ffi.Char> in_start,
    ffi.Pointer<ffi.Char> in_end,
    ffi.Pointer<ffi.Uint8> uu,
  ) {
    return _av_uuid_parse_range(
      in_start,
      in_end,
      uu,
    );
  }

  late final _av_uuid_parse_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Uint8>)>>('av_uuid_parse_range');
  late final _av_uuid_parse_range = _av_uuid_parse_rangePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Uint8>)>();

  /// Serializes a AVUUID into a string representation according to IETF RFC 4122.
  /// The string is lowercase and always 37 characters long, including the
  /// terminating NUL character.
  ///
  /// @param[in]  uu  AVUUID
  /// @param[out] out Pointer to an array of no less than 37 characters.
  void av_uuid_unparse(
    ffi.Pointer<ffi.Uint8> uu,
    ffi.Pointer<ffi.Char> out,
  ) {
    return _av_uuid_unparse(
      uu,
      out,
    );
  }

  late final _av_uuid_unparsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Char>)>>('av_uuid_unparse');
  late final _av_uuid_unparse = _av_uuid_unparsePtr.asFunction<
      void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Char>)>();

  void av_lfg_init(
    ffi.Pointer<AVLFG> c,
    int seed,
  ) {
    return _av_lfg_init(
      c,
      seed,
    );
  }

  late final _av_lfg_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVLFG>, ffi.UnsignedInt)>>('av_lfg_init');
  late final _av_lfg_init =
      _av_lfg_initPtr.asFunction<void Function(ffi.Pointer<AVLFG>, int)>();

  /// Seed the state of the ALFG using binary data.
  ///
  /// @return 0 on success, negative value (AVERROR) on failure.
  int av_lfg_init_from_data(
    ffi.Pointer<AVLFG> c,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    return _av_lfg_init_from_data(
      c,
      data,
      length,
    );
  }

  late final _av_lfg_init_from_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVLFG>, ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt)>>('av_lfg_init_from_data');
  late final _av_lfg_init_from_data = _av_lfg_init_from_dataPtr.asFunction<
      int Function(ffi.Pointer<AVLFG>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the next two numbers generated by a Box-Muller Gaussian
  /// generator using the random numbers issued by lfg.
  ///
  /// @param lfg pointer to the contex structure
  /// @param out array where the two generated numbers are placed
  void av_bmg_get(
    ffi.Pointer<AVLFG> lfg,
    ffi.Pointer<ffi.Double> out,
  ) {
    return _av_bmg_get(
      lfg,
      out,
    );
  }

  late final _av_bmg_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVLFG>, ffi.Pointer<ffi.Double>)>>('av_bmg_get');
  late final _av_bmg_get = _av_bmg_getPtr
      .asFunction<void Function(ffi.Pointer<AVLFG>, ffi.Pointer<ffi.Double>)>();

  /// Allocate an AVXTEA context.
  ffi.Pointer<AVXTEA> av_xtea_alloc() {
    return _av_xtea_alloc();
  }

  late final _av_xtea_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVXTEA> Function()>>(
          'av_xtea_alloc');
  late final _av_xtea_alloc =
      _av_xtea_allocPtr.asFunction<ffi.Pointer<AVXTEA> Function()>();

  /// Initialize an AVXTEA context.
  ///
  /// @param ctx an AVXTEA context
  /// @param key a key of 16 bytes used for encryption/decryption,
  /// interpreted as big endian 32 bit numbers
  void av_xtea_init(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> key,
  ) {
    return _av_xtea_init(
      ctx,
      key,
    );
  }

  late final _av_xtea_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVXTEA>, ffi.Pointer<ffi.Uint8>)>>('av_xtea_init');
  late final _av_xtea_init = _av_xtea_initPtr
      .asFunction<void Function(ffi.Pointer<AVXTEA>, ffi.Pointer<ffi.Uint8>)>();

  /// Initialize an AVXTEA context.
  ///
  /// @param ctx an AVXTEA context
  /// @param key a key of 16 bytes used for encryption/decryption,
  /// interpreted as little endian 32 bit numbers
  void av_xtea_le_init(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> key,
  ) {
    return _av_xtea_le_init(
      ctx,
      key,
    );
  }

  late final _av_xtea_le_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVXTEA>, ffi.Pointer<ffi.Uint8>)>>('av_xtea_le_init');
  late final _av_xtea_le_init = _av_xtea_le_initPtr
      .asFunction<void Function(ffi.Pointer<AVXTEA>, ffi.Pointer<ffi.Uint8>)>();

  /// Encrypt or decrypt a buffer using a previously initialized context,
  /// in big endian format.
  ///
  /// @param ctx an AVXTEA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_xtea_crypt(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_xtea_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_xtea_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVXTEA>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_xtea_crypt');
  late final _av_xtea_crypt = _av_xtea_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVXTEA>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context,
  /// in little endian format.
  ///
  /// @param ctx an AVXTEA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_xtea_le_crypt(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_xtea_le_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_xtea_le_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVXTEA>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_xtea_le_crypt');
  late final _av_xtea_le_crypt = _av_xtea_le_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVXTEA>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Initialize a CRC table.
  /// @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024
  /// @param le If 1, the lowest bit represents the coefficient for the highest
  /// exponent of the corresponding polynomial (both for poly and
  /// actual CRC).
  /// If 0, you must swap the CRC parameter and the result of av_crc
  /// if you need the standard representation (can be simplified in
  /// most cases to e.g. bswap16):
  /// av_bswap32(crc << (32-bits))
  /// @param bits number of bits for the CRC
  /// @param poly generator polynomial without the x**bits coefficient, in the
  /// representation as specified by le
  /// @param ctx_size size of ctx in bytes
  /// @return <0 on failure
  int av_crc_init(
    ffi.Pointer<AVCRC> ctx,
    int le,
    int bits,
    int poly,
    int ctx_size,
  ) {
    return _av_crc_init(
      ctx,
      le,
      bits,
      poly,
      ctx_size,
    );
  }

  late final _av_crc_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCRC>, ffi.Int, ffi.Int, ffi.Uint32,
              ffi.Int)>>('av_crc_init');
  late final _av_crc_init = _av_crc_initPtr
      .asFunction<int Function(ffi.Pointer<AVCRC>, int, int, int, int)>();

  /// Get an initialized standard CRC table.
  /// @param crc_id ID of a standard CRC
  /// @return a pointer to the CRC table or NULL on failure
  ffi.Pointer<AVCRC> av_crc_get_table(
    AVCRCId crc_id,
  ) {
    return _av_crc_get_table(
      crc_id.value,
    );
  }

  late final _av_crc_get_tablePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCRC> Function(ffi.UnsignedInt)>>(
          'av_crc_get_table');
  late final _av_crc_get_table =
      _av_crc_get_tablePtr.asFunction<ffi.Pointer<AVCRC> Function(int)>();

  /// Calculate the CRC of a block.
  /// @param ctx initialized AVCRC array (see av_crc_init())
  /// @param crc CRC of previous blocks if any or initial value for CRC
  /// @param buffer buffer whose CRC to calculate
  /// @param length length of the buffer
  /// @return CRC updated with the data from the given block
  ///
  /// @see av_crc_init() "le" parameter
  int av_crc(
    ffi.Pointer<AVCRC> ctx,
    int crc,
    ffi.Pointer<ffi.Uint8> buffer,
    int length,
  ) {
    return _av_crc(
      ctx,
      crc,
      buffer,
      length,
    );
  }

  late final _av_crcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<AVCRC>, ffi.Uint32,
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('av_crc');
  late final _av_crc = _av_crcPtr.asFunction<
      int Function(ffi.Pointer<AVCRC>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Read the file with name filename, and put its content in a newly
  /// allocated buffer or map it with mmap() when available.
  /// In case of success set *bufptr to the read or mmapped buffer, and
  /// *size to the size in bytes of the buffer in *bufptr.
  /// Unlike mmap this function succeeds with zero sized files, in this
  /// case *bufptr will be set to NULL and *size will be set to 0.
  /// The returned buffer must be released with av_file_unmap().
  ///
  /// @param filename path to the file
  /// @param[out] bufptr pointee is set to the mapped or allocated buffer
  /// @param[out] size pointee is set to the size in bytes of the buffer
  /// @param log_offset loglevel offset used for logging
  /// @param log_ctx context used for logging
  /// @return a non negative number in case of success, a negative value
  /// corresponding to an AVERROR error code in case of failure
  int av_file_map(
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufptr,
    ffi.Pointer<ffi.Size> size,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_file_map(
      filename,
      bufptr,
      size,
      log_offset,
      log_ctx,
    );
  }

  late final _av_file_mapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('av_file_map');
  late final _av_file_map = _av_file_mapPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Size>, int, ffi.Pointer<ffi.Void>)>();

  /// Unmap or free the buffer bufptr created by av_file_map().
  ///
  /// @param bufptr the buffer previously created with av_file_map()
  /// @param size size in bytes of bufptr, must be the same as returned
  /// by av_file_map()
  void av_file_unmap(
    ffi.Pointer<ffi.Uint8> bufptr,
    int size,
  ) {
    return _av_file_unmap(
      bufptr,
      size,
    );
  }

  late final _av_file_unmapPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Uint8>, ffi.Size)>>(
      'av_file_unmap');
  late final _av_file_unmap = _av_file_unmapPtr
      .asFunction<void Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// @defgroup lavu_md5 MD5
  /// @ingroup lavu_hash
  /// MD5 hash function implementation.
  ///
  /// @{
  late final ffi.Pointer<ffi.Int> _av_md5_size =
      _lookup<ffi.Int>('av_md5_size');

  int get av_md5_size => _av_md5_size.value;

  /// Allocate an AVMD5 context.
  ffi.Pointer<AVMD5> av_md5_alloc() {
    return _av_md5_alloc();
  }

  late final _av_md5_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVMD5> Function()>>(
          'av_md5_alloc');
  late final _av_md5_alloc =
      _av_md5_allocPtr.asFunction<ffi.Pointer<AVMD5> Function()>();

  /// Initialize MD5 hashing.
  ///
  /// @param ctx pointer to the function context (of size av_md5_size)
  void av_md5_init(
    ffi.Pointer<AVMD5> ctx,
  ) {
    return _av_md5_init(
      ctx,
    );
  }

  late final _av_md5_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVMD5>)>>(
          'av_md5_init');
  late final _av_md5_init =
      _av_md5_initPtr.asFunction<void Function(ffi.Pointer<AVMD5>)>();

  /// Update hash value.
  ///
  /// @param ctx hash function context
  /// @param src input data to update hash with
  /// @param len input data length
  void av_md5_update(
    ffi.Pointer<AVMD5> ctx,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    return _av_md5_update(
      ctx,
      src,
      len,
    );
  }

  late final _av_md5_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVMD5>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_md5_update');
  late final _av_md5_update = _av_md5_updatePtr.asFunction<
      void Function(ffi.Pointer<AVMD5>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finish hashing and output digest value.
  ///
  /// @param ctx hash function context
  /// @param dst buffer where output digest value is stored
  void av_md5_final(
    ffi.Pointer<AVMD5> ctx,
    ffi.Pointer<ffi.Uint8> dst,
  ) {
    return _av_md5_final(
      ctx,
      dst,
    );
  }

  late final _av_md5_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVMD5>, ffi.Pointer<ffi.Uint8>)>>('av_md5_final');
  late final _av_md5_final = _av_md5_finalPtr
      .asFunction<void Function(ffi.Pointer<AVMD5>, ffi.Pointer<ffi.Uint8>)>();

  /// Hash an array of data.
  ///
  /// @param dst The output buffer to write the digest into
  /// @param src The data to hash
  /// @param len The length of the data, in bytes
  void av_md5_sum(
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    return _av_md5_sum(
      dst,
      src,
      len,
    );
  }

  late final _av_md5_sumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_md5_sum');
  late final _av_md5_sum = _av_md5_sumPtr.asFunction<
      void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>, int)>();

  /// @file
  /// @brief Public header for libavutil CAST5 algorithm
  /// @defgroup lavu_cast5 CAST5
  /// @ingroup lavu_crypto
  /// @{
  late final ffi.Pointer<ffi.Int> _av_cast5_size =
      _lookup<ffi.Int>('av_cast5_size');

  int get av_cast5_size => _av_cast5_size.value;

  /// Allocate an AVCAST5 context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVCAST5> av_cast5_alloc() {
    return _av_cast5_alloc();
  }

  late final _av_cast5_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCAST5> Function()>>(
          'av_cast5_alloc');
  late final _av_cast5_alloc =
      _av_cast5_allocPtr.asFunction<ffi.Pointer<AVCAST5> Function()>();

  /// Initialize an AVCAST5 context.
  ///
  /// @param ctx an AVCAST5 context
  /// @param key a key of 5,6,...16 bytes used for encryption/decryption
  /// @param key_bits number of keybits: possible are 40,48,...,128
  /// @return 0 on success, less than 0 on failure
  int av_cast5_init(
    ffi.Pointer<AVCAST5> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
  ) {
    return _av_cast5_init(
      ctx,
      key,
      key_bits,
    );
  }

  late final _av_cast5_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCAST5>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_cast5_init');
  late final _av_cast5_init = _av_cast5_initPtr.asFunction<
      int Function(ffi.Pointer<AVCAST5>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context, ECB mode only
  ///
  /// @param ctx an AVCAST5 context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_cast5_crypt(
    ffi.Pointer<AVCAST5> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    int decrypt,
  ) {
    return _av_cast5_crypt(
      ctx,
      dst,
      src,
      count,
      decrypt,
    );
  }

  late final _av_cast5_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVCAST5>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>, ffi.Int, ffi.Int)>>('av_cast5_crypt');
  late final _av_cast5_crypt = _av_cast5_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVCAST5>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context
  ///
  /// @param ctx an AVCAST5 context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, NULL for ECB mode
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_cast5_crypt2(
    ffi.Pointer<AVCAST5> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_cast5_crypt2(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_cast5_crypt2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVCAST5>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_cast5_crypt2');
  late final _av_cast5_crypt2 = _av_cast5_crypt2Ptr.asFunction<
      void Function(ffi.Pointer<AVCAST5>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate a AVSphericalVideo structure and initialize its fields to default
  /// values.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVSphericalMapping> av_spherical_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_spherical_alloc(
      size,
    );
  }

  late final _av_spherical_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVSphericalMapping> Function(
              ffi.Pointer<ffi.Size>)>>('av_spherical_alloc');
  late final _av_spherical_alloc = _av_spherical_allocPtr.asFunction<
      ffi.Pointer<AVSphericalMapping> Function(ffi.Pointer<ffi.Size>)>();

  /// Convert the @ref bounding fields from an AVSphericalVideo
  /// from 0.32 fixed point to pixels.
  ///
  /// @param map    The AVSphericalVideo map to read bound values from.
  /// @param width  Width of the current frame or stream.
  /// @param height Height of the current frame or stream.
  /// @param left   Pixels from the left edge.
  /// @param top    Pixels from the top edge.
  /// @param right  Pixels from the right edge.
  /// @param bottom Pixels from the bottom edge.
  void av_spherical_tile_bounds(
    ffi.Pointer<AVSphericalMapping> map,
    int width,
    int height,
    ffi.Pointer<ffi.Size> left,
    ffi.Pointer<ffi.Size> top,
    ffi.Pointer<ffi.Size> right,
    ffi.Pointer<ffi.Size> bottom,
  ) {
    return _av_spherical_tile_bounds(
      map,
      width,
      height,
      left,
      top,
      right,
      bottom,
    );
  }

  late final _av_spherical_tile_boundsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVSphericalMapping>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>)>>('av_spherical_tile_bounds');
  late final _av_spherical_tile_bounds =
      _av_spherical_tile_boundsPtr.asFunction<
          void Function(
              ffi.Pointer<AVSphericalMapping>,
              int,
              int,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>)>();

  /// Provide a human-readable name of a given AVSphericalProjection.
  ///
  /// @param projection The input AVSphericalProjection.
  ///
  /// @return The name of the AVSphericalProjection, or "unknown".
  ffi.Pointer<ffi.Char> av_spherical_projection_name(
    AVSphericalProjection projection,
  ) {
    return _av_spherical_projection_name(
      projection.value,
    );
  }

  late final _av_spherical_projection_namePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.UnsignedInt)>>(
      'av_spherical_projection_name');
  late final _av_spherical_projection_name = _av_spherical_projection_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the AVSphericalProjection form a human-readable name.
  ///
  /// @param name The input string.
  ///
  /// @return The AVSphericalProjection value, or -1 if not found.
  int av_spherical_from_name(
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_spherical_from_name(
      name,
    );
  }

  late final _av_spherical_from_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'av_spherical_from_name');
  late final _av_spherical_from_name = _av_spherical_from_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Free an AVAudioFifo.
  ///
  /// @param af  AVAudioFifo to free
  void av_audio_fifo_free(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    return _av_audio_fifo_free(
      af,
    );
  }

  late final _av_audio_fifo_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVAudioFifo>)>>(
          'av_audio_fifo_free');
  late final _av_audio_fifo_free = _av_audio_fifo_freePtr
      .asFunction<void Function(ffi.Pointer<AVAudioFifo>)>();

  /// Allocate an AVAudioFifo.
  ///
  /// @param sample_fmt  sample format
  /// @param channels    number of channels
  /// @param nb_samples  initial allocation size, in samples
  /// @return            newly allocated AVAudioFifo, or NULL on error
  ffi.Pointer<AVAudioFifo> av_audio_fifo_alloc(
    AVSampleFormat sample_fmt,
    int channels,
    int nb_samples,
  ) {
    return _av_audio_fifo_alloc(
      sample_fmt.value,
      channels,
      nb_samples,
    );
  }

  late final _av_audio_fifo_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVAudioFifo> Function(
              ffi.Int, ffi.Int, ffi.Int)>>('av_audio_fifo_alloc');
  late final _av_audio_fifo_alloc = _av_audio_fifo_allocPtr
      .asFunction<ffi.Pointer<AVAudioFifo> Function(int, int, int)>();

  /// Reallocate an AVAudioFifo.
  ///
  /// @param af          AVAudioFifo to reallocate
  /// @param nb_samples  new allocation size, in samples
  /// @return            0 if OK, or negative AVERROR code on failure
  int av_audio_fifo_realloc(
    ffi.Pointer<AVAudioFifo> af,
    int nb_samples,
  ) {
    return _av_audio_fifo_realloc(
      af,
      nb_samples,
    );
  }

  late final _av_audio_fifo_reallocPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVAudioFifo>, ffi.Int)>>(
      'av_audio_fifo_realloc');
  late final _av_audio_fifo_realloc = _av_audio_fifo_reallocPtr
      .asFunction<int Function(ffi.Pointer<AVAudioFifo>, int)>();

  /// Write data to an AVAudioFifo.
  ///
  /// The AVAudioFifo will be reallocated automatically if the available space
  /// is less than nb_samples.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to write to
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to write
  /// @return            number of samples actually written, or negative AVERROR
  /// code on failure. If successful, the number of samples
  /// actually written will always be nb_samples.
  int av_audio_fifo_write(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
  ) {
    return _av_audio_fifo_write(
      af,
      data,
      nb_samples,
    );
  }

  late final _av_audio_fifo_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVAudioFifo>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Int)>>('av_audio_fifo_write');
  late final _av_audio_fifo_write = _av_audio_fifo_writePtr.asFunction<
      int Function(
          ffi.Pointer<AVAudioFifo>, ffi.Pointer<ffi.Pointer<ffi.Void>>, int)>();

  /// Peek data from an AVAudioFifo.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to read from
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to peek
  /// @return            number of samples actually peek, or negative AVERROR code
  /// on failure. The number of samples actually peek will not
  /// be greater than nb_samples, and will only be less than
  /// nb_samples if av_audio_fifo_size is less than nb_samples.
  int av_audio_fifo_peek(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
  ) {
    return _av_audio_fifo_peek(
      af,
      data,
      nb_samples,
    );
  }

  late final _av_audio_fifo_peekPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVAudioFifo>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Int)>>('av_audio_fifo_peek');
  late final _av_audio_fifo_peek = _av_audio_fifo_peekPtr.asFunction<
      int Function(
          ffi.Pointer<AVAudioFifo>, ffi.Pointer<ffi.Pointer<ffi.Void>>, int)>();

  /// Peek data from an AVAudioFifo.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to read from
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to peek
  /// @param offset      offset from current read position
  /// @return            number of samples actually peek, or negative AVERROR code
  /// on failure. The number of samples actually peek will not
  /// be greater than nb_samples, and will only be less than
  /// nb_samples if av_audio_fifo_size is less than nb_samples.
  int av_audio_fifo_peek_at(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
    int offset,
  ) {
    return _av_audio_fifo_peek_at(
      af,
      data,
      nb_samples,
      offset,
    );
  }

  late final _av_audio_fifo_peek_atPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVAudioFifo>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Int,
              ffi.Int)>>('av_audio_fifo_peek_at');
  late final _av_audio_fifo_peek_at = _av_audio_fifo_peek_atPtr.asFunction<
      int Function(ffi.Pointer<AVAudioFifo>, ffi.Pointer<ffi.Pointer<ffi.Void>>,
          int, int)>();

  /// Read data from an AVAudioFifo.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to read from
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to read
  /// @return            number of samples actually read, or negative AVERROR code
  /// on failure. The number of samples actually read will not
  /// be greater than nb_samples, and will only be less than
  /// nb_samples if av_audio_fifo_size is less than nb_samples.
  int av_audio_fifo_read(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
  ) {
    return _av_audio_fifo_read(
      af,
      data,
      nb_samples,
    );
  }

  late final _av_audio_fifo_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVAudioFifo>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Int)>>('av_audio_fifo_read');
  late final _av_audio_fifo_read = _av_audio_fifo_readPtr.asFunction<
      int Function(
          ffi.Pointer<AVAudioFifo>, ffi.Pointer<ffi.Pointer<ffi.Void>>, int)>();

  /// Drain data from an AVAudioFifo.
  ///
  /// Removes the data without reading it.
  ///
  /// @param af          AVAudioFifo to drain
  /// @param nb_samples  number of samples to drain
  /// @return            0 if OK, or negative AVERROR code on failure
  int av_audio_fifo_drain(
    ffi.Pointer<AVAudioFifo> af,
    int nb_samples,
  ) {
    return _av_audio_fifo_drain(
      af,
      nb_samples,
    );
  }

  late final _av_audio_fifo_drainPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVAudioFifo>, ffi.Int)>>(
      'av_audio_fifo_drain');
  late final _av_audio_fifo_drain = _av_audio_fifo_drainPtr
      .asFunction<int Function(ffi.Pointer<AVAudioFifo>, int)>();

  /// Reset the AVAudioFifo buffer.
  ///
  /// This empties all data in the buffer.
  ///
  /// @param af  AVAudioFifo to reset
  void av_audio_fifo_reset(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    return _av_audio_fifo_reset(
      af,
    );
  }

  late final _av_audio_fifo_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVAudioFifo>)>>(
          'av_audio_fifo_reset');
  late final _av_audio_fifo_reset = _av_audio_fifo_resetPtr
      .asFunction<void Function(ffi.Pointer<AVAudioFifo>)>();

  /// Get the current number of samples in the AVAudioFifo available for reading.
  ///
  /// @param af  the AVAudioFifo to query
  /// @return    number of samples available for reading
  int av_audio_fifo_size(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    return _av_audio_fifo_size(
      af,
    );
  }

  late final _av_audio_fifo_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVAudioFifo>)>>(
          'av_audio_fifo_size');
  late final _av_audio_fifo_size = _av_audio_fifo_sizePtr
      .asFunction<int Function(ffi.Pointer<AVAudioFifo>)>();

  /// Get the current number of samples in the AVAudioFifo available for writing.
  ///
  /// @param af  the AVAudioFifo to query
  /// @return    number of samples available for writing
  int av_audio_fifo_space(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    return _av_audio_fifo_space(
      af,
    );
  }

  late final _av_audio_fifo_spacePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVAudioFifo>)>>(
          'av_audio_fifo_space');
  late final _av_audio_fifo_space = _av_audio_fifo_spacePtr
      .asFunction<int Function(ffi.Pointer<AVAudioFifo>)>();

  late final ffi.Pointer<ffi.Int> _av_tree_node_size =
      _lookup<ffi.Int>('av_tree_node_size');

  int get av_tree_node_size => _av_tree_node_size.value;

  /// Allocate an AVTreeNode.
  ffi.Pointer<AVTreeNode> av_tree_node_alloc() {
    return _av_tree_node_alloc();
  }

  late final _av_tree_node_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVTreeNode> Function()>>(
          'av_tree_node_alloc');
  late final _av_tree_node_alloc =
      _av_tree_node_allocPtr.asFunction<ffi.Pointer<AVTreeNode> Function()>();

  /// Find an element.
  /// @param root a pointer to the root node of the tree
  /// @param next If next is not NULL, then next[0] will contain the previous
  /// element and next[1] the next element. If either does not exist,
  /// then the corresponding entry in next is unchanged.
  /// @param cmp compare function used to compare elements in the tree,
  /// API identical to that of Standard C's qsort
  /// It is guaranteed that the first and only the first argument to cmp()
  /// will be the key parameter to av_tree_find(), thus it could if the
  /// user wants, be a different type (like an opaque context).
  /// @return An element with cmp(key, elem) == 0 or NULL if no such element
  /// exists in the tree.
  ffi.Pointer<ffi.Void> av_tree_find(
    ffi.Pointer<AVTreeNode> root,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> key, ffi.Pointer<ffi.Void> b)>>
        cmp,
    ffi.Pointer<ffi.Pointer<ffi.Void>> next,
  ) {
    return _av_tree_find(
      root,
      key,
      cmp,
      next,
    );
  }

  late final _av_tree_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<AVTreeNode>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void> key, ffi.Pointer<ffi.Void> b)>>,
              ffi.Pointer<ffi.Pointer<ffi.Void>>)>>('av_tree_find');
  late final _av_tree_find = _av_tree_findPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<AVTreeNode>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void> key, ffi.Pointer<ffi.Void> b)>>,
          ffi.Pointer<ffi.Pointer<ffi.Void>>)>();

  /// Insert or remove an element.
  ///
  /// If *next is NULL, then the supplied element will be removed if it exists.
  /// If *next is non-NULL, then the supplied element will be inserted, unless
  /// it already exists in the tree.
  ///
  /// @param rootp A pointer to a pointer to the root node of the tree; note that
  /// the root node can change during insertions, this is required
  /// to keep the tree balanced.
  /// @param key  pointer to the element key to insert in the tree
  /// @param next Used to allocate and free AVTreeNodes. For insertion the user
  /// must set it to an allocated and zeroed object of at least
  /// av_tree_node_size bytes size. av_tree_insert() will set it to
  /// NULL if it has been consumed.
  /// For deleting elements *next is set to NULL by the user and
  /// av_tree_insert() will set it to the AVTreeNode which was
  /// used for the removed element.
  /// This allows the use of flat arrays, which have
  /// lower overhead compared to many malloced elements.
  /// You might want to define a function like:
  /// @code
  /// void *tree_insert(struct AVTreeNode **rootp, void *key,
  /// int (*cmp)(void *key, const void *b),
  /// AVTreeNode **next)
  /// {
  /// if (!*next)
  /// *next = av_mallocz(av_tree_node_size);
  /// return av_tree_insert(rootp, key, cmp, next);
  /// }
  /// void *tree_remove(struct AVTreeNode **rootp, void *key,
  /// int (*cmp)(void *key, const void *b, AVTreeNode **next))
  /// {
  /// av_freep(next);
  /// return av_tree_insert(rootp, key, cmp, next);
  /// }
  /// @endcode
  /// @param cmp compare function used to compare elements in the tree, API identical
  /// to that of Standard C's qsort
  /// @return If no insertion happened, the found element; if an insertion or
  /// removal happened, then either key or NULL will be returned.
  /// Which one it is depends on the tree state and the implementation. You
  /// should make no assumptions that it's one or the other in the code.
  ffi.Pointer<ffi.Void> av_tree_insert(
    ffi.Pointer<ffi.Pointer<AVTreeNode>> rootp,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> key, ffi.Pointer<ffi.Void> b)>>
        cmp,
    ffi.Pointer<ffi.Pointer<AVTreeNode>> next,
  ) {
    return _av_tree_insert(
      rootp,
      key,
      cmp,
      next,
    );
  }

  late final _av_tree_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Pointer<AVTreeNode>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void> key, ffi.Pointer<ffi.Void> b)>>,
              ffi.Pointer<ffi.Pointer<AVTreeNode>>)>>('av_tree_insert');
  late final _av_tree_insert = _av_tree_insertPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Pointer<AVTreeNode>>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void> key, ffi.Pointer<ffi.Void> b)>>,
          ffi.Pointer<ffi.Pointer<AVTreeNode>>)>();

  void av_tree_destroy(
    ffi.Pointer<AVTreeNode> t,
  ) {
    return _av_tree_destroy(
      t,
    );
  }

  late final _av_tree_destroyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVTreeNode>)>>(
          'av_tree_destroy');
  late final _av_tree_destroy =
      _av_tree_destroyPtr.asFunction<void Function(ffi.Pointer<AVTreeNode>)>();

  /// Apply enu(opaque, &elem) to all the elements in the tree in a given range.
  ///
  /// @param cmp a comparison function that returns < 0 for an element below the
  /// range, > 0 for an element above the range and == 0 for an
  /// element inside the range
  ///
  /// @note The cmp function should use the same ordering used to construct the
  /// tree.
  void av_tree_enumerate(
    ffi.Pointer<AVTreeNode> t,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> opaque, ffi.Pointer<ffi.Void> elem)>>
        cmp,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(
                    ffi.Pointer<ffi.Void> opaque, ffi.Pointer<ffi.Void> elem)>>
        enu,
  ) {
    return _av_tree_enumerate(
      t,
      opaque,
      cmp,
      enu,
    );
  }

  late final _av_tree_enumeratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVTreeNode>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                          ffi.Pointer<ffi.Void> elem)>>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                          ffi.Pointer<ffi.Void> elem)>>)>>('av_tree_enumerate');
  late final _av_tree_enumerate = _av_tree_enumeratePtr.asFunction<
      void Function(
          ffi.Pointer<AVTreeNode>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                      ffi.Pointer<ffi.Void> elem)>>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
                      ffi.Pointer<ffi.Void> elem)>>)>();

  /// Allocate a new message queue.
  ///
  /// @param mq      pointer to the message queue
  /// @param nelem   maximum number of elements in the queue
  /// @param elsize  size of each element in the queue
  /// @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if
  /// lavu was built without thread support
  int av_thread_message_queue_alloc(
    ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
    int nelem,
    int elsize,
  ) {
    return _av_thread_message_queue_alloc(
      mq,
      nelem,
      elsize,
    );
  }

  late final _av_thread_message_queue_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>>,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('av_thread_message_queue_alloc');
  late final _av_thread_message_queue_alloc =
      _av_thread_message_queue_allocPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>>, int, int)>();

  /// Free a message queue.
  ///
  /// The message queue must no longer be in use by another thread.
  void av_thread_message_queue_free(
    ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
  ) {
    return _av_thread_message_queue_free(
      mq,
    );
  }

  late final _av_thread_message_queue_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>>)>>(
      'av_thread_message_queue_free');
  late final _av_thread_message_queue_free =
      _av_thread_message_queue_freePtr.asFunction<
          void Function(ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>>)>();

  /// Send a message on the queue.
  int av_thread_message_queue_send(
    ffi.Pointer<AVThreadMessageQueue> mq,
    ffi.Pointer<ffi.Void> msg,
    int flags,
  ) {
    return _av_thread_message_queue_send(
      mq,
      msg,
      flags,
    );
  }

  late final _av_thread_message_queue_sendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVThreadMessageQueue>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedInt)>>('av_thread_message_queue_send');
  late final _av_thread_message_queue_send =
      _av_thread_message_queue_sendPtr.asFunction<
          int Function(
              ffi.Pointer<AVThreadMessageQueue>, ffi.Pointer<ffi.Void>, int)>();

  /// Receive a message from the queue.
  int av_thread_message_queue_recv(
    ffi.Pointer<AVThreadMessageQueue> mq,
    ffi.Pointer<ffi.Void> msg,
    int flags,
  ) {
    return _av_thread_message_queue_recv(
      mq,
      msg,
      flags,
    );
  }

  late final _av_thread_message_queue_recvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVThreadMessageQueue>,
              ffi.Pointer<ffi.Void>,
              ffi.UnsignedInt)>>('av_thread_message_queue_recv');
  late final _av_thread_message_queue_recv =
      _av_thread_message_queue_recvPtr.asFunction<
          int Function(
              ffi.Pointer<AVThreadMessageQueue>, ffi.Pointer<ffi.Void>, int)>();

  /// Set the sending error code.
  ///
  /// If the error code is set to non-zero, av_thread_message_queue_send() will
  /// return it immediately. Conventional values, such as AVERROR_EOF or
  /// AVERROR(EAGAIN), can be used to cause the sending thread to stop or
  /// suspend its operation.
  void av_thread_message_queue_set_err_send(
    ffi.Pointer<AVThreadMessageQueue> mq,
    int err,
  ) {
    return _av_thread_message_queue_set_err_send(
      mq,
      err,
    );
  }

  late final _av_thread_message_queue_set_err_sendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVThreadMessageQueue>,
              ffi.Int)>>('av_thread_message_queue_set_err_send');
  late final _av_thread_message_queue_set_err_send =
      _av_thread_message_queue_set_err_sendPtr
          .asFunction<void Function(ffi.Pointer<AVThreadMessageQueue>, int)>();

  /// Set the receiving error code.
  ///
  /// If the error code is set to non-zero, av_thread_message_queue_recv() will
  /// return it immediately when there are no longer available messages.
  /// Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used
  /// to cause the receiving thread to stop or suspend its operation.
  void av_thread_message_queue_set_err_recv(
    ffi.Pointer<AVThreadMessageQueue> mq,
    int err,
  ) {
    return _av_thread_message_queue_set_err_recv(
      mq,
      err,
    );
  }

  late final _av_thread_message_queue_set_err_recvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVThreadMessageQueue>,
              ffi.Int)>>('av_thread_message_queue_set_err_recv');
  late final _av_thread_message_queue_set_err_recv =
      _av_thread_message_queue_set_err_recvPtr
          .asFunction<void Function(ffi.Pointer<AVThreadMessageQueue>, int)>();

  /// Set the optional free message callback function which will be called if an
  /// operation is removing messages from the queue.
  void av_thread_message_queue_set_free_func(
    ffi.Pointer<AVThreadMessageQueue> mq,
    ffi.Pointer<
            ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> msg)>>
        free_func,
  ) {
    return _av_thread_message_queue_set_free_func(
      mq,
      free_func,
    );
  }

  late final _av_thread_message_queue_set_free_funcPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<AVThreadMessageQueue>,
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Void Function(ffi.Pointer<ffi.Void> msg)>>)>>(
      'av_thread_message_queue_set_free_func');
  late final _av_thread_message_queue_set_free_func =
      _av_thread_message_queue_set_free_funcPtr.asFunction<
          void Function(
              ffi.Pointer<AVThreadMessageQueue>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Pointer<ffi.Void> msg)>>)>();

  /// Return the current number of messages in the queue.
  ///
  /// @return the current number of messages or AVERROR(ENOSYS) if lavu was built
  /// without thread support
  int av_thread_message_queue_nb_elems(
    ffi.Pointer<AVThreadMessageQueue> mq,
  ) {
    return _av_thread_message_queue_nb_elems(
      mq,
    );
  }

  late final _av_thread_message_queue_nb_elemsPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVThreadMessageQueue>)>>(
      'av_thread_message_queue_nb_elems');
  late final _av_thread_message_queue_nb_elems =
      _av_thread_message_queue_nb_elemsPtr
          .asFunction<int Function(ffi.Pointer<AVThreadMessageQueue>)>();

  /// Flush the message queue
  ///
  /// This function is mostly equivalent to reading and free-ing every message
  /// except that it will be done in a single operation (no lock/unlock between
  /// reads).
  void av_thread_message_flush(
    ffi.Pointer<AVThreadMessageQueue> mq,
  ) {
    return _av_thread_message_flush(
      mq,
    );
  }

  late final _av_thread_message_flushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVThreadMessageQueue>)>>('av_thread_message_flush');
  late final _av_thread_message_flush = _av_thread_message_flushPtr
      .asFunction<void Function(ffi.Pointer<AVThreadMessageQueue>)>();

  /// Allocate an AVDynamicHDRVivid structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVDynamicHDRVivid filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVDynamicHDRVivid> av_dynamic_hdr_vivid_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_dynamic_hdr_vivid_alloc(
      size,
    );
  }

  late final _av_dynamic_hdr_vivid_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDynamicHDRVivid> Function(
              ffi.Pointer<ffi.Size>)>>('av_dynamic_hdr_vivid_alloc');
  late final _av_dynamic_hdr_vivid_alloc =
      _av_dynamic_hdr_vivid_allocPtr.asFunction<
          ffi.Pointer<AVDynamicHDRVivid> Function(ffi.Pointer<ffi.Size>)>();

  /// Allocate a complete AVDynamicHDRVivid and add it to the frame.
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVDynamicHDRVivid structure to be filled by caller or NULL
  /// on failure.
  ffi.Pointer<AVDynamicHDRVivid> av_dynamic_hdr_vivid_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_dynamic_hdr_vivid_create_side_data(
      frame,
    );
  }

  late final _av_dynamic_hdr_vivid_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDynamicHDRVivid> Function(
              ffi.Pointer<AVFrame>)>>('av_dynamic_hdr_vivid_create_side_data');
  late final _av_dynamic_hdr_vivid_create_side_data =
      _av_dynamic_hdr_vivid_create_side_dataPtr.asFunction<
          ffi.Pointer<AVDynamicHDRVivid> Function(ffi.Pointer<AVFrame>)>();

  /// Calculate the Adler32 checksum of a buffer.
  ///
  /// Passing the return value to a subsequent av_adler32_update() call
  /// allows the checksum of multiple buffers to be calculated as though
  /// they were concatenated.
  ///
  /// @param adler initial checksum value
  /// @param buf   pointer to input buffer
  /// @param len   size of input buffer
  /// @return      updated checksum
  int av_adler32_update(
    int adler,
    ffi.Pointer<ffi.Uint8> buf,
    int len,
  ) {
    return _av_adler32_update(
      adler,
      buf,
      len,
    );
  }

  late final _av_adler32_updatePtr = _lookup<
      ffi.NativeFunction<
          AVAdler Function(
              AVAdler, ffi.Pointer<ffi.Uint8>, ffi.Size)>>('av_adler32_update');
  late final _av_adler32_update = _av_adler32_updatePtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Adjust frame number for NTSC drop frame time code.
  ///
  /// @param framenum frame number to adjust
  /// @param fps      frame per second, multiples of 30
  /// @return         adjusted frame number
  /// @warning        adjustment is only valid for multiples of NTSC 29.97
  int av_timecode_adjust_ntsc_framenum2(
    int framenum,
    int fps,
  ) {
    return _av_timecode_adjust_ntsc_framenum2(
      framenum,
      fps,
    );
  }

  late final _av_timecode_adjust_ntsc_framenum2Ptr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'av_timecode_adjust_ntsc_framenum2');
  late final _av_timecode_adjust_ntsc_framenum2 =
      _av_timecode_adjust_ntsc_framenum2Ptr
          .asFunction<int Function(int, int)>();

  /// Convert frame number to SMPTE 12M binary representation.
  ///
  /// @param tc       timecode data correctly initialized
  /// @param framenum frame number
  /// @return         the SMPTE binary representation
  ///
  /// See SMPTE ST 314M-2005 Sec 4.4.2.2.1 "Time code pack (TC)"
  /// the format description as follows:
  /// bits 0-5:   hours, in BCD(6bits)
  /// bits 6:     BGF1
  /// bits 7:     BGF2 (NTSC) or FIELD (PAL)
  /// bits 8-14:  minutes, in BCD(7bits)
  /// bits 15:    BGF0 (NTSC) or BGF2 (PAL)
  /// bits 16-22: seconds, in BCD(7bits)
  /// bits 23:    FIELD (NTSC) or BGF0 (PAL)
  /// bits 24-29: frames, in BCD(6bits)
  /// bits 30:    drop  frame flag (0: non drop,    1: drop)
  /// bits 31:    color frame flag (0: unsync mode, 1: sync mode)
  /// @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.
  /// @note Frame number adjustment is automatically done in case of drop timecode,
  /// you do NOT have to call av_timecode_adjust_ntsc_framenum2().
  /// @note The frame number is relative to tc->start.
  /// @note Color frame (CF) and binary group flags (BGF) bits are set to zero.
  int av_timecode_get_smpte_from_framenum(
    ffi.Pointer<AVTimecode> tc,
    int framenum,
  ) {
    return _av_timecode_get_smpte_from_framenum(
      tc,
      framenum,
    );
  }

  late final _av_timecode_get_smpte_from_framenumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(ffi.Pointer<AVTimecode>,
              ffi.Int)>>('av_timecode_get_smpte_from_framenum');
  late final _av_timecode_get_smpte_from_framenum =
      _av_timecode_get_smpte_from_framenumPtr
          .asFunction<int Function(ffi.Pointer<AVTimecode>, int)>();

  /// Convert sei info to SMPTE 12M binary representation.
  ///
  /// @param rate     frame rate in rational form
  /// @param drop     drop flag
  /// @param hh       hour
  /// @param mm       minute
  /// @param ss       second
  /// @param ff       frame number
  /// @return         the SMPTE binary representation
  int av_timecode_get_smpte(
    AVRational rate,
    int drop,
    int hh,
    int mm,
    int ss,
    int ff,
  ) {
    return _av_timecode_get_smpte(
      rate,
      drop,
      hh,
      mm,
      ss,
      ff,
    );
  }

  late final _av_timecode_get_smptePtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint32 Function(AVRational, ffi.Int, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('av_timecode_get_smpte');
  late final _av_timecode_get_smpte = _av_timecode_get_smptePtr
      .asFunction<int Function(AVRational, int, int, int, int, int)>();

  /// Load timecode string in buf.
  ///
  /// @param tc       timecode data correctly initialized
  /// @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param framenum frame number
  /// @return         the buf parameter
  ///
  /// @note Timecode representation can be a negative timecode and have more than
  /// 24 hours, but will only be honored if the flags are correctly set.
  /// @note The frame number is relative to tc->start.
  ffi.Pointer<ffi.Char> av_timecode_make_string(
    ffi.Pointer<AVTimecode> tc,
    ffi.Pointer<ffi.Char> buf,
    int framenum,
  ) {
    return _av_timecode_make_string(
      tc,
      buf,
      framenum,
    );
  }

  late final _av_timecode_make_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<AVTimecode>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('av_timecode_make_string');
  late final _av_timecode_make_string = _av_timecode_make_stringPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<AVTimecode>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the timecode string from the SMPTE timecode format.
  ///
  /// In contrast to av_timecode_make_smpte_tc_string this function supports 50/60
  /// fps timecodes by using the field bit.
  ///
  /// @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param rate       frame rate of the timecode
  /// @param tcsmpte    the 32-bit SMPTE timecode
  /// @param prevent_df prevent the use of a drop flag when it is known the DF bit
  /// is arbitrary
  /// @param skip_field prevent the use of a field flag when it is known the field
  /// bit is arbitrary (e.g. because it is used as PC flag)
  /// @return           the buf parameter
  ffi.Pointer<ffi.Char> av_timecode_make_smpte_tc_string2(
    ffi.Pointer<ffi.Char> buf,
    AVRational rate,
    int tcsmpte,
    int prevent_df,
    int skip_field,
  ) {
    return _av_timecode_make_smpte_tc_string2(
      buf,
      rate,
      tcsmpte,
      prevent_df,
      skip_field,
    );
  }

  late final _av_timecode_make_smpte_tc_string2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              AVRational,
              ffi.Uint32,
              ffi.Int,
              ffi.Int)>>('av_timecode_make_smpte_tc_string2');
  late final _av_timecode_make_smpte_tc_string2 =
      _av_timecode_make_smpte_tc_string2Ptr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, AVRational, int, int, int)>();

  /// Get the timecode string from the SMPTE timecode format.
  ///
  /// @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param tcsmpte    the 32-bit SMPTE timecode
  /// @param prevent_df prevent the use of a drop flag when it is known the DF bit
  /// is arbitrary
  /// @return           the buf parameter
  ffi.Pointer<ffi.Char> av_timecode_make_smpte_tc_string(
    ffi.Pointer<ffi.Char> buf,
    int tcsmpte,
    int prevent_df,
  ) {
    return _av_timecode_make_smpte_tc_string(
      buf,
      tcsmpte,
      prevent_df,
    );
  }

  late final _av_timecode_make_smpte_tc_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Uint32,
              ffi.Int)>>('av_timecode_make_smpte_tc_string');
  late final _av_timecode_make_smpte_tc_string =
      _av_timecode_make_smpte_tc_stringPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, int)>();

  /// Get the timecode string from the 25-bit timecode format (MPEG GOP format).
  ///
  /// @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param tc25bit the 25-bits timecode
  /// @return        the buf parameter
  ffi.Pointer<ffi.Char> av_timecode_make_mpeg_tc_string(
    ffi.Pointer<ffi.Char> buf,
    int tc25bit,
  ) {
    return _av_timecode_make_mpeg_tc_string(
      buf,
      tc25bit,
    );
  }

  late final _av_timecode_make_mpeg_tc_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('av_timecode_make_mpeg_tc_string');
  late final _av_timecode_make_mpeg_tc_string =
      _av_timecode_make_mpeg_tc_stringPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int)>();

  /// Init a timecode struct with the passed parameters.
  ///
  /// @param tc          pointer to an allocated AVTimecode
  /// @param rate        frame rate in rational form
  /// @param flags       miscellaneous flags such as drop frame, +24 hours, ...
  /// (see AVTimecodeFlag)
  /// @param frame_start the first frame number
  /// @param log_ctx     a pointer to an arbitrary struct of which the first field
  /// is a pointer to an AVClass struct (used for av_log)
  /// @return            0 on success, AVERROR otherwise
  int av_timecode_init(
    ffi.Pointer<AVTimecode> tc,
    AVRational rate,
    int flags,
    int frame_start,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_timecode_init(
      tc,
      rate,
      flags,
      frame_start,
      log_ctx,
    );
  }

  late final _av_timecode_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVTimecode>, AVRational, ffi.Int,
              ffi.Int, ffi.Pointer<ffi.Void>)>>('av_timecode_init');
  late final _av_timecode_init = _av_timecode_initPtr.asFunction<
      int Function(ffi.Pointer<AVTimecode>, AVRational, int, int,
          ffi.Pointer<ffi.Void>)>();

  /// Init a timecode struct from the passed timecode components.
  ///
  /// @param tc          pointer to an allocated AVTimecode
  /// @param rate        frame rate in rational form
  /// @param flags       miscellaneous flags such as drop frame, +24 hours, ...
  /// (see AVTimecodeFlag)
  /// @param hh          hours
  /// @param mm          minutes
  /// @param ss          seconds
  /// @param ff          frames
  /// @param log_ctx     a pointer to an arbitrary struct of which the first field
  /// is a pointer to an AVClass struct (used for av_log)
  /// @return            0 on success, AVERROR otherwise
  int av_timecode_init_from_components(
    ffi.Pointer<AVTimecode> tc,
    AVRational rate,
    int flags,
    int hh,
    int mm,
    int ss,
    int ff,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_timecode_init_from_components(
      tc,
      rate,
      flags,
      hh,
      mm,
      ss,
      ff,
      log_ctx,
    );
  }

  late final _av_timecode_init_from_componentsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVTimecode>,
              AVRational,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('av_timecode_init_from_components');
  late final _av_timecode_init_from_components =
      _av_timecode_init_from_componentsPtr.asFunction<
          int Function(ffi.Pointer<AVTimecode>, AVRational, int, int, int, int,
              int, ffi.Pointer<ffi.Void>)>();

  /// Parse timecode representation (hh:mm:ss[:;.]ff).
  ///
  /// @param tc      pointer to an allocated AVTimecode
  /// @param rate    frame rate in rational form
  /// @param str     timecode string which will determine the frame start
  /// @param log_ctx a pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct (used for av_log).
  /// @return        0 on success, AVERROR otherwise
  int av_timecode_init_from_string(
    ffi.Pointer<AVTimecode> tc,
    AVRational rate,
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_timecode_init_from_string(
      tc,
      rate,
      str,
      log_ctx,
    );
  }

  late final _av_timecode_init_from_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVTimecode>,
              AVRational,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>>('av_timecode_init_from_string');
  late final _av_timecode_init_from_string =
      _av_timecode_init_from_stringPtr.asFunction<
          int Function(ffi.Pointer<AVTimecode>, AVRational,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>();

  /// Check if the timecode feature is available for the given frame rate
  ///
  /// @return 0 if supported, <0 otherwise
  int av_timecode_check_frame_rate(
    AVRational rate,
  ) {
    return _av_timecode_check_frame_rate(
      rate,
    );
  }

  late final _av_timecode_check_frame_ratePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(AVRational)>>(
          'av_timecode_check_frame_rate');
  late final _av_timecode_check_frame_rate =
      _av_timecode_check_frame_ratePtr.asFunction<int Function(AVRational)>();

  /// Retrieves the Luma coefficients necessary to construct a conversion matrix
  /// from an enum constant describing the colorspace.
  /// @param csp An enum constant indicating YUV or similar colorspace.
  /// @return The Luma coefficients associated with that colorspace, or NULL
  /// if the constant is unknown to libavutil.
  ffi.Pointer<AVLumaCoefficients> av_csp_luma_coeffs_from_avcsp(
    AVColorSpace csp,
  ) {
    return _av_csp_luma_coeffs_from_avcsp(
      csp.value,
    );
  }

  late final _av_csp_luma_coeffs_from_avcspPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVLumaCoefficients> Function(
              ffi.UnsignedInt)>>('av_csp_luma_coeffs_from_avcsp');
  late final _av_csp_luma_coeffs_from_avcsp = _av_csp_luma_coeffs_from_avcspPtr
      .asFunction<ffi.Pointer<AVLumaCoefficients> Function(int)>();

  /// Retrieves a complete gamut description from an enum constant describing the
  /// color primaries.
  /// @param prm An enum constant indicating primaries
  /// @return A description of the colorspace gamut associated with that enum
  /// constant, or NULL if the constant is unknown to libavutil.
  ffi.Pointer<AVColorPrimariesDesc> av_csp_primaries_desc_from_id(
    AVColorPrimaries prm,
  ) {
    return _av_csp_primaries_desc_from_id(
      prm.value,
    );
  }

  late final _av_csp_primaries_desc_from_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVColorPrimariesDesc> Function(
              ffi.UnsignedInt)>>('av_csp_primaries_desc_from_id');
  late final _av_csp_primaries_desc_from_id = _av_csp_primaries_desc_from_idPtr
      .asFunction<ffi.Pointer<AVColorPrimariesDesc> Function(int)>();

  /// Detects which enum AVColorPrimaries constant corresponds to the given complete
  /// gamut description.
  /// @see enum AVColorPrimaries
  /// @param prm A description of the colorspace gamut
  /// @return The enum constant associated with this gamut, or
  /// AVCOL_PRI_UNSPECIFIED if no clear match can be idenitified.
  AVColorPrimaries av_csp_primaries_id_from_desc(
    ffi.Pointer<AVColorPrimariesDesc> prm,
  ) {
    return AVColorPrimaries.fromValue(_av_csp_primaries_id_from_desc(
      prm,
    ));
  }

  late final _av_csp_primaries_id_from_descPtr = _lookup<
          ffi.NativeFunction<
              ffi.UnsignedInt Function(ffi.Pointer<AVColorPrimariesDesc>)>>(
      'av_csp_primaries_id_from_desc');
  late final _av_csp_primaries_id_from_desc = _av_csp_primaries_id_from_descPtr
      .asFunction<int Function(ffi.Pointer<AVColorPrimariesDesc>)>();

  /// Determine a suitable 'gamma' value to match the supplied
  /// AVColorTransferCharacteristic.
  ///
  /// See Apple Technical Note TN2257 (https://developer.apple.com/library/mac/technotes/tn2257/_index.html)
  ///
  /// This function returns the gamma exponent for the OETF. For example, sRGB is approximated
  /// by gamma 2.2, not by gamma 0.45455.
  ///
  /// @return Will return an approximation to the simple gamma function matching
  /// the supplied Transfer Characteristic, Will return 0.0 for any
  /// we cannot reasonably match against.
  double av_csp_approximate_trc_gamma(
    AVColorTransferCharacteristic trc,
  ) {
    return _av_csp_approximate_trc_gamma(
      trc.value,
    );
  }

  late final _av_csp_approximate_trc_gammaPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.UnsignedInt)>>(
          'av_csp_approximate_trc_gamma');
  late final _av_csp_approximate_trc_gamma =
      _av_csp_approximate_trc_gammaPtr.asFunction<double Function(int)>();

  /// Determine the function needed to apply the given
  /// AVColorTransferCharacteristic to linear input.
  ///
  /// The function returned should expect a nominal domain and range of [0.0-1.0]
  /// values outside of this range maybe valid depending on the chosen
  /// characteristic function.
  ///
  /// @return Will return pointer to the function matching the
  /// supplied Transfer Characteristic. If unspecified will
  /// return NULL:
  av_csp_trc_function av_csp_trc_func_from_id(
    AVColorTransferCharacteristic trc,
  ) {
    return _av_csp_trc_func_from_id(
      trc.value,
    );
  }

  late final _av_csp_trc_func_from_idPtr = _lookup<
          ffi.NativeFunction<av_csp_trc_function Function(ffi.UnsignedInt)>>(
      'av_csp_trc_func_from_id');
  late final _av_csp_trc_func_from_id = _av_csp_trc_func_from_idPtr
      .asFunction<av_csp_trc_function Function(int)>();

  /// Allocate a AVDOVIDecoderConfigurationRecord structure and initialize its
  /// fields to default values.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVDOVIDecoderConfigurationRecord> av_dovi_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_dovi_alloc(
      size,
    );
  }

  late final _av_dovi_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDOVIDecoderConfigurationRecord> Function(
              ffi.Pointer<ffi.Size>)>>('av_dovi_alloc');
  late final _av_dovi_alloc = _av_dovi_allocPtr.asFunction<
      ffi.Pointer<AVDOVIDecoderConfigurationRecord> Function(
          ffi.Pointer<ffi.Size>)>();

  /// Find an extension block with a given level, or NULL. In the case of
  /// multiple extension blocks, only the first is returned.
  ffi.Pointer<AVDOVIDmData> av_dovi_find_level(
    ffi.Pointer<AVDOVIMetadata> data,
    int level,
  ) {
    return _av_dovi_find_level(
      data,
      level,
    );
  }

  late final _av_dovi_find_levelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDOVIDmData> Function(
              ffi.Pointer<AVDOVIMetadata>, ffi.Uint8)>>('av_dovi_find_level');
  late final _av_dovi_find_level = _av_dovi_find_levelPtr.asFunction<
      ffi.Pointer<AVDOVIDmData> Function(ffi.Pointer<AVDOVIMetadata>, int)>();

  /// Allocate an AVDOVIMetadata structure and initialize its
  /// fields to default values.
  ///
  /// @param size If this parameter is non-NULL, the size in bytes of the
  /// allocated struct will be written here on success
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVDOVIMetadata> av_dovi_metadata_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_dovi_metadata_alloc(
      size,
    );
  }

  late final _av_dovi_metadata_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDOVIMetadata> Function(
              ffi.Pointer<ffi.Size>)>>('av_dovi_metadata_alloc');
  late final _av_dovi_metadata_alloc = _av_dovi_metadata_allocPtr.asFunction<
      ffi.Pointer<AVDOVIMetadata> Function(ffi.Pointer<ffi.Size>)>();

  /// Initialize a transform context with the given configuration
  /// (i)MDCTs with an odd length are currently not supported.
  ///
  /// @param ctx the context to allocate, will be NULL on error
  /// @param tx pointer to the transform function pointer to set
  /// @param type type the type of transform
  /// @param inv whether to do an inverse or a forward transform
  /// @param len the size of the transform in samples
  /// @param scale pointer to the value to scale the output if supported by type
  /// @param flags a bitmask of AVTXFlags or 0
  ///
  /// @return 0 on success, negative error code on failure
  int av_tx_init(
    ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
    ffi.Pointer<av_tx_fn> tx,
    AVTXType type,
    int inv,
    int len,
    ffi.Pointer<ffi.Void> scale,
    int flags,
  ) {
    return _av_tx_init(
      ctx,
      tx,
      type.value,
      inv,
      len,
      scale,
      flags,
    );
  }

  late final _av_tx_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVTXContext>>,
              ffi.Pointer<av_tx_fn>,
              ffi.UnsignedInt,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>,
              ffi.Uint64)>>('av_tx_init');
  late final _av_tx_init = _av_tx_initPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<AVTXContext>>, ffi.Pointer<av_tx_fn>,
          int, int, int, ffi.Pointer<ffi.Void>, int)>();

  /// Frees a context and sets *ctx to NULL, does nothing when *ctx == NULL.
  void av_tx_uninit(
    ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
  ) {
    return _av_tx_uninit(
      ctx,
    );
  }

  late final _av_tx_uninitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVTXContext>>)>>('av_tx_uninit');
  late final _av_tx_uninit = _av_tx_uninitPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVTXContext>>)>();

  /// @defgroup lavu_sha512 SHA-512
  /// @ingroup lavu_hash
  /// SHA-512 (Secure Hash Algorithm) hash function implementations.
  ///
  /// This module supports the following SHA-2 hash functions:
  ///
  /// - SHA-512/224: 224 bits
  /// - SHA-512/256: 256 bits
  /// - SHA-384: 384 bits
  /// - SHA-512: 512 bits
  ///
  /// @see For SHA-1, SHA-256, and variants thereof, see @ref lavu_sha.
  ///
  /// @{
  late final ffi.Pointer<ffi.Int> _av_sha512_size =
      _lookup<ffi.Int>('av_sha512_size');

  int get av_sha512_size => _av_sha512_size.value;

  /// Allocate an AVSHA512 context.
  ffi.Pointer<AVSHA512> av_sha512_alloc() {
    return _av_sha512_alloc();
  }

  late final _av_sha512_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVSHA512> Function()>>(
          'av_sha512_alloc');
  late final _av_sha512_alloc =
      _av_sha512_allocPtr.asFunction<ffi.Pointer<AVSHA512> Function()>();

  /// Initialize SHA-2 512 hashing.
  ///
  /// @param context pointer to the function context (of size av_sha512_size)
  /// @param bits    number of bits in digest (224, 256, 384 or 512 bits)
  /// @return        zero if initialization succeeded, -1 otherwise
  int av_sha512_init(
    ffi.Pointer<AVSHA512> context,
    int bits,
  ) {
    return _av_sha512_init(
      context,
      bits,
    );
  }

  late final _av_sha512_initPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVSHA512>, ffi.Int)>>(
      'av_sha512_init');
  late final _av_sha512_init =
      _av_sha512_initPtr.asFunction<int Function(ffi.Pointer<AVSHA512>, int)>();

  /// Update hash value.
  ///
  /// @param context hash function context
  /// @param data    input data to update hash with
  /// @param len     input data length
  void av_sha512_update(
    ffi.Pointer<AVSHA512> context,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _av_sha512_update(
      context,
      data,
      len,
    );
  }

  late final _av_sha512_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVSHA512>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_sha512_update');
  late final _av_sha512_update = _av_sha512_updatePtr.asFunction<
      void Function(ffi.Pointer<AVSHA512>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finish hashing and output digest value.
  ///
  /// @param context hash function context
  /// @param digest  buffer where output digest value is stored
  void av_sha512_final(
    ffi.Pointer<AVSHA512> context,
    ffi.Pointer<ffi.Uint8> digest,
  ) {
    return _av_sha512_final(
      context,
      digest,
    );
  }

  late final _av_sha512_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVSHA512>,
              ffi.Pointer<ffi.Uint8>)>>('av_sha512_final');
  late final _av_sha512_final = _av_sha512_finalPtr.asFunction<
      void Function(ffi.Pointer<AVSHA512>, ffi.Pointer<ffi.Uint8>)>();

  /// Extract the rotation component of the transformation matrix.
  ///
  /// @param matrix the transformation matrix
  /// @return the angle (in degrees) by which the transformation rotates the frame
  /// counterclockwise. The angle will be in range [-180.0, 180.0],
  /// or NaN if the matrix is singular.
  ///
  /// @note floating point numbers are inherently inexact, so callers are
  /// recommended to round the return value to nearest integer before use.
  double av_display_rotation_get(
    ffi.Pointer<ffi.Int32> matrix,
  ) {
    return _av_display_rotation_get(
      matrix,
    );
  }

  late final _av_display_rotation_getPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Int32>)>>(
          'av_display_rotation_get');
  late final _av_display_rotation_get = _av_display_rotation_getPtr
      .asFunction<double Function(ffi.Pointer<ffi.Int32>)>();

  /// Initialize a transformation matrix describing a pure clockwise
  /// rotation by the specified angle (in degrees).
  ///
  /// @param[out] matrix a transformation matrix (will be fully overwritten
  /// by this function)
  /// @param angle rotation angle in degrees.
  void av_display_rotation_set(
    ffi.Pointer<ffi.Int32> matrix,
    double angle,
  ) {
    return _av_display_rotation_set(
      matrix,
      angle,
    );
  }

  late final _av_display_rotation_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int32>, ffi.Double)>>('av_display_rotation_set');
  late final _av_display_rotation_set = _av_display_rotation_setPtr
      .asFunction<void Function(ffi.Pointer<ffi.Int32>, double)>();

  /// Flip the input matrix horizontally and/or vertically.
  ///
  /// @param[in,out] matrix a transformation matrix
  /// @param hflip whether the matrix should be flipped horizontally
  /// @param vflip whether the matrix should be flipped vertically
  void av_display_matrix_flip(
    ffi.Pointer<ffi.Int32> matrix,
    int hflip,
    int vflip,
  ) {
    return _av_display_matrix_flip(
      matrix,
      hflip,
      vflip,
    );
  }

  late final _av_display_matrix_flipPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int32>, ffi.Int,
              ffi.Int)>>('av_display_matrix_flip');
  late final _av_display_matrix_flip = _av_display_matrix_flipPtr
      .asFunction<void Function(ffi.Pointer<ffi.Int32>, int, int)>();

  /// @file
  /// @brief Public header for libavutil CAMELLIA algorithm
  /// @defgroup lavu_camellia CAMELLIA
  /// @ingroup lavu_crypto
  /// @{
  late final ffi.Pointer<ffi.Int> _av_camellia_size =
      _lookup<ffi.Int>('av_camellia_size');

  int get av_camellia_size => _av_camellia_size.value;

  /// Allocate an AVCAMELLIA context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVCAMELLIA> av_camellia_alloc() {
    return _av_camellia_alloc();
  }

  late final _av_camellia_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVCAMELLIA> Function()>>(
          'av_camellia_alloc');
  late final _av_camellia_alloc =
      _av_camellia_allocPtr.asFunction<ffi.Pointer<AVCAMELLIA> Function()>();

  /// Initialize an AVCAMELLIA context.
  ///
  /// @param ctx an AVCAMELLIA context
  /// @param key a key of 16, 24, 32 bytes used for encryption/decryption
  /// @param key_bits number of keybits: possible are 128, 192, 256
  int av_camellia_init(
    ffi.Pointer<AVCAMELLIA> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
  ) {
    return _av_camellia_init(
      ctx,
      key,
      key_bits,
    );
  }

  late final _av_camellia_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCAMELLIA>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_camellia_init');
  late final _av_camellia_init = _av_camellia_initPtr.asFunction<
      int Function(ffi.Pointer<AVCAMELLIA>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context
  ///
  /// @param ctx an AVCAMELLIA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 16 byte blocks
  /// @param iv initialization vector for CBC mode, NULL for ECB mode
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_camellia_crypt(
    ffi.Pointer<AVCAMELLIA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_camellia_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_camellia_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVCAMELLIA>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_camellia_crypt');
  late final _av_camellia_crypt = _av_camellia_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVCAMELLIA>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate memory for the AVVideoHint struct along with an nb_rects-sized
  /// arrays of AVVideoRect.
  ///
  /// The side data contains a list of rectangles for the portions of the frame
  /// which changed from the last encoded one (and the remainder are assumed to be
  /// changed), or, alternately (depending on the type parameter) the unchanged
  /// ones (and the remanining ones are those which changed).
  /// Macroblocks will thus be hinted either to be P_SKIP-ped or go through the
  /// regular encoding procedure.
  ///
  /// It's responsibility of the caller to fill the AVRects accordingly, and to set
  /// the proper AVVideoHintType field.
  ///
  /// @param out_size if non-NULL, the size in bytes of the resulting data array is
  /// written here
  ///
  /// @return newly allocated AVVideoHint struct (must be freed by the caller using
  /// av_free()) on success, NULL on memory allocation failure
  ffi.Pointer<AVVideoHint> av_video_hint_alloc(
    int nb_rects,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _av_video_hint_alloc(
      nb_rects,
      out_size,
    );
  }

  late final _av_video_hint_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVVideoHint> Function(
              ffi.Size, ffi.Pointer<ffi.Size>)>>('av_video_hint_alloc');
  late final _av_video_hint_alloc = _av_video_hint_allocPtr.asFunction<
      ffi.Pointer<AVVideoHint> Function(int, ffi.Pointer<ffi.Size>)>();

  /// Same as av_video_hint_alloc(), except newly-allocated AVVideoHint is attached
  /// as side data of type AV_FRAME_DATA_VIDEO_HINT_INFO to frame.
  ffi.Pointer<AVVideoHint> av_video_hint_create_side_data(
    ffi.Pointer<AVFrame> frame,
    int nb_rects,
  ) {
    return _av_video_hint_create_side_data(
      frame,
      nb_rects,
    );
  }

  late final _av_video_hint_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVVideoHint> Function(ffi.Pointer<AVFrame>,
              ffi.Size)>>('av_video_hint_create_side_data');
  late final _av_video_hint_create_side_data =
      _av_video_hint_create_side_dataPtr.asFunction<
          ffi.Pointer<AVVideoHint> Function(ffi.Pointer<AVFrame>, int)>();

  /// Get a potentially optimized pointer to a Sum-of-absolute-differences
  /// function (see the av_pixelutils_sad_fn prototype).
  ///
  /// @param w_bits  1<<w_bits is the requested width of the block size
  /// @param h_bits  1<<h_bits is the requested height of the block size
  /// @param aligned If set to 2, the returned sad function will assume src1 and
  /// src2 addresses are aligned on the block size.
  /// If set to 1, the returned sad function will assume src1 is
  /// aligned on the block size.
  /// If set to 0, the returned sad function assume no particular
  /// alignment.
  /// @param log_ctx context used for logging, can be NULL
  ///
  /// @return a pointer to the SAD function or NULL in case of error (because of
  /// invalid parameters)
  av_pixelutils_sad_fn av_pixelutils_get_sad_fn(
    int w_bits,
    int h_bits,
    int aligned,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_pixelutils_get_sad_fn(
      w_bits,
      h_bits,
      aligned,
      log_ctx,
    );
  }

  late final _av_pixelutils_get_sad_fnPtr = _lookup<
      ffi.NativeFunction<
          av_pixelutils_sad_fn Function(ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Void>)>>('av_pixelutils_get_sad_fn');
  late final _av_pixelutils_get_sad_fn =
      _av_pixelutils_get_sad_fnPtr.asFunction<
          av_pixelutils_sad_fn Function(
              int, int, int, ffi.Pointer<ffi.Void>)>();

  /// Allocate an AVHMAC context.
  /// @param type The hash function used for the HMAC.
  ffi.Pointer<AVHMAC> av_hmac_alloc(
    AVHMACType type,
  ) {
    return _av_hmac_alloc(
      type.value,
    );
  }

  late final _av_hmac_allocPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<AVHMAC> Function(ffi.UnsignedInt)>>(
      'av_hmac_alloc');
  late final _av_hmac_alloc =
      _av_hmac_allocPtr.asFunction<ffi.Pointer<AVHMAC> Function(int)>();

  /// Free an AVHMAC context.
  /// @param ctx The context to free, may be NULL
  void av_hmac_free(
    ffi.Pointer<AVHMAC> ctx,
  ) {
    return _av_hmac_free(
      ctx,
    );
  }

  late final _av_hmac_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVHMAC>)>>(
          'av_hmac_free');
  late final _av_hmac_free =
      _av_hmac_freePtr.asFunction<void Function(ffi.Pointer<AVHMAC>)>();

  /// Initialize an AVHMAC context with an authentication key.
  /// @param ctx    The HMAC context
  /// @param key    The authentication key
  /// @param keylen The length of the key, in bytes
  void av_hmac_init(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int keylen,
  ) {
    return _av_hmac_init(
      ctx,
      key,
      keylen,
    );
  }

  late final _av_hmac_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt)>>('av_hmac_init');
  late final _av_hmac_init = _av_hmac_initPtr.asFunction<
      void Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Hash data with the HMAC.
  /// @param ctx  The HMAC context
  /// @param data The data to hash
  /// @param len  The length of the data, in bytes
  void av_hmac_update(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _av_hmac_update(
      ctx,
      data,
      len,
    );
  }

  late final _av_hmac_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt)>>('av_hmac_update');
  late final _av_hmac_update = _av_hmac_updatePtr.asFunction<
      void Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finish hashing and output the HMAC digest.
  /// @param ctx    The HMAC context
  /// @param out    The output buffer to write the digest into
  /// @param outlen The length of the out buffer, in bytes
  /// @return       The number of bytes written to out, or a negative error code.
  int av_hmac_final(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> out,
    int outlen,
  ) {
    return _av_hmac_final(
      ctx,
      out,
      outlen,
    );
  }

  late final _av_hmac_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt)>>('av_hmac_final');
  late final _av_hmac_final = _av_hmac_finalPtr.asFunction<
      int Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Hash an array of data with a key.
  /// @param ctx    The HMAC context
  /// @param data   The data to hash
  /// @param len    The length of the data, in bytes
  /// @param key    The authentication key
  /// @param keylen The length of the key, in bytes
  /// @param out    The output buffer to write the digest into
  /// @param outlen The length of the out buffer, in bytes
  /// @return       The number of bytes written to out, or a negative error code.
  int av_hmac_calc(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Uint8> key,
    int keylen,
    ffi.Pointer<ffi.Uint8> out,
    int outlen,
  ) {
    return _av_hmac_calc(
      ctx,
      data,
      len,
      key,
      keylen,
      out,
      outlen,
    );
  }

  late final _av_hmac_calcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVHMAC>,
              ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt)>>('av_hmac_calc');
  late final _av_hmac_calc = _av_hmac_calcPtr.asFunction<
      int Function(ffi.Pointer<AVHMAC>, ffi.Pointer<ffi.Uint8>, int,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Parse and evaluate an expression.
  /// Note, this is significantly slower than av_expr_eval().
  ///
  /// @param res a pointer to a double where is put the result value of
  /// the expression, or NAN in case of error
  /// @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
  /// @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
  /// @param const_values a zero terminated array of values for the identifiers from const_names
  /// @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
  /// @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
  /// @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  /// @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
  /// @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
  /// @param log_offset log level offset, can be used to silence error messages
  /// @param log_ctx parent logging context
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code otherwise
  int av_expr_parse_and_eval(
    ffi.Pointer<ffi.Double> res,
    ffi.Pointer<ffi.Char> s,
    ffi.Pointer<ffi.Pointer<ffi.Char>> const_names,
    ffi.Pointer<ffi.Double> const_values,
    ffi.Pointer<ffi.Pointer<ffi.Char>> func1_names,
    ffi.Pointer<
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Double)>>>
        funcs1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> func2_names,
    ffi.Pointer<
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Double Function(
                        ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double)>>>
        funcs2,
    ffi.Pointer<ffi.Void> opaque,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_expr_parse_and_eval(
      res,
      s,
      const_names,
      const_values,
      func1_names,
      funcs1,
      func2_names,
      funcs2,
      opaque,
      log_offset,
      log_ctx,
    );
  }

  late final _av_expr_parse_and_evalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Double Function(
                              ffi.Pointer<ffi.Void>, ffi.Double)>>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Double Function(
                              ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double)>>>,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('av_expr_parse_and_eval');
  late final _av_expr_parse_and_eval = _av_expr_parse_and_evalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Double)>>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Double Function(
                          ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double)>>>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Void>)>();

  /// Parse an expression.
  ///
  /// @param expr a pointer where is put an AVExpr containing the parsed
  /// value in case of successful parsing, or NULL otherwise.
  /// The pointed to AVExpr must be freed with av_expr_free() by the user
  /// when it is not needed anymore.
  /// @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
  /// @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
  /// @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
  /// @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
  /// @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  /// @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
  /// @param log_offset log level offset, can be used to silence error messages
  /// @param log_ctx parent logging context
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code otherwise
  int av_expr_parse(
    ffi.Pointer<ffi.Pointer<AVExpr>> expr,
    ffi.Pointer<ffi.Char> s,
    ffi.Pointer<ffi.Pointer<ffi.Char>> const_names,
    ffi.Pointer<ffi.Pointer<ffi.Char>> func1_names,
    ffi.Pointer<
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Double)>>>
        funcs1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> func2_names,
    ffi.Pointer<
            ffi.Pointer<
                ffi.NativeFunction<
                    ffi.Double Function(
                        ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double)>>>
        funcs2,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_expr_parse(
      expr,
      s,
      const_names,
      func1_names,
      funcs1,
      func2_names,
      funcs2,
      log_offset,
      log_ctx,
    );
  }

  late final _av_expr_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVExpr>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Double Function(
                              ffi.Pointer<ffi.Void>, ffi.Double)>>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<
                  ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Double Function(
                              ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double)>>>,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('av_expr_parse');
  late final _av_expr_parse = _av_expr_parsePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVExpr>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Double Function(ffi.Pointer<ffi.Void>, ffi.Double)>>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Double Function(
                          ffi.Pointer<ffi.Void>, ffi.Double, ffi.Double)>>>,
          int,
          ffi.Pointer<ffi.Void>)>();

  /// Evaluate a previously parsed expression.
  ///
  /// @param e the AVExpr to evaluate
  /// @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names
  /// @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
  /// @return the value of the expression
  double av_expr_eval(
    ffi.Pointer<AVExpr> e,
    ffi.Pointer<ffi.Double> const_values,
    ffi.Pointer<ffi.Void> opaque,
  ) {
    return _av_expr_eval(
      e,
      const_values,
      opaque,
    );
  }

  late final _av_expr_evalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<AVExpr>, ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Void>)>>('av_expr_eval');
  late final _av_expr_eval = _av_expr_evalPtr.asFunction<
      double Function(ffi.Pointer<AVExpr>, ffi.Pointer<ffi.Double>,
          ffi.Pointer<ffi.Void>)>();

  /// Track the presence of variables and their number of occurrences in a parsed expression
  ///
  /// @param e the AVExpr to track variables in
  /// @param counter a zero-initialized array where the count of each variable will be stored
  /// @param size size of array
  /// @return 0 on success, a negative value indicates that no expression or array was passed
  /// or size was zero
  int av_expr_count_vars(
    ffi.Pointer<AVExpr> e,
    ffi.Pointer<ffi.UnsignedInt> counter,
    int size,
  ) {
    return _av_expr_count_vars(
      e,
      counter,
      size,
    );
  }

  late final _av_expr_count_varsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVExpr>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Int)>>('av_expr_count_vars');
  late final _av_expr_count_vars = _av_expr_count_varsPtr.asFunction<
      int Function(ffi.Pointer<AVExpr>, ffi.Pointer<ffi.UnsignedInt>, int)>();

  /// Track the presence of user provided functions and their number of occurrences
  /// in a parsed expression.
  ///
  /// @param e the AVExpr to track user provided functions in
  /// @param counter a zero-initialized array where the count of each function will be stored
  /// if you passed 5 functions with 2 arguments to av_expr_parse()
  /// then for arg=2 this will use up to 5 entries.
  /// @param size size of array
  /// @param arg number of arguments the counted functions have
  /// @return 0 on success, a negative value indicates that no expression or array was passed
  /// or size was zero
  int av_expr_count_func(
    ffi.Pointer<AVExpr> e,
    ffi.Pointer<ffi.UnsignedInt> counter,
    int size,
    int arg,
  ) {
    return _av_expr_count_func(
      e,
      counter,
      size,
      arg,
    );
  }

  late final _av_expr_count_funcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVExpr>, ffi.Pointer<ffi.UnsignedInt>,
              ffi.Int, ffi.Int)>>('av_expr_count_func');
  late final _av_expr_count_func = _av_expr_count_funcPtr.asFunction<
      int Function(
          ffi.Pointer<AVExpr>, ffi.Pointer<ffi.UnsignedInt>, int, int)>();

  /// Free a parsed expression previously created with av_expr_parse().
  void av_expr_free(
    ffi.Pointer<AVExpr> e,
  ) {
    return _av_expr_free(
      e,
    );
  }

  late final _av_expr_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVExpr>)>>(
          'av_expr_free');
  late final _av_expr_free =
      _av_expr_freePtr.asFunction<void Function(ffi.Pointer<AVExpr>)>();

  /// Parse the string in numstr and return its value as a double. If
  /// the string is empty, contains only whitespaces, or does not contain
  /// an initial substring that has the expected syntax for a
  /// floating-point number, no conversion is performed. In this case,
  /// returns a value of zero and the value returned in tail is the value
  /// of numstr.
  ///
  /// @param numstr a string representing a number, may contain one of
  /// the International System number postfixes, for example 'K', 'M',
  /// 'G'. If 'i' is appended after the postfix, powers of 2 are used
  /// instead of powers of 10. The 'B' postfix multiplies the value by
  /// 8, and can be appended after another postfix or used alone. This
  /// allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
  /// @param tail if non-NULL puts here the pointer to the char next
  /// after the last parsed character
  double av_strtod(
    ffi.Pointer<ffi.Char> numstr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> tail,
  ) {
    return _av_strtod(
      numstr,
      tail,
    );
  }

  late final _av_strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('av_strtod');
  late final _av_strtod = _av_strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Alloc executor
  /// @param callbacks callback structure for executor
  /// @param thread_count worker thread number, 0 for run on caller's thread directly
  /// @return return the executor
  ffi.Pointer<AVExecutor> av_executor_alloc(
    ffi.Pointer<AVTaskCallbacks> callbacks,
    int thread_count,
  ) {
    return _av_executor_alloc(
      callbacks,
      thread_count,
    );
  }

  late final _av_executor_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVExecutor> Function(
              ffi.Pointer<AVTaskCallbacks>, ffi.Int)>>('av_executor_alloc');
  late final _av_executor_alloc = _av_executor_allocPtr.asFunction<
      ffi.Pointer<AVExecutor> Function(ffi.Pointer<AVTaskCallbacks>, int)>();

  /// Free executor
  /// @param e  pointer to executor
  void av_executor_free(
    ffi.Pointer<ffi.Pointer<AVExecutor>> e,
  ) {
    return _av_executor_free(
      e,
    );
  }

  late final _av_executor_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVExecutor>>)>>('av_executor_free');
  late final _av_executor_free = _av_executor_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVExecutor>>)>();

  /// Add task to executor
  /// @param e pointer to executor
  /// @param t pointer to task. If NULL, it will wakeup one work thread
  void av_executor_execute(
    ffi.Pointer<AVExecutor> e,
    ffi.Pointer<AVTask> t,
  ) {
    return _av_executor_execute(
      e,
      t,
    );
  }

  late final _av_executor_executePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVExecutor>,
              ffi.Pointer<AVTask>)>>('av_executor_execute');
  late final _av_executor_execute = _av_executor_executePtr.asFunction<
      void Function(ffi.Pointer<AVExecutor>, ffi.Pointer<AVTask>)>();

  /// Get a seed to use in conjunction with random functions.
  /// This function tries to provide a good seed at a best effort bases.
  /// Its possible to call this function multiple times if more bits are needed.
  /// It can be quite slow, which is why it should only be used as seed for a faster
  /// PRNG. The quality of the seed depends on the platform.
  int av_get_random_seed() {
    return _av_get_random_seed();
  }

  late final _av_get_random_seedPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('av_get_random_seed');
  late final _av_get_random_seed =
      _av_get_random_seedPtr.asFunction<int Function()>();

  /// Generate cryptographically secure random data, i.e. suitable for use as
  /// encryption keys and similar.
  ///
  /// @param buf buffer into which the random data will be written
  /// @param len size of buf in bytes
  ///
  /// @retval 0                         success, len bytes of random data was written
  /// into buf
  /// @retval "a negative AVERROR code" random data could not be generated
  int av_random_bytes(
    ffi.Pointer<ffi.Uint8> buf,
    int len,
  ) {
    return _av_random_bytes(
      buf,
      len,
    );
  }

  late final _av_random_bytesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Uint8>, ffi.Size)>>(
      'av_random_bytes');
  late final _av_random_bytes = _av_random_bytesPtr
      .asFunction<int Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate an AVMasteringDisplayMetadata structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVMasteringDisplayMetadata filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVMasteringDisplayMetadata>
      av_mastering_display_metadata_alloc() {
    return _av_mastering_display_metadata_alloc();
  }

  late final _av_mastering_display_metadata_allocPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<AVMasteringDisplayMetadata> Function()>>(
      'av_mastering_display_metadata_alloc');
  late final _av_mastering_display_metadata_alloc =
      _av_mastering_display_metadata_allocPtr
          .asFunction<ffi.Pointer<AVMasteringDisplayMetadata> Function()>();

  /// Allocate an AVMasteringDisplayMetadata structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVMasteringDisplayMetadata filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVMasteringDisplayMetadata>
      av_mastering_display_metadata_alloc_size(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_mastering_display_metadata_alloc_size(
      size,
    );
  }

  late final _av_mastering_display_metadata_alloc_sizePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVMasteringDisplayMetadata> Function(
                  ffi.Pointer<ffi.Size>)>>(
      'av_mastering_display_metadata_alloc_size');
  late final _av_mastering_display_metadata_alloc_size =
      _av_mastering_display_metadata_alloc_sizePtr.asFunction<
          ffi.Pointer<AVMasteringDisplayMetadata> Function(
              ffi.Pointer<ffi.Size>)>();

  /// Allocate a complete AVMasteringDisplayMetadata and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVMasteringDisplayMetadata structure to be filled by caller.
  ffi.Pointer<AVMasteringDisplayMetadata>
      av_mastering_display_metadata_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_mastering_display_metadata_create_side_data(
      frame,
    );
  }

  late final _av_mastering_display_metadata_create_side_dataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVMasteringDisplayMetadata> Function(
                  ffi.Pointer<AVFrame>)>>(
      'av_mastering_display_metadata_create_side_data');
  late final _av_mastering_display_metadata_create_side_data =
      _av_mastering_display_metadata_create_side_dataPtr.asFunction<
          ffi.Pointer<AVMasteringDisplayMetadata> Function(
              ffi.Pointer<AVFrame>)>();

  /// Allocate an AVContentLightMetadata structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVContentLightMetadata filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVContentLightMetadata> av_content_light_metadata_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_content_light_metadata_alloc(
      size,
    );
  }

  late final _av_content_light_metadata_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVContentLightMetadata> Function(
              ffi.Pointer<ffi.Size>)>>('av_content_light_metadata_alloc');
  late final _av_content_light_metadata_alloc =
      _av_content_light_metadata_allocPtr.asFunction<
          ffi.Pointer<AVContentLightMetadata> Function(
              ffi.Pointer<ffi.Size>)>();

  /// Allocate a complete AVContentLightMetadata and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVContentLightMetadata structure to be filled by caller.
  ffi.Pointer<AVContentLightMetadata>
      av_content_light_metadata_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_content_light_metadata_create_side_data(
      frame,
    );
  }

  late final _av_content_light_metadata_create_side_dataPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<AVContentLightMetadata> Function(
                  ffi.Pointer<AVFrame>)>>(
      'av_content_light_metadata_create_side_data');
  late final _av_content_light_metadata_create_side_data =
      _av_content_light_metadata_create_side_dataPtr.asFunction<
          ffi.Pointer<AVContentLightMetadata> Function(ffi.Pointer<AVFrame>)>();

  /// @defgroup lavu_aes AES
  /// @ingroup lavu_crypto
  /// @{
  late final ffi.Pointer<ffi.Int> _av_aes_size =
      _lookup<ffi.Int>('av_aes_size');

  int get av_aes_size => _av_aes_size.value;

  /// Allocate an AVAES context.
  ffi.Pointer<AVAES> av_aes_alloc() {
    return _av_aes_alloc();
  }

  late final _av_aes_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVAES> Function()>>(
          'av_aes_alloc');
  late final _av_aes_alloc =
      _av_aes_allocPtr.asFunction<ffi.Pointer<AVAES> Function()>();

  /// Initialize an AVAES context.
  ///
  /// @param a The AVAES context
  /// @param key Pointer to the key
  /// @param key_bits 128, 192 or 256
  /// @param decrypt 0 for encryption, 1 for decryption
  int av_aes_init(
    ffi.Pointer<AVAES> a,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
    int decrypt,
  ) {
    return _av_aes_init(
      a,
      key,
      key_bits,
      decrypt,
    );
  }

  late final _av_aes_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVAES>, ffi.Pointer<ffi.Uint8>, ffi.Int,
              ffi.Int)>>('av_aes_init');
  late final _av_aes_init = _av_aes_initPtr.asFunction<
      int Function(ffi.Pointer<AVAES>, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param a The AVAES context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 16 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_aes_crypt(
    ffi.Pointer<AVAES> a,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_aes_crypt(
      a,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_aes_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVAES>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_aes_crypt');
  late final _av_aes_crypt = _av_aes_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVAES>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocate an AVRC4 context.
  ffi.Pointer<AVRC4> av_rc4_alloc() {
    return _av_rc4_alloc();
  }

  late final _av_rc4_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVRC4> Function()>>(
          'av_rc4_alloc');
  late final _av_rc4_alloc =
      _av_rc4_allocPtr.asFunction<ffi.Pointer<AVRC4> Function()>();

  /// @brief Initializes an AVRC4 context.
  ///
  /// @param d pointer to the AVRC4 context
  /// @param key buffer containig the key
  /// @param key_bits must be a multiple of 8
  /// @param decrypt 0 for encryption, 1 for decryption, currently has no effect
  /// @return zero on success, negative value otherwise
  int av_rc4_init(
    ffi.Pointer<AVRC4> d,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
    int decrypt,
  ) {
    return _av_rc4_init(
      d,
      key,
      key_bits,
      decrypt,
    );
  }

  late final _av_rc4_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVRC4>, ffi.Pointer<ffi.Uint8>, ffi.Int,
              ffi.Int)>>('av_rc4_init');
  late final _av_rc4_init = _av_rc4_initPtr.asFunction<
      int Function(ffi.Pointer<AVRC4>, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// @brief Encrypts / decrypts using the RC4 algorithm.
  ///
  /// @param d pointer to the AVRC4 context
  /// @param count number of bytes
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst, may be NULL
  /// @param iv not (yet) used for RC4, should be NULL
  /// @param decrypt 0 for encryption, 1 for decryption, not (yet) used
  void av_rc4_crypt(
    ffi.Pointer<AVRC4> d,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_rc4_crypt(
      d,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_rc4_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVRC4>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_rc4_crypt');
  late final _av_rc4_crypt = _av_rc4_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVRC4>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// @file
  /// @brief Public header for libavutil TEA algorithm
  /// @defgroup lavu_tea TEA
  /// @ingroup lavu_crypto
  /// @{
  late final ffi.Pointer<ffi.Int> _av_tea_size =
      _lookup<ffi.Int>('av_tea_size');

  int get av_tea_size => _av_tea_size.value;

  /// Allocate an AVTEA context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVTEA> av_tea_alloc() {
    return _av_tea_alloc();
  }

  late final _av_tea_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVTEA> Function()>>(
          'av_tea_alloc');
  late final _av_tea_alloc =
      _av_tea_allocPtr.asFunction<ffi.Pointer<AVTEA> Function()>();

  /// Initialize an AVTEA context.
  ///
  /// @param ctx an AVTEA context
  /// @param key a key of 16 bytes used for encryption/decryption
  /// @param rounds the number of rounds in TEA (64 is the "standard")
  void av_tea_init(
    ffi.Pointer<AVTEA> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int rounds,
  ) {
    return _av_tea_init(
      ctx,
      key,
      rounds,
    );
  }

  late final _av_tea_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVTEA>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_tea_init');
  late final _av_tea_init = _av_tea_initPtr.asFunction<
      void Function(ffi.Pointer<AVTEA>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param ctx an AVTEA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_tea_crypt(
    ffi.Pointer<AVTEA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_tea_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_tea_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVTEA>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_tea_crypt');
  late final _av_tea_crypt = _av_tea_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVTEA>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Return the flags which specify extensions supported by the CPU.
  /// The returned value is affected by av_force_cpu_flags() if that was used
  /// before. So av_get_cpu_flags() can easily be used in an application to
  /// detect the enabled cpu flags.
  int av_get_cpu_flags() {
    return _av_get_cpu_flags();
  }

  late final _av_get_cpu_flagsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('av_get_cpu_flags');
  late final _av_get_cpu_flags =
      _av_get_cpu_flagsPtr.asFunction<int Function()>();

  /// Disables cpu detection and forces the specified flags.
  /// -1 is a special case that disables forcing of specific flags.
  void av_force_cpu_flags(
    int flags,
  ) {
    return _av_force_cpu_flags(
      flags,
    );
  }

  late final _av_force_cpu_flagsPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'av_force_cpu_flags');
  late final _av_force_cpu_flags =
      _av_force_cpu_flagsPtr.asFunction<void Function(int)>();

  /// Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
  ///
  /// @return negative on error.
  int av_parse_cpu_caps(
    ffi.Pointer<ffi.UnsignedInt> flags,
    ffi.Pointer<ffi.Char> s,
  ) {
    return _av_parse_cpu_caps(
      flags,
      s,
    );
  }

  late final _av_parse_cpu_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<ffi.Char>)>>('av_parse_cpu_caps');
  late final _av_parse_cpu_caps = _av_parse_cpu_capsPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<ffi.Char>)>();

  /// @return the number of logical CPU cores present.
  int av_cpu_count() {
    return _av_cpu_count();
  }

  late final _av_cpu_countPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('av_cpu_count');
  late final _av_cpu_count = _av_cpu_countPtr.asFunction<int Function()>();

  /// Overrides cpu count detection and forces the specified count.
  /// Count < 1 disables forcing of specific count.
  void av_cpu_force_count(
    int count,
  ) {
    return _av_cpu_force_count(
      count,
    );
  }

  late final _av_cpu_force_countPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>(
          'av_cpu_force_count');
  late final _av_cpu_force_count =
      _av_cpu_force_countPtr.asFunction<void Function(int)>();

  /// Get the maximum data alignment that may be required by FFmpeg.
  ///
  /// Note that this is affected by the build configuration and the CPU flags mask,
  /// so e.g. if the CPU supports AVX, but libavutil has been built with
  /// --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through
  /// av_set_cpu_flags_mask(), then this function will behave as if AVX is not
  /// present.
  int av_cpu_max_align() {
    return _av_cpu_max_align();
  }

  late final _av_cpu_max_alignPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>('av_cpu_max_align');
  late final _av_cpu_max_align =
      _av_cpu_max_alignPtr.asFunction<int Function()>();

  /// @brief Decodes LZO 1x compressed data.
  /// @param out output buffer
  /// @param outlen size of output buffer, number of bytes left are returned here
  /// @param in input buffer
  /// @param inlen size of input buffer, number of bytes left are returned here
  /// @return 0 on success, otherwise a combination of the error flags above
  ///
  /// Make sure all buffers are appropriately padded, in must provide
  /// AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.
  int av_lzo1x_decode(
    ffi.Pointer<ffi.Void> out,
    ffi.Pointer<ffi.Int> outlen,
    ffi.Pointer<ffi.Void> in1,
    ffi.Pointer<ffi.Int> inlen,
  ) {
    return _av_lzo1x_decode(
      out,
      outlen,
      in1,
      inlen,
    );
  }

  late final _av_lzo1x_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>>('av_lzo1x_decode');
  late final _av_lzo1x_decode = _av_lzo1x_decodePtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>();

  /// Allocate an AVDES context.
  ffi.Pointer<AVDES> av_des_alloc() {
    return _av_des_alloc();
  }

  late final _av_des_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVDES> Function()>>(
          'av_des_alloc');
  late final _av_des_alloc =
      _av_des_allocPtr.asFunction<ffi.Pointer<AVDES> Function()>();

  /// @brief Initializes an AVDES context.
  ///
  /// @param d pointer to a AVDES structure to initialize
  /// @param key pointer to the key to use
  /// @param key_bits must be 64 or 192
  /// @param decrypt 0 for encryption/CBC-MAC, 1 for decryption
  /// @return zero on success, negative value otherwise
  int av_des_init(
    ffi.Pointer<AVDES> d,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
    int decrypt,
  ) {
    return _av_des_init(
      d,
      key,
      key_bits,
      decrypt,
    );
  }

  late final _av_des_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVDES>, ffi.Pointer<ffi.Uint8>, ffi.Int,
              ffi.Int)>>('av_des_init');
  late final _av_des_init = _av_des_initPtr.asFunction<
      int Function(ffi.Pointer<AVDES>, ffi.Pointer<ffi.Uint8>, int, int)>();

  /// @brief Encrypts / decrypts using the DES algorithm.
  ///
  /// @param d pointer to the AVDES structure
  /// @param dst destination array, can be equal to src, must be 8-byte aligned
  /// @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used,
  /// must be 8-byte aligned
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_des_crypt(
    ffi.Pointer<AVDES> d,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_des_crypt(
      d,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_des_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVDES>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_des_crypt');
  late final _av_des_crypt = _av_des_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVDES>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// @brief Calculates CBC-MAC using the DES algorithm.
  ///
  /// @param d pointer to the AVDES structure
  /// @param dst destination array, can be equal to src, must be 8-byte aligned
  /// @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL
  /// @param count number of 8 byte blocks
  void av_des_mac(
    ffi.Pointer<AVDES> d,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
  ) {
    return _av_des_mac(
      d,
      dst,
      src,
      count,
    );
  }

  late final _av_des_macPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVDES>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('av_des_mac');
  late final _av_des_mac = _av_des_macPtr.asFunction<
      void Function(ffi.Pointer<AVDES>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocates an AVEncryptionInfo structure and sub-pointers to hold the given
  /// number of subsamples.  This will allocate pointers for the key ID, IV,
  /// and subsample entries, set the size members, and zero-initialize the rest.
  ///
  /// @param subsample_count The number of subsamples.
  /// @param key_id_size The number of bytes in the key ID, should be 16.
  /// @param iv_size The number of bytes in the IV, should be 16.
  ///
  /// @return The new AVEncryptionInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInfo> av_encryption_info_alloc(
    int subsample_count,
    int key_id_size,
    int iv_size,
  ) {
    return _av_encryption_info_alloc(
      subsample_count,
      key_id_size,
      iv_size,
    );
  }

  late final _av_encryption_info_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVEncryptionInfo> Function(
              ffi.Uint32, ffi.Uint32, ffi.Uint32)>>('av_encryption_info_alloc');
  late final _av_encryption_info_alloc = _av_encryption_info_allocPtr
      .asFunction<ffi.Pointer<AVEncryptionInfo> Function(int, int, int)>();

  /// Allocates an AVEncryptionInfo structure with a copy of the given data.
  /// @return The new AVEncryptionInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInfo> av_encryption_info_clone(
    ffi.Pointer<AVEncryptionInfo> info,
  ) {
    return _av_encryption_info_clone(
      info,
    );
  }

  late final _av_encryption_info_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVEncryptionInfo> Function(
              ffi.Pointer<AVEncryptionInfo>)>>('av_encryption_info_clone');
  late final _av_encryption_info_clone =
      _av_encryption_info_clonePtr.asFunction<
          ffi.Pointer<AVEncryptionInfo> Function(
              ffi.Pointer<AVEncryptionInfo>)>();

  /// Frees the given encryption info object.  This MUST NOT be used to free the
  /// side-data data pointer, that should use normal side-data methods.
  void av_encryption_info_free(
    ffi.Pointer<AVEncryptionInfo> info,
  ) {
    return _av_encryption_info_free(
      info,
    );
  }

  late final _av_encryption_info_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVEncryptionInfo>)>>(
      'av_encryption_info_free');
  late final _av_encryption_info_free = _av_encryption_info_freePtr
      .asFunction<void Function(ffi.Pointer<AVEncryptionInfo>)>();

  /// Creates a copy of the AVEncryptionInfo that is contained in the given side
  /// data.  The resulting object should be passed to av_encryption_info_free()
  /// when done.
  ///
  /// @return The new AVEncryptionInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInfo> av_encryption_info_get_side_data(
    ffi.Pointer<ffi.Uint8> side_data,
    int side_data_size,
  ) {
    return _av_encryption_info_get_side_data(
      side_data,
      side_data_size,
    );
  }

  late final _av_encryption_info_get_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVEncryptionInfo> Function(ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_encryption_info_get_side_data');
  late final _av_encryption_info_get_side_data =
      _av_encryption_info_get_side_dataPtr.asFunction<
          ffi.Pointer<AVEncryptionInfo> Function(
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocates and initializes side data that holds a copy of the given encryption
  /// info.  The resulting pointer should be either freed using av_free or given
  /// to av_packet_add_side_data().
  ///
  /// @return The new side-data pointer, or NULL.
  ffi.Pointer<ffi.Uint8> av_encryption_info_add_side_data(
    ffi.Pointer<AVEncryptionInfo> info,
    ffi.Pointer<ffi.Size> side_data_size,
  ) {
    return _av_encryption_info_add_side_data(
      info,
      side_data_size,
    );
  }

  late final _av_encryption_info_add_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVEncryptionInfo>,
              ffi.Pointer<ffi.Size>)>>('av_encryption_info_add_side_data');
  late final _av_encryption_info_add_side_data =
      _av_encryption_info_add_side_dataPtr.asFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<AVEncryptionInfo>, ffi.Pointer<ffi.Size>)>();

  /// Allocates an AVEncryptionInitInfo structure and sub-pointers to hold the
  /// given sizes.  This will allocate pointers and set all the fields.
  ///
  /// @return The new AVEncryptionInitInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInitInfo> av_encryption_init_info_alloc(
    int system_id_size,
    int num_key_ids,
    int key_id_size,
    int data_size,
  ) {
    return _av_encryption_init_info_alloc(
      system_id_size,
      num_key_ids,
      key_id_size,
      data_size,
    );
  }

  late final _av_encryption_init_info_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVEncryptionInitInfo> Function(ffi.Uint32, ffi.Uint32,
              ffi.Uint32, ffi.Uint32)>>('av_encryption_init_info_alloc');
  late final _av_encryption_init_info_alloc =
      _av_encryption_init_info_allocPtr.asFunction<
          ffi.Pointer<AVEncryptionInitInfo> Function(int, int, int, int)>();

  /// Frees the given encryption init info object.  This MUST NOT be used to free
  /// the side-data data pointer, that should use normal side-data methods.
  void av_encryption_init_info_free(
    ffi.Pointer<AVEncryptionInitInfo> info,
  ) {
    return _av_encryption_init_info_free(
      info,
    );
  }

  late final _av_encryption_init_info_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<AVEncryptionInitInfo>)>>(
      'av_encryption_init_info_free');
  late final _av_encryption_init_info_free = _av_encryption_init_info_freePtr
      .asFunction<void Function(ffi.Pointer<AVEncryptionInitInfo>)>();

  /// Creates a copy of the AVEncryptionInitInfo that is contained in the given
  /// side data.  The resulting object should be passed to
  /// av_encryption_init_info_free() when done.
  ///
  /// @return The new AVEncryptionInitInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInitInfo> av_encryption_init_info_get_side_data(
    ffi.Pointer<ffi.Uint8> side_data,
    int side_data_size,
  ) {
    return _av_encryption_init_info_get_side_data(
      side_data,
      side_data_size,
    );
  }

  late final _av_encryption_init_info_get_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVEncryptionInitInfo> Function(ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_encryption_init_info_get_side_data');
  late final _av_encryption_init_info_get_side_data =
      _av_encryption_init_info_get_side_dataPtr.asFunction<
          ffi.Pointer<AVEncryptionInitInfo> Function(
              ffi.Pointer<ffi.Uint8>, int)>();

  /// Allocates and initializes side data that holds a copy of the given encryption
  /// init info.  The resulting pointer should be either freed using av_free or
  /// given to av_packet_add_side_data().
  ///
  /// @return The new side-data pointer, or NULL.
  ffi.Pointer<ffi.Uint8> av_encryption_init_info_add_side_data(
    ffi.Pointer<AVEncryptionInitInfo> info,
    ffi.Pointer<ffi.Size> side_data_size,
  ) {
    return _av_encryption_init_info_add_side_data(
      info,
      side_data_size,
    );
  }

  late final _av_encryption_init_info_add_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVEncryptionInitInfo>,
              ffi.Pointer<ffi.Size>)>>('av_encryption_init_info_add_side_data');
  late final _av_encryption_init_info_add_side_data =
      _av_encryption_init_info_add_side_dataPtr.asFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<AVEncryptionInitInfo>, ffi.Pointer<ffi.Size>)>();

  /// @file
  /// @brief Public header for libavutil TWOFISH algorithm
  /// @defgroup lavu_twofish TWOFISH
  /// @ingroup lavu_crypto
  /// @{
  late final ffi.Pointer<ffi.Int> _av_twofish_size =
      _lookup<ffi.Int>('av_twofish_size');

  int get av_twofish_size => _av_twofish_size.value;

  /// Allocate an AVTWOFISH context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVTWOFISH> av_twofish_alloc() {
    return _av_twofish_alloc();
  }

  late final _av_twofish_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVTWOFISH> Function()>>(
          'av_twofish_alloc');
  late final _av_twofish_alloc =
      _av_twofish_allocPtr.asFunction<ffi.Pointer<AVTWOFISH> Function()>();

  /// Initialize an AVTWOFISH context.
  ///
  /// @param ctx an AVTWOFISH context
  /// @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption
  /// @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise
  int av_twofish_init(
    ffi.Pointer<AVTWOFISH> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
  ) {
    return _av_twofish_init(
      ctx,
      key,
      key_bits,
    );
  }

  late final _av_twofish_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVTWOFISH>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_twofish_init');
  late final _av_twofish_init = _av_twofish_initPtr.asFunction<
      int Function(ffi.Pointer<AVTWOFISH>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Encrypt or decrypt a buffer using a previously initialized context
  ///
  /// @param ctx an AVTWOFISH context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 16 byte blocks
  /// @param iv initialization vector for CBC mode, NULL for ECB mode
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_twofish_crypt(
    ffi.Pointer<AVTWOFISH> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    return _av_twofish_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  late final _av_twofish_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVTWOFISH>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_twofish_crypt');
  late final _av_twofish_crypt = _av_twofish_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVTWOFISH>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int)>();

  /// Compute the max pixel step for each plane of an image with a
  /// format described by pixdesc.
  ///
  /// The pixel step is the distance in bytes between the first byte of
  /// the group of bytes which describe a pixel component and the first
  /// byte of the successive group in the same plane for the same
  /// component.
  ///
  /// @param max_pixsteps an array which is filled with the max pixel step
  /// for each plane. Since a plane may contain different pixel
  /// components, the computed max_pixsteps[plane] is relative to the
  /// component in the plane with the max pixel step.
  /// @param max_pixstep_comps an array which is filled with the component
  /// for each plane which has the max pixel step. May be NULL.
  /// @param pixdesc the AVPixFmtDescriptor for the image, describing its format
  void av_image_fill_max_pixsteps(
    ffi.Pointer<ffi.Int> max_pixsteps,
    ffi.Pointer<ffi.Int> max_pixstep_comps,
    ffi.Pointer<AVPixFmtDescriptor> pixdesc,
  ) {
    return _av_image_fill_max_pixsteps(
      max_pixsteps,
      max_pixstep_comps,
      pixdesc,
    );
  }

  late final _av_image_fill_max_pixstepsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPixFmtDescriptor>)>>('av_image_fill_max_pixsteps');
  late final _av_image_fill_max_pixsteps =
      _av_image_fill_max_pixstepsPtr.asFunction<
          void Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<AVPixFmtDescriptor>)>();

  /// Compute the size of an image line with format pix_fmt and width
  /// width for the plane plane.
  ///
  /// @return the computed size in bytes
  int av_image_get_linesize(
    AVPixelFormat pix_fmt,
    int width,
    int plane,
  ) {
    return _av_image_get_linesize(
      pix_fmt.value,
      width,
      plane,
    );
  }

  late final _av_image_get_linesizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'av_image_get_linesize');
  late final _av_image_get_linesize =
      _av_image_get_linesizePtr.asFunction<int Function(int, int, int)>();

  /// Fill plane linesizes for an image with pixel format pix_fmt and
  /// width width.
  ///
  /// @param linesizes array to be filled with the linesize for each plane
  /// @param pix_fmt the AVPixelFormat of the image
  /// @param width width of the image in pixels
  /// @return >= 0 in case of success, a negative error code otherwise
  int av_image_fill_linesizes(
    ffi.Pointer<ffi.Int> linesizes,
    AVPixelFormat pix_fmt,
    int width,
  ) {
    return _av_image_fill_linesizes(
      linesizes,
      pix_fmt.value,
      width,
    );
  }

  late final _av_image_fill_linesizesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Int)>>('av_image_fill_linesizes');
  late final _av_image_fill_linesizes = _av_image_fill_linesizesPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, int, int)>();

  /// Fill plane sizes for an image with pixel format pix_fmt and height height.
  ///
  /// @param size the array to be filled with the size of each image plane
  /// @param pix_fmt the AVPixelFormat of the image
  /// @param height height of the image in pixels
  /// @param linesizes the array containing the linesize for each
  /// plane, should be filled by av_image_fill_linesizes()
  /// @return >= 0 in case of success, a negative error code otherwise
  ///
  /// @note The linesize parameters have the type ptrdiff_t here, while they are
  /// int for av_image_fill_linesizes().
  int av_image_fill_plane_sizes(
    ffi.Pointer<ffi.Size> size,
    AVPixelFormat pix_fmt,
    int height,
    ffi.Pointer<ptrdiff_t> linesizes,
  ) {
    return _av_image_fill_plane_sizes(
      size,
      pix_fmt.value,
      height,
      linesizes,
    );
  }

  late final _av_image_fill_plane_sizesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Int, ffi.Int,
              ffi.Pointer<ptrdiff_t>)>>('av_image_fill_plane_sizes');
  late final _av_image_fill_plane_sizes =
      _av_image_fill_plane_sizesPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Size>, int, int, ffi.Pointer<ptrdiff_t>)>();

  /// Fill plane data pointers for an image with pixel format pix_fmt and
  /// height height.
  ///
  /// @param data pointers array to be filled with the pointer for each image plane
  /// @param pix_fmt the AVPixelFormat of the image
  /// @param height height of the image in pixels
  /// @param ptr the pointer to a buffer which will contain the image
  /// @param linesizes the array containing the linesize for each
  /// plane, should be filled by av_image_fill_linesizes()
  /// @return the size in bytes required for the image buffer, a negative
  /// error code in case of failure
  int av_image_fill_pointers(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    AVPixelFormat pix_fmt,
    int height,
    ffi.Pointer<ffi.Uint8> ptr,
    ffi.Pointer<ffi.Int> linesizes,
  ) {
    return _av_image_fill_pointers(
      data,
      pix_fmt.value,
      height,
      ptr,
      linesizes,
    );
  }

  late final _av_image_fill_pointersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Int>)>>('av_image_fill_pointers');
  late final _av_image_fill_pointers = _av_image_fill_pointersPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int, int,
          ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Int>)>();

  /// Allocate an image with size w and h and pixel format pix_fmt, and
  /// fill pointers and linesizes accordingly.
  /// The allocated image buffer has to be freed by using
  /// av_freep(&pointers[0]).
  ///
  /// @param pointers array to be filled with the pointer for each image plane
  /// @param linesizes the array filled with the linesize for each plane
  /// @param w width of the image in pixels
  /// @param h height of the image in pixels
  /// @param pix_fmt the AVPixelFormat of the image
  /// @param align the value to use for buffer size alignment
  /// @return the size in bytes required for the image buffer, a negative
  /// error code in case of failure
  int av_image_alloc(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pointers,
    ffi.Pointer<ffi.Int> linesizes,
    int w,
    int h,
    AVPixelFormat pix_fmt,
    int align,
  ) {
    return _av_image_alloc(
      pointers,
      linesizes,
      w,
      h,
      pix_fmt.value,
      align,
    );
  }

  late final _av_image_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_alloc');
  late final _av_image_alloc = _av_image_allocPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Int>,
          int, int, int, int)>();

  /// Copy image plane from src to dst.
  /// That is, copy "height" number of lines of "bytewidth" bytes each.
  /// The first byte of each successive line is separated by *_linesize
  /// bytes.
  ///
  /// bytewidth must be contained by both absolute values of dst_linesize
  /// and src_linesize, otherwise the function behavior is undefined.
  ///
  /// @param dst          destination plane to copy to
  /// @param dst_linesize linesize for the image plane in dst
  /// @param src          source plane to copy from
  /// @param src_linesize linesize for the image plane in src
  /// @param height       height (number of lines) of the plane
  void av_image_copy_plane(
    ffi.Pointer<ffi.Uint8> dst,
    int dst_linesize,
    ffi.Pointer<ffi.Uint8> src,
    int src_linesize,
    int bytewidth,
    int height,
  ) {
    return _av_image_copy_plane(
      dst,
      dst_linesize,
      src,
      src_linesize,
      bytewidth,
      height,
    );
  }

  late final _av_image_copy_planePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_copy_plane');
  late final _av_image_copy_plane = _av_image_copy_planePtr.asFunction<
      void Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>, int,
          int, int)>();

  /// Copy image data located in uncacheable (e.g. GPU mapped) memory. Where
  /// available, this function will use special functionality for reading from such
  /// memory, which may result in greatly improved performance compared to plain
  /// av_image_copy_plane().
  ///
  /// bytewidth must be contained by both absolute values of dst_linesize
  /// and src_linesize, otherwise the function behavior is undefined.
  ///
  /// @note The linesize parameters have the type ptrdiff_t here, while they are
  /// int for av_image_copy_plane().
  /// @note On x86, the linesizes currently need to be aligned to the cacheline
  /// size (i.e. 64) to get improved performance.
  void av_image_copy_plane_uc_from(
    ffi.Pointer<ffi.Uint8> dst,
    int dst_linesize,
    ffi.Pointer<ffi.Uint8> src,
    int src_linesize,
    int bytewidth,
    int height,
  ) {
    return _av_image_copy_plane_uc_from(
      dst,
      dst_linesize,
      src,
      src_linesize,
      bytewidth,
      height,
    );
  }

  late final _av_image_copy_plane_uc_fromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>,
              ptrdiff_t,
              ffi.Pointer<ffi.Uint8>,
              ptrdiff_t,
              ptrdiff_t,
              ffi.Int)>>('av_image_copy_plane_uc_from');
  late final _av_image_copy_plane_uc_from =
      _av_image_copy_plane_uc_fromPtr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, int, ffi.Pointer<ffi.Uint8>,
              int, int, int)>();

  /// Copy image in src_data to dst_data.
  ///
  /// @param dst_data      destination image data buffer to copy to
  /// @param dst_linesizes linesizes for the image in dst_data
  /// @param src_data      source image data buffer to copy from
  /// @param src_linesizes linesizes for the image in src_data
  /// @param pix_fmt       the AVPixelFormat of the image
  /// @param width         width of the image in pixels
  /// @param height        height of the image in pixels
  void av_image_copy(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ffi.Int> dst_linesizes,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
    ffi.Pointer<ffi.Int> src_linesizes,
    AVPixelFormat pix_fmt,
    int width,
    int height,
  ) {
    return _av_image_copy(
      dst_data,
      dst_linesizes,
      src_data,
      src_linesizes,
      pix_fmt.value,
      width,
      height,
    );
  }

  late final _av_image_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_copy');
  late final _av_image_copy = _av_image_copyPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          int)>();

  /// Copy image data located in uncacheable (e.g. GPU mapped) memory. Where
  /// available, this function will use special functionality for reading from such
  /// memory, which may result in greatly improved performance compared to plain
  /// av_image_copy().
  ///
  /// The data pointers and the linesizes must be aligned to the maximum required
  /// by the CPU architecture.
  ///
  /// @note The linesize parameters have the type ptrdiff_t here, while they are
  /// int for av_image_copy().
  /// @note On x86, the linesizes currently need to be aligned to the cacheline
  /// size (i.e. 64) to get improved performance.
  void av_image_copy_uc_from(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ptrdiff_t> dst_linesizes,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
    ffi.Pointer<ptrdiff_t> src_linesizes,
    AVPixelFormat pix_fmt,
    int width,
    int height,
  ) {
    return _av_image_copy_uc_from(
      dst_data,
      dst_linesizes,
      src_data,
      src_linesizes,
      pix_fmt.value,
      width,
      height,
    );
  }

  late final _av_image_copy_uc_fromPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ptrdiff_t>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ptrdiff_t>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_copy_uc_from');
  late final _av_image_copy_uc_from = _av_image_copy_uc_fromPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ptrdiff_t>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ptrdiff_t>,
          int,
          int,
          int)>();

  /// Setup the data pointers and linesizes based on the specified image
  /// parameters and the provided array.
  ///
  /// The fields of the given image are filled in by using the src
  /// address which points to the image data buffer. Depending on the
  /// specified pixel format, one or multiple image data pointers and
  /// line sizes will be set.  If a planar format is specified, several
  /// pointers will be set pointing to the different picture planes and
  /// the line sizes of the different planes will be stored in the
  /// lines_sizes array. Call with src == NULL to get the required
  /// size for the src buffer.
  ///
  /// To allocate the buffer and fill in the dst_data and dst_linesize in
  /// one call, use av_image_alloc().
  ///
  /// @param dst_data      data pointers to be filled in
  /// @param dst_linesize  linesizes for the image in dst_data to be filled in
  /// @param src           buffer which will contain or contains the actual image data, can be NULL
  /// @param pix_fmt       the pixel format of the image
  /// @param width         the width of the image in pixels
  /// @param height        the height of the image in pixels
  /// @param align         the value used in src for linesize alignment
  /// @return the size in bytes required for src, a negative error code
  /// in case of failure
  int av_image_fill_arrays(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ffi.Int> dst_linesize,
    ffi.Pointer<ffi.Uint8> src,
    AVPixelFormat pix_fmt,
    int width,
    int height,
    int align,
  ) {
    return _av_image_fill_arrays(
      dst_data,
      dst_linesize,
      src,
      pix_fmt.value,
      width,
      height,
      align,
    );
  }

  late final _av_image_fill_arraysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_fill_arrays');
  late final _av_image_fill_arrays = _av_image_fill_arraysPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Uint8>, int, int, int, int)>();

  /// Return the size in bytes of the amount of data required to store an
  /// image with the given parameters.
  ///
  /// @param pix_fmt  the pixel format of the image
  /// @param width    the width of the image in pixels
  /// @param height   the height of the image in pixels
  /// @param align    the assumed linesize alignment
  /// @return the buffer size in bytes, a negative error code in case of failure
  int av_image_get_buffer_size(
    AVPixelFormat pix_fmt,
    int width,
    int height,
    int align,
  ) {
    return _av_image_get_buffer_size(
      pix_fmt.value,
      width,
      height,
      align,
    );
  }

  late final _av_image_get_buffer_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Int, ffi.Int, ffi.Int)>>('av_image_get_buffer_size');
  late final _av_image_get_buffer_size = _av_image_get_buffer_sizePtr
      .asFunction<int Function(int, int, int, int)>();

  /// Copy image data from an image into a buffer.
  ///
  /// av_image_get_buffer_size() can be used to compute the required size
  /// for the buffer to fill.
  ///
  /// @param dst           a buffer into which picture data will be copied
  /// @param dst_size      the size in bytes of dst
  /// @param src_data      pointers containing the source image data
  /// @param src_linesize  linesizes for the image in src_data
  /// @param pix_fmt       the pixel format of the source image
  /// @param width         the width of the source image in pixels
  /// @param height        the height of the source image in pixels
  /// @param align         the assumed linesize alignment for dst
  /// @return the number of bytes written to dst, or a negative value
  /// (error code) on error
  int av_image_copy_to_buffer(
    ffi.Pointer<ffi.Uint8> dst,
    int dst_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
    ffi.Pointer<ffi.Int> src_linesize,
    AVPixelFormat pix_fmt,
    int width,
    int height,
    int align,
  ) {
    return _av_image_copy_to_buffer(
      dst,
      dst_size,
      src_data,
      src_linesize,
      pix_fmt.value,
      width,
      height,
      align,
    );
  }

  late final _av_image_copy_to_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_copy_to_buffer');
  late final _av_image_copy_to_buffer = _av_image_copy_to_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Uint8>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          int,
          int)>();

  /// Check if the given dimension of an image is valid, meaning that all
  /// bytes of the image can be addressed with a signed int.
  ///
  /// @param w the width of the picture
  /// @param h the height of the picture
  /// @param log_offset the offset to sum to the log level for logging with log_ctx
  /// @param log_ctx the parent logging context, it may be NULL
  /// @return >= 0 if valid, a negative error code otherwise
  int av_image_check_size(
    int w,
    int h,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_image_check_size(
      w,
      h,
      log_offset,
      log_ctx,
    );
  }

  late final _av_image_check_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.Int,
              ffi.Pointer<ffi.Void>)>>('av_image_check_size');
  late final _av_image_check_size = _av_image_check_sizePtr
      .asFunction<int Function(int, int, int, ffi.Pointer<ffi.Void>)>();

  /// Check if the given dimension of an image is valid, meaning that all
  /// bytes of a plane of an image with the specified pix_fmt can be addressed
  /// with a signed int.
  ///
  /// @param w the width of the picture
  /// @param h the height of the picture
  /// @param max_pixels the maximum number of pixels the user wants to accept
  /// @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.
  /// @param log_offset the offset to sum to the log level for logging with log_ctx
  /// @param log_ctx the parent logging context, it may be NULL
  /// @return >= 0 if valid, a negative error code otherwise
  int av_image_check_size2(
    int w,
    int h,
    int max_pixels,
    AVPixelFormat pix_fmt,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_image_check_size2(
      w,
      h,
      max_pixels,
      pix_fmt.value,
      log_offset,
      log_ctx,
    );
  }

  late final _av_image_check_size2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.Int64, ffi.Int,
              ffi.Int, ffi.Pointer<ffi.Void>)>>('av_image_check_size2');
  late final _av_image_check_size2 = _av_image_check_size2Ptr.asFunction<
      int Function(int, int, int, int, int, ffi.Pointer<ffi.Void>)>();

  /// Check if the given sample aspect ratio of an image is valid.
  ///
  /// It is considered invalid if the denominator is 0 or if applying the ratio
  /// to the image size would make the smaller dimension less than 1. If the
  /// sar numerator is 0, it is considered unknown and will return as valid.
  ///
  /// @param w width of the image
  /// @param h height of the image
  /// @param sar sample aspect ratio of the image
  /// @return 0 if valid, a negative AVERROR code otherwise
  int av_image_check_sar(
    int w,
    int h,
    AVRational sar,
  ) {
    return _av_image_check_sar(
      w,
      h,
      sar,
    );
  }

  late final _av_image_check_sarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.UnsignedInt,
              AVRational)>>('av_image_check_sar');
  late final _av_image_check_sar =
      _av_image_check_sarPtr.asFunction<int Function(int, int, AVRational)>();

  /// Overwrite the image data with black. This is suitable for filling a
  /// sub-rectangle of an image, meaning the padding between the right most pixel
  /// and the left most pixel on the next line will not be overwritten. For some
  /// formats, the image size might be rounded up due to inherent alignment.
  ///
  /// If the pixel format has alpha, the alpha is cleared to opaque.
  ///
  /// This can return an error if the pixel format is not supported. Normally, all
  /// non-hwaccel pixel formats should be supported.
  ///
  /// Passing NULL for dst_data is allowed. Then the function returns whether the
  /// operation would have succeeded. (It can return an error if the pix_fmt is
  /// not supported.)
  ///
  /// @param dst_data      data pointers to destination image
  /// @param dst_linesize  linesizes for the destination image
  /// @param pix_fmt       the pixel format of the image
  /// @param range         the color range of the image (important for colorspaces such as YUV)
  /// @param width         the width of the image in pixels
  /// @param height        the height of the image in pixels
  /// @return 0 if the image data was cleared, a negative AVERROR code otherwise
  int av_image_fill_black(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ptrdiff_t> dst_linesize,
    AVPixelFormat pix_fmt,
    AVColorRange range,
    int width,
    int height,
  ) {
    return _av_image_fill_black(
      dst_data,
      dst_linesize,
      pix_fmt.value,
      range.value,
      width,
      height,
    );
  }

  late final _av_image_fill_blackPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ptrdiff_t>,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.Int,
              ffi.Int)>>('av_image_fill_black');
  late final _av_image_fill_black = _av_image_fill_blackPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ptrdiff_t>,
          int, int, int, int)>();

  /// Overwrite the image data with a color. This is suitable for filling a
  /// sub-rectangle of an image, meaning the padding between the right most pixel
  /// and the left most pixel on the next line will not be overwritten. For some
  /// formats, the image size might be rounded up due to inherent alignment.
  ///
  /// If the pixel format has alpha, it is also replaced. Color component values
  /// are interpreted as native integers (or intfloats) regardless of actual pixel
  /// format endianness.
  ///
  /// This can return an error if the pixel format is not supported. Normally, all
  /// non-hwaccel pixel formats should be supported.
  ///
  /// Passing NULL for dst_data is allowed. Then the function returns whether the
  /// operation would have succeeded. (It can return an error if the pix_fmt is
  /// not supported.)
  ///
  /// @param dst_data      data pointers to destination image
  /// @param dst_linesize  linesizes for the destination image
  /// @param pix_fmt       the pixel format of the image
  /// @param color         the color components to be used for the fill
  /// @param width         the width of the image in pixels
  /// @param height        the height of the image in pixels
  /// @param flags         currently unused
  /// @return 0 if the image data was filled, a negative AVERROR code otherwise
  int av_image_fill_color(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ptrdiff_t> dst_linesize,
    AVPixelFormat pix_fmt,
    ffi.Pointer<ffi.Uint32> color,
    int width,
    int height,
    int flags,
  ) {
    return _av_image_fill_color(
      dst_data,
      dst_linesize,
      pix_fmt.value,
      color,
      width,
      height,
      flags,
    );
  }

  late final _av_image_fill_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ptrdiff_t>,
              ffi.Int,
              ffi.Pointer<ffi.Uint32>,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('av_image_fill_color');
  late final _av_image_fill_color = _av_image_fill_colorPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ptrdiff_t>,
          int, ffi.Pointer<ffi.Uint32>, int, int, int)>();

  /// Allocates memory for AVVideoEncParams of the given type, plus an array of
  /// {@code nb_blocks} AVVideoBlockParams and initializes the variables. Can be
  /// freed with a normal av_free() call.
  ///
  /// @param out_size if non-NULL, the size in bytes of the resulting data array is
  /// written here.
  ffi.Pointer<AVVideoEncParams> av_video_enc_params_alloc(
    AVVideoEncParamsType type,
    int nb_blocks,
    ffi.Pointer<ffi.Size> out_size,
  ) {
    return _av_video_enc_params_alloc(
      type.value,
      nb_blocks,
      out_size,
    );
  }

  late final _av_video_enc_params_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVVideoEncParams> Function(ffi.Int, ffi.UnsignedInt,
              ffi.Pointer<ffi.Size>)>>('av_video_enc_params_alloc');
  late final _av_video_enc_params_alloc =
      _av_video_enc_params_allocPtr.asFunction<
          ffi.Pointer<AVVideoEncParams> Function(
              int, int, ffi.Pointer<ffi.Size>)>();

  /// Allocates memory for AVEncodeInfoFrame plus an array of
  /// {@code nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}
  /// as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS
  /// and initializes the variables.
  ffi.Pointer<AVVideoEncParams> av_video_enc_params_create_side_data(
    ffi.Pointer<AVFrame> frame,
    AVVideoEncParamsType type,
    int nb_blocks,
  ) {
    return _av_video_enc_params_create_side_data(
      frame,
      type.value,
      nb_blocks,
    );
  }

  late final _av_video_enc_params_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVVideoEncParams> Function(ffi.Pointer<AVFrame>, ffi.Int,
              ffi.UnsignedInt)>>('av_video_enc_params_create_side_data');
  late final _av_video_enc_params_create_side_data =
      _av_video_enc_params_create_side_dataPtr.asFunction<
          ffi.Pointer<AVVideoEncParams> Function(
              ffi.Pointer<AVFrame>, int, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  late final ffi.Pointer<ffi.Int> _getdate_err =
      _lookup<ffi.Int>('getdate_err');

  int get getdate_err => _getdate_err.value;

  set getdate_err(int value) => _getdate_err.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  ffi.Pointer<ffi.Char> asctime(
    ffi.Pointer<tm> arg0,
  ) {
    return _asctime(
      arg0,
    );
  }

  late final _asctimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>>(
      'asctime');
  late final _asctime =
      _asctimePtr.asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>();

  int clock() {
    return _clock();
  }

  late final _clockPtr =
      _lookup<ffi.NativeFunction<clock_t Function()>>('clock');
  late final _clock = _clockPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> ctime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _ctime(
      arg0,
    );
  }

  late final _ctimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>>('ctime');
  late final _ctime = _ctimePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>();

  double difftime(
    int arg0,
    int arg1,
  ) {
    return _difftime(
      arg0,
      arg1,
    );
  }

  late final _difftimePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(time_t, time_t)>>(
          'difftime');
  late final _difftime = _difftimePtr.asFunction<double Function(int, int)>();

  ffi.Pointer<tm> getdate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getdate(
      arg0,
    );
  }

  late final _getdatePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<ffi.Char>)>>(
      'getdate');
  late final _getdate =
      _getdatePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tm> gmtime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _gmtime(
      arg0,
    );
  }

  late final _gmtimePtr = _lookup<
      ffi
      .NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>('gmtime');
  late final _gmtime =
      _gmtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> localtime(
    ffi.Pointer<time_t> arg0,
  ) {
    return _localtime(
      arg0,
    );
  }

  late final _localtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'localtime');
  late final _localtime =
      _localtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  int mktime(
    ffi.Pointer<tm> arg0,
  ) {
    return _mktime(
      arg0,
    );
  }

  late final _mktimePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('mktime');
  late final _mktime = _mktimePtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int strftime(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
    ffi.Pointer<tm> arg3,
  ) {
    return _strftime(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _strftimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strftime');
  late final _strftime = _strftimePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> strptime(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<tm> arg2,
  ) {
    return _strptime(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _strptimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strptime');
  late final _strptime = _strptimePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>();

  int time(
    ffi.Pointer<time_t> arg0,
  ) {
    return _time(
      arg0,
    );
  }

  late final _timePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<time_t>)>>('time');
  late final _time = _timePtr.asFunction<int Function(ffi.Pointer<time_t>)>();

  void tzset() {
    return _tzset();
  }

  late final _tzsetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzset');
  late final _tzset = _tzsetPtr.asFunction<void Function()>();

  ffi.Pointer<ffi.Char> asctime_r(
    ffi.Pointer<tm> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _asctime_r(
      arg0,
      arg1,
    );
  }

  late final _asctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>>('asctime_r');
  late final _asctime_r = _asctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _ctime_r(
      arg0,
      arg1,
    );
  }

  late final _ctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>>('ctime_r');
  late final _ctime_r = _ctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<tm> gmtime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<tm> arg1,
  ) {
    return _gmtime_r(
      arg0,
      arg1,
    );
  }

  late final _gmtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('gmtime_r');
  late final _gmtime_r = _gmtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<tm> localtime_r(
    ffi.Pointer<time_t> arg0,
    ffi.Pointer<tm> arg1,
  ) {
    return _localtime_r(
      arg0,
      arg1,
    );
  }

  late final _localtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('localtime_r');
  late final _localtime_r = _localtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  int posix2time(
    int arg0,
  ) {
    return _posix2time(
      arg0,
    );
  }

  late final _posix2timePtr =
      _lookup<ffi.NativeFunction<time_t Function(time_t)>>('posix2time');
  late final _posix2time = _posix2timePtr.asFunction<int Function(int)>();

  void tzsetwall() {
    return _tzsetwall();
  }

  late final _tzsetwallPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzsetwall');
  late final _tzsetwall = _tzsetwallPtr.asFunction<void Function()>();

  int time2posix(
    int arg0,
  ) {
    return _time2posix(
      arg0,
    );
  }

  late final _time2posixPtr =
      _lookup<ffi.NativeFunction<time_t Function(time_t)>>('time2posix');
  late final _time2posix = _time2posixPtr.asFunction<int Function(int)>();

  int timelocal(
    ffi.Pointer<tm> arg0,
  ) {
    return _timelocal(
      arg0,
    );
  }

  late final _timelocalPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>(
          'timelocal');
  late final _timelocal =
      _timelocalPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int timegm(
    ffi.Pointer<tm> arg0,
  ) {
    return _timegm(
      arg0,
    );
  }

  late final _timegmPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('timegm');
  late final _timegm = _timegmPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int nanosleep(
    ffi.Pointer<timespec> __rqtp,
    ffi.Pointer<timespec> __rmtp,
  ) {
    return _nanosleep(
      __rqtp,
      __rmtp,
    );
  }

  late final _nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<timespec>, ffi.Pointer<timespec>)>>('nanosleep');
  late final _nanosleep = _nanosleepPtr
      .asFunction<int Function(ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getres(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __res,
  ) {
    return _clock_getres(
      __clock_id.value,
      __res,
    );
  }

  late final _clock_getresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_getres');
  late final _clock_getres =
      _clock_getresPtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_gettime(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_gettime(
      __clock_id.value,
      __tp,
    );
  }

  late final _clock_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_gettime');
  late final _clock_gettime =
      _clock_gettimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  Dart__uint64_t clock_gettime_nsec_np(
    clockid_t __clock_id,
  ) {
    return _clock_gettime_nsec_np(
      __clock_id.value,
    );
  }

  late final _clock_gettime_nsec_npPtr =
      _lookup<ffi.NativeFunction<__uint64_t Function(ffi.UnsignedInt)>>(
          'clock_gettime_nsec_np');
  late final _clock_gettime_nsec_np =
      _clock_gettime_nsec_npPtr.asFunction<int Function(int)>();

  int clock_settime(
    clockid_t __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_settime(
      __clock_id.value,
      __tp,
    );
  }

  late final _clock_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<timespec>)>>('clock_settime');
  late final _clock_settime =
      _clock_settimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int timespec_get(
    ffi.Pointer<timespec> ts,
    int base,
  ) {
    return _timespec_get(
      ts,
      base,
    );
  }

  late final _timespec_getPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<timespec>, ffi.Int)>>(
      'timespec_get');
  late final _timespec_get =
      _timespec_getPtr.asFunction<int Function(ffi.Pointer<timespec>, int)>();

  /// Parse str and store the parsed ratio in q.
  ///
  /// Note that a ratio with infinite (1/0) or negative value is
  /// considered valid, so you should check on the returned value if you
  /// want to exclude those values.
  ///
  /// The undefined value can be expressed using the "0:0" string.
  ///
  /// @param[in,out] q pointer to the AVRational which will contain the ratio
  /// @param[in] str the string to parse: it has to be a string in the format
  /// num:den, a float number or an expression
  /// @param[in] max the maximum allowed numerator and denominator
  /// @param[in] log_offset log level offset which is applied to the log
  /// level of log_ctx
  /// @param[in] log_ctx parent logging context
  /// @return >= 0 on success, a negative error code otherwise
  int av_parse_ratio(
    ffi.Pointer<AVRational> q,
    ffi.Pointer<ffi.Char> str,
    int max,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_parse_ratio(
      q,
      str,
      max,
      log_offset,
      log_ctx,
    );
  }

  late final _av_parse_ratioPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVRational>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Int, ffi.Pointer<ffi.Void>)>>('av_parse_ratio');
  late final _av_parse_ratio = _av_parse_ratioPtr.asFunction<
      int Function(ffi.Pointer<AVRational>, ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Void>)>();

  /// Parse str and put in width_ptr and height_ptr the detected values.
  ///
  /// @param[in,out] width_ptr pointer to the variable which will contain the detected
  /// width value
  /// @param[in,out] height_ptr pointer to the variable which will contain the detected
  /// height value
  /// @param[in] str the string to parse: it has to be a string in the format
  /// width x height or a valid video size abbreviation.
  /// @return >= 0 on success, a negative error code otherwise
  int av_parse_video_size(
    ffi.Pointer<ffi.Int> width_ptr,
    ffi.Pointer<ffi.Int> height_ptr,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _av_parse_video_size(
      width_ptr,
      height_ptr,
      str,
    );
  }

  late final _av_parse_video_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('av_parse_video_size');
  late final _av_parse_video_size = _av_parse_video_sizePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Parse str and store the detected values in *rate.
  ///
  /// @param[in,out] rate pointer to the AVRational which will contain the detected
  /// frame rate
  /// @param[in] str the string to parse: it has to be a string in the format
  /// rate_num / rate_den, a float number or a valid video rate abbreviation
  /// @return >= 0 on success, a negative error code otherwise
  int av_parse_video_rate(
    ffi.Pointer<AVRational> rate,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _av_parse_video_rate(
      rate,
      str,
    );
  }

  late final _av_parse_video_ratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVRational>,
              ffi.Pointer<ffi.Char>)>>('av_parse_video_rate');
  late final _av_parse_video_rate = _av_parse_video_ratePtr.asFunction<
      int Function(ffi.Pointer<AVRational>, ffi.Pointer<ffi.Char>)>();

  /// Put the RGBA values that correspond to color_string in rgba_color.
  ///
  /// @param rgba_color 4-elements array of uint8_t values, where the respective
  /// red, green, blue and alpha component values are written.
  /// @param color_string a string specifying a color. It can be the name of
  /// a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,
  /// possibly followed by "@" and a string representing the alpha
  /// component.
  /// The alpha component may be a string composed by "0x" followed by an
  /// hexadecimal number or a decimal number between 0.0 and 1.0, which
  /// represents the opacity value (0x00/0.0 means completely transparent,
  /// 0xff/1.0 completely opaque).
  /// If the alpha component is not specified then 0xff is assumed.
  /// The string "random" will result in a random color.
  /// @param slen length of the initial part of color_string containing the
  /// color. It can be set to -1 if color_string is a null terminated string
  /// containing nothing else than the color.
  /// @param log_ctx a pointer to an arbitrary struct of which the first field
  /// is a pointer to an AVClass struct (used for av_log()). Can be NULL.
  /// @return >= 0 in case of success, a negative value in case of
  /// failure (for example if color_string cannot be parsed).
  int av_parse_color(
    ffi.Pointer<ffi.Uint8> rgba_color,
    ffi.Pointer<ffi.Char> color_string,
    int slen,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _av_parse_color(
      rgba_color,
      color_string,
      slen,
      log_ctx,
    );
  }

  late final _av_parse_colorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Char>,
              ffi.Int, ffi.Pointer<ffi.Void>)>>('av_parse_color');
  late final _av_parse_color = _av_parse_colorPtr.asFunction<
      int Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Void>)>();

  /// Get the name of a color from the internal table of hard-coded named
  /// colors.
  ///
  /// This function is meant to enumerate the color names recognized by
  /// av_parse_color().
  ///
  /// @param color_idx index of the requested color, starting from 0
  /// @param rgb      if not NULL, will point to a 3-elements array with the color value in RGB
  /// @return the color name string or NULL if color_idx is not in the array
  ffi.Pointer<ffi.Char> av_get_known_color_name(
    int color_idx,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> rgb,
  ) {
    return _av_get_known_color_name(
      color_idx,
      rgb,
    );
  }

  late final _av_get_known_color_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>>('av_get_known_color_name');
  late final _av_get_known_color_name = _av_get_known_color_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          int, ffi.Pointer<ffi.Pointer<ffi.Uint8>>)>();

  /// Parse timestr and return in *time a corresponding number of
  /// microseconds.
  ///
  /// @param timeval puts here the number of microseconds corresponding
  /// to the string in timestr. If the string represents a duration, it
  /// is the number of microseconds contained in the time interval.  If
  /// the string is a date, is the number of microseconds since 1st of
  /// January, 1970 up to the time of the parsed date.  If timestr cannot
  /// be successfully parsed, set *time to INT64_MIN.
  ///
  /// @param timestr a string representing a date or a duration.
  /// - If a date the syntax is:
  /// @code
  /// [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]
  /// now
  /// @endcode
  /// If the value is "now" it takes the current time.
  /// Time is local time unless Z is appended, in which case it is
  /// interpreted as UTC.
  /// If the year-month-day part is not specified it takes the current
  /// year-month-day.
  /// - If a duration the syntax is:
  /// @code
  /// [-][HH:]MM:SS[.m...]
  /// [-]S+[.m...]
  /// @endcode
  /// @param duration flag which tells how to interpret timestr, if not
  /// zero timestr is interpreted as a duration, otherwise as a date
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code otherwise
  int av_parse_time(
    ffi.Pointer<ffi.Int64> timeval,
    ffi.Pointer<ffi.Char> timestr,
    int duration,
  ) {
    return _av_parse_time(
      timeval,
      timestr,
      duration,
    );
  }

  late final _av_parse_timePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('av_parse_time');
  late final _av_parse_time = _av_parse_timePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<ffi.Char>, int)>();

  /// Attempt to find a specific tag in a URL.
  ///
  /// syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.
  /// Return 1 if found.
  int av_find_info_tag(
    ffi.Pointer<ffi.Char> arg,
    int arg_size,
    ffi.Pointer<ffi.Char> tag1,
    ffi.Pointer<ffi.Char> info,
  ) {
    return _av_find_info_tag(
      arg,
      arg_size,
      tag1,
      info,
    );
  }

  late final _av_find_info_tagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('av_find_info_tag');
  late final _av_find_info_tag = _av_find_info_tagPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Simplified version of strptime
  ///
  /// Parse the input string p according to the format string fmt and
  /// store its results in the structure dt.
  /// This implementation supports only a subset of the formats supported
  /// by the standard strptime().
  ///
  /// The supported input field descriptors are listed below.
  /// - `%%H`: the hour as a decimal number, using a 24-hour clock, in the
  /// range '00' through '23'
  /// - `%%J`: hours as a decimal number, in the range '0' through INT_MAX
  /// - `%%M`: the minute as a decimal number, using a 24-hour clock, in the
  /// range '00' through '59'
  /// - `%%S`: the second as a decimal number, using a 24-hour clock, in the
  /// range '00' through '59'
  /// - `%%Y`: the year as a decimal number, using the Gregorian calendar
  /// - `%%m`: the month as a decimal number, in the range '1' through '12'
  /// - `%%d`: the day of the month as a decimal number, in the range '1'
  /// through '31'
  /// - `%%T`: alias for `%%H:%%M:%%S`
  /// - `%%`: a literal `%`
  ///
  /// @return a pointer to the first character not processed in this function
  /// call. In case the input string contains more characters than
  /// required by the format string the return value points right after
  /// the last consumed input character. In case the whole input string
  /// is consumed the return value points to the null byte at the end of
  /// the string. On failure NULL is returned.
  ffi.Pointer<ffi.Char> av_small_strptime(
    ffi.Pointer<ffi.Char> p,
    ffi.Pointer<ffi.Char> fmt,
    ffi.Pointer<tm> dt,
  ) {
    return _av_small_strptime(
      p,
      fmt,
      dt,
    );
  }

  late final _av_small_strptimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('av_small_strptime');
  late final _av_small_strptime = _av_small_strptimePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>();

  /// Convert the decomposed UTC time in tm to a time_t value.
  int av_timegm(
    ffi.Pointer<tm> tm,
  ) {
    return _av_timegm(
      tm,
    );
  }

  late final _av_timegmPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>(
          'av_timegm');
  late final _av_timegm =
      _av_timegmPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  /// @defgroup lavu_ripemd RIPEMD
  /// @ingroup lavu_hash
  /// RIPEMD hash function implementation.
  ///
  /// @{
  late final ffi.Pointer<ffi.Int> _av_ripemd_size =
      _lookup<ffi.Int>('av_ripemd_size');

  int get av_ripemd_size => _av_ripemd_size.value;

  /// Allocate an AVRIPEMD context.
  ffi.Pointer<AVRIPEMD> av_ripemd_alloc() {
    return _av_ripemd_alloc();
  }

  late final _av_ripemd_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVRIPEMD> Function()>>(
          'av_ripemd_alloc');
  late final _av_ripemd_alloc =
      _av_ripemd_allocPtr.asFunction<ffi.Pointer<AVRIPEMD> Function()>();

  /// Initialize RIPEMD hashing.
  ///
  /// @param context pointer to the function context (of size av_ripemd_size)
  /// @param bits    number of bits in digest (128, 160, 256 or 320 bits)
  /// @return        zero if initialization succeeded, -1 otherwise
  int av_ripemd_init(
    ffi.Pointer<AVRIPEMD> context,
    int bits,
  ) {
    return _av_ripemd_init(
      context,
      bits,
    );
  }

  late final _av_ripemd_initPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVRIPEMD>, ffi.Int)>>(
      'av_ripemd_init');
  late final _av_ripemd_init =
      _av_ripemd_initPtr.asFunction<int Function(ffi.Pointer<AVRIPEMD>, int)>();

  /// Update hash value.
  ///
  /// @param context hash function context
  /// @param data    input data to update hash with
  /// @param len     input data length
  void av_ripemd_update(
    ffi.Pointer<AVRIPEMD> context,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    return _av_ripemd_update(
      context,
      data,
      len,
    );
  }

  late final _av_ripemd_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVRIPEMD>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_ripemd_update');
  late final _av_ripemd_update = _av_ripemd_updatePtr.asFunction<
      void Function(ffi.Pointer<AVRIPEMD>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finish hashing and output digest value.
  ///
  /// @param context hash function context
  /// @param digest  buffer where output digest value is stored
  void av_ripemd_final(
    ffi.Pointer<AVRIPEMD> context,
    ffi.Pointer<ffi.Uint8> digest,
  ) {
    return _av_ripemd_final(
      context,
      digest,
    );
  }

  late final _av_ripemd_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVRIPEMD>,
              ffi.Pointer<ffi.Uint8>)>>('av_ripemd_final');
  late final _av_ripemd_final = _av_ripemd_finalPtr.asFunction<
      void Function(ffi.Pointer<AVRIPEMD>, ffi.Pointer<ffi.Uint8>)>();

  /// Return non-zero if pfx is a prefix of str. If it is, *ptr is set to
  /// the address of the first character in str after the prefix.
  ///
  /// @param str input string
  /// @param pfx prefix to test
  /// @param ptr updated if the prefix is matched inside str
  /// @return non-zero if the prefix matches, zero otherwise
  int av_strstart(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> pfx,
    ffi.Pointer<ffi.Pointer<ffi.Char>> ptr,
  ) {
    return _av_strstart(
      str,
      pfx,
      ptr,
    );
  }

  late final _av_strstartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('av_strstart');
  late final _av_strstart = _av_strstartPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Return non-zero if pfx is a prefix of str independent of case. If
  /// it is, *ptr is set to the address of the first character in str
  /// after the prefix.
  ///
  /// @param str input string
  /// @param pfx prefix to test
  /// @param ptr updated if the prefix is matched inside str
  /// @return non-zero if the prefix matches, zero otherwise
  int av_stristart(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> pfx,
    ffi.Pointer<ffi.Pointer<ffi.Char>> ptr,
  ) {
    return _av_stristart(
      str,
      pfx,
      ptr,
    );
  }

  late final _av_stristartPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('av_stristart');
  late final _av_stristart = _av_stristartPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Locate the first case-independent occurrence in the string haystack
  /// of the string needle.  A zero-length string needle is considered to
  /// match at the start of haystack.
  ///
  /// This function is a case-insensitive version of the standard strstr().
  ///
  /// @param haystack string to search in
  /// @param needle   string to search for
  /// @return         pointer to the located match within haystack
  /// or a null pointer if no match
  ffi.Pointer<ffi.Char> av_stristr(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
  ) {
    return _av_stristr(
      haystack,
      needle,
    );
  }

  late final _av_stristrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('av_stristr');
  late final _av_stristr = _av_stristrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Locate the first occurrence of the string needle in the string haystack
  /// where not more than hay_length characters are searched. A zero-length
  /// string needle is considered to match at the start of haystack.
  ///
  /// This function is a length-limited version of the standard strstr().
  ///
  /// @param haystack   string to search in
  /// @param needle     string to search for
  /// @param hay_length length of string to search in
  /// @return           pointer to the located match within haystack
  /// or a null pointer if no match
  ffi.Pointer<ffi.Char> av_strnstr(
    ffi.Pointer<ffi.Char> haystack,
    ffi.Pointer<ffi.Char> needle,
    int hay_length,
  ) {
    return _av_strnstr(
      haystack,
      needle,
      hay_length,
    );
  }

  late final _av_strnstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('av_strnstr');
  late final _av_strnstr = _av_strnstrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Copy the string src to dst, but no more than size - 1 bytes, and
  /// null-terminate dst.
  ///
  /// This function is the same as BSD strlcpy().
  ///
  /// @param dst destination buffer
  /// @param src source string
  /// @param size size of destination buffer
  /// @return the length of src
  ///
  /// @warning since the return value is the length of src, src absolutely
  /// _must_ be a properly 0-terminated string, otherwise this will read beyond
  /// the end of the buffer and possibly crash.
  int av_strlcpy(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int size,
  ) {
    return _av_strlcpy(
      dst,
      src,
      size,
    );
  }

  late final _av_strlcpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('av_strlcpy');
  late final _av_strlcpy = _av_strlcpyPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Append the string src to the string dst, but to a total length of
  /// no more than size - 1 bytes, and null-terminate dst.
  ///
  /// This function is similar to BSD strlcat(), but differs when
  /// size <= strlen(dst).
  ///
  /// @param dst destination buffer
  /// @param src source string
  /// @param size size of destination buffer
  /// @return the total length of src and dst
  ///
  /// @warning since the return value use the length of src and dst, these
  /// absolutely _must_ be a properly 0-terminated strings, otherwise this
  /// will read beyond the end of the buffer and possibly crash.
  int av_strlcat(
    ffi.Pointer<ffi.Char> dst,
    ffi.Pointer<ffi.Char> src,
    int size,
  ) {
    return _av_strlcat(
      dst,
      src,
      size,
    );
  }

  late final _av_strlcatPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('av_strlcat');
  late final _av_strlcat = _av_strlcatPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Append output to a string, according to a format. Never write out of
  /// the destination buffer, and always put a terminating 0 within
  /// the buffer.
  /// @param dst destination buffer (string to which the output is
  /// appended)
  /// @param size total size of the destination buffer
  /// @param fmt printf-compatible format string, specifying how the
  /// following parameters are used
  /// @return the length of the string that would have been generated
  /// if enough space had been available
  int av_strlcatf(
    ffi.Pointer<ffi.Char> dst,
    int size,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _av_strlcatf(
      dst,
      size,
      fmt,
    );
  }

  late final _av_strlcatfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>)>>('av_strlcatf');
  late final _av_strlcatf = _av_strlcatfPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Print arguments following specified format into a large enough auto
  /// allocated buffer. It is similar to GNU asprintf().
  /// @param fmt printf-compatible format string, specifying how the
  /// following parameters are used.
  /// @return the allocated string
  /// @note You have to free the string yourself with av_free().
  ffi.Pointer<ffi.Char> av_asprintf(
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _av_asprintf(
      fmt,
    );
  }

  late final _av_asprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('av_asprintf');
  late final _av_asprintf = _av_asprintfPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Unescape the given string until a non escaped terminating char,
  /// and return the token corresponding to the unescaped string.
  ///
  /// The normal \ and ' escaping is supported. Leading and trailing
  /// whitespaces are removed, unless they are escaped with '\' or are
  /// enclosed between ''.
  ///
  /// @param buf the buffer to parse, buf will be updated to point to the
  /// terminating char
  /// @param term a 0-terminated list of terminating chars
  /// @return the malloced unescaped string, which must be av_freed by
  /// the user, NULL in case of allocation failure
  ffi.Pointer<ffi.Char> av_get_token(
    ffi.Pointer<ffi.Pointer<ffi.Char>> buf,
    ffi.Pointer<ffi.Char> term,
  ) {
    return _av_get_token(
      buf,
      term,
    );
  }

  late final _av_get_tokenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('av_get_token');
  late final _av_get_token = _av_get_tokenPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  /// Split the string into several tokens which can be accessed by
  /// successive calls to av_strtok().
  ///
  /// A token is defined as a sequence of characters not belonging to the
  /// set specified in delim.
  ///
  /// On the first call to av_strtok(), s should point to the string to
  /// parse, and the value of saveptr is ignored. In subsequent calls, s
  /// should be NULL, and saveptr should be unchanged since the previous
  /// call.
  ///
  /// This function is similar to strtok_r() defined in POSIX.1.
  ///
  /// @param s the string to parse, may be NULL
  /// @param delim 0-terminated list of token delimiters, must be non-NULL
  /// @param saveptr user-provided pointer which points to stored
  /// information necessary for av_strtok() to continue scanning the same
  /// string. saveptr is updated to point to the next character after the
  /// first delimiter found, or to NULL if the string was terminated
  /// @return the found token, or NULL when no token is found
  ffi.Pointer<ffi.Char> av_strtok(
    ffi.Pointer<ffi.Char> s,
    ffi.Pointer<ffi.Char> delim,
    ffi.Pointer<ffi.Pointer<ffi.Char>> saveptr,
  ) {
    return _av_strtok(
      s,
      delim,
      saveptr,
    );
  }

  late final _av_strtokPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('av_strtok');
  late final _av_strtok = _av_strtokPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Locale-independent case-insensitive compare.
  /// @note This means only ASCII-range characters are case-insensitive
  int av_strcasecmp(
    ffi.Pointer<ffi.Char> a,
    ffi.Pointer<ffi.Char> b,
  ) {
    return _av_strcasecmp(
      a,
      b,
    );
  }

  late final _av_strcasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('av_strcasecmp');
  late final _av_strcasecmp = _av_strcasecmpPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Locale-independent case-insensitive compare.
  /// @note This means only ASCII-range characters are case-insensitive
  int av_strncasecmp(
    ffi.Pointer<ffi.Char> a,
    ffi.Pointer<ffi.Char> b,
    int n,
  ) {
    return _av_strncasecmp(
      a,
      b,
      n,
    );
  }

  late final _av_strncasecmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('av_strncasecmp');
  late final _av_strncasecmp = _av_strncasecmpPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// Locale-independent strings replace.
  /// @note This means only ASCII-range characters are replaced.
  ffi.Pointer<ffi.Char> av_strireplace(
    ffi.Pointer<ffi.Char> str,
    ffi.Pointer<ffi.Char> from,
    ffi.Pointer<ffi.Char> to,
  ) {
    return _av_strireplace(
      str,
      from,
      to,
    );
  }

  late final _av_strireplacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('av_strireplace');
  late final _av_strireplace = _av_strireplacePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Thread safe basename.
  /// @param path the string to parse, on DOS both \ and / are considered separators.
  /// @return pointer to the basename substring.
  /// If path does not contain a slash, the function returns a copy of path.
  /// If path is a NULL pointer or points to an empty string, a pointer
  /// to a string "." is returned.
  ffi.Pointer<ffi.Char> av_basename(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _av_basename(
      path,
    );
  }

  late final _av_basenamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>)>>('av_basename');
  late final _av_basename = _av_basenamePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Thread safe dirname.
  /// @param path the string to parse, on DOS both \ and / are considered separators.
  /// @return A pointer to a string that's the parent directory of path.
  /// If path is a NULL pointer or points to an empty string, a pointer
  /// to a string "." is returned.
  /// @note the function may modify the contents of the path, so copies should be passed.
  ffi.Pointer<ffi.Char> av_dirname(
    ffi.Pointer<ffi.Char> path,
  ) {
    return _av_dirname(
      path,
    );
  }

  late final _av_dirnamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('av_dirname');
  late final _av_dirname = _av_dirnamePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  /// Match instances of a name in a comma-separated list of names.
  /// List entries are checked from the start to the end of the names list,
  /// the first match ends further processing. If an entry prefixed with '-'
  /// matches, then 0 is returned. The "ALL" list entry is considered to
  /// match all names.
  ///
  /// @param name  Name to look for.
  /// @param names List of names.
  /// @return 1 on match, 0 otherwise.
  int av_match_name(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> names,
  ) {
    return _av_match_name(
      name,
      names,
    );
  }

  late final _av_match_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('av_match_name');
  late final _av_match_name = _av_match_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Append path component to the existing path.
  /// Path separator '/' is placed between when needed.
  /// Resulting string have to be freed with av_free().
  /// @param path      base path
  /// @param component component to be appended
  /// @return new path or NULL on error.
  ffi.Pointer<ffi.Char> av_append_path_component(
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> component,
  ) {
    return _av_append_path_component(
      path,
      component,
    );
  }

  late final _av_append_path_componentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('av_append_path_component');
  late final _av_append_path_component =
      _av_append_path_componentPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Escape string in src, and put the escaped string in an allocated
  /// string in *dst, which must be freed with av_free().
  ///
  /// @param dst           pointer where an allocated string is put
  /// @param src           string to escape, must be non-NULL
  /// @param special_chars string containing the special characters which
  /// need to be escaped, can be NULL
  /// @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
  /// Any unknown value for mode will be considered equivalent to
  /// AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
  /// notice.
  /// @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros
  /// @return the length of the allocated string, or a negative error code in case of error
  /// @see av_bprint_escape()
  int av_escape(
    ffi.Pointer<ffi.Pointer<ffi.Char>> dst,
    ffi.Pointer<ffi.Char> src,
    ffi.Pointer<ffi.Char> special_chars,
    AVEscapeMode mode,
    int flags,
  ) {
    return _av_escape(
      dst,
      src,
      special_chars,
      mode.value,
      flags,
    );
  }

  late final _av_escapePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Int)>>('av_escape');
  late final _av_escape = _av_escapePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int, int)>();

  /// Read and decode a single UTF-8 code point (character) from the
  /// buffer in *buf, and update *buf to point to the next byte to
  /// decode.
  ///
  /// In case of an invalid byte sequence, the pointer will be updated to
  /// the next byte after the invalid sequence and the function will
  /// return an error code.
  ///
  /// Depending on the specified flags, the function will also fail in
  /// case the decoded code point does not belong to a valid range.
  ///
  /// @note For speed-relevant code a carefully implemented use of
  /// GET_UTF8() may be preferred.
  ///
  /// @param codep   pointer used to return the parsed code in case of success.
  /// The value in *codep is set even in case the range check fails.
  /// @param bufp    pointer to the address the first byte of the sequence
  /// to decode, updated by the function to point to the
  /// byte next after the decoded sequence
  /// @param buf_end pointer to the end of the buffer, points to the next
  /// byte past the last in the buffer. This is used to
  /// avoid buffer overreads (in case of an unfinished
  /// UTF-8 sequence towards the end of the buffer).
  /// @param flags   a collection of AV_UTF8_FLAG_* flags
  /// @return >= 0 in case a sequence was successfully read, a negative
  /// value in case of invalid sequence
  int av_utf8_decode(
    ffi.Pointer<ffi.Int32> codep,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufp,
    ffi.Pointer<ffi.Uint8> buf_end,
    int flags,
  ) {
    return _av_utf8_decode(
      codep,
      bufp,
      buf_end,
      flags,
    );
  }

  late final _av_utf8_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Uint8>,
              ffi.UnsignedInt)>>('av_utf8_decode');
  late final _av_utf8_decode = _av_utf8_decodePtr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Check if a name is in a list.
  /// @returns 0 if not found, or the 1 based index where it has been found in the
  /// list.
  int av_match_list(
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> list,
    int separator,
  ) {
    return _av_match_list(
      name,
      list,
      separator,
    );
  }

  late final _av_match_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Char)>>('av_match_list');
  late final _av_match_list = _av_match_listPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  /// See libc sscanf manual for more information.
  /// Locale-independent sscanf implementation.
  int av_sscanf(
    ffi.Pointer<ffi.Char> string,
    ffi.Pointer<ffi.Char> format,
  ) {
    return _av_sscanf(
      string,
      format,
    );
  }

  late final _av_sscanfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('av_sscanf');
  late final _av_sscanf = _av_sscanfPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Init a print buffer.
  ///
  /// @param buf        buffer to init
  /// @param size_init  initial size (including the final 0)
  /// @param size_max   maximum size;
  /// - `0` means do not write anything, just count the length
  /// - `1` is replaced by the maximum value for automatic storage
  /// any large value means that the internal buffer will be
  /// reallocated as needed up to that limit
  /// - `-1` is converted to `UINT_MAX`, the largest limit possible.
  /// Check also `AV_BPRINT_SIZE_*` macros.
  void av_bprint_init(
    ffi.Pointer<AVBPrint> buf,
    int size_init,
    int size_max,
  ) {
    return _av_bprint_init(
      buf,
      size_init,
      size_max,
    );
  }

  late final _av_bprint_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('av_bprint_init');
  late final _av_bprint_init = _av_bprint_initPtr
      .asFunction<void Function(ffi.Pointer<AVBPrint>, int, int)>();

  /// Init a print buffer using a pre-existing buffer.
  ///
  /// The buffer will not be reallocated.
  /// In case size equals zero, the AVBPrint will be initialized to use
  /// the internal buffer as if using AV_BPRINT_SIZE_COUNT_ONLY with
  /// av_bprint_init().
  ///
  /// @param buf     buffer structure to init
  /// @param buffer  byte buffer to use for the string data
  /// @param size    size of buffer
  void av_bprint_init_for_buffer(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Char> buffer,
    int size,
  ) {
    return _av_bprint_init_for_buffer(
      buf,
      buffer,
      size,
    );
  }

  late final _av_bprint_init_for_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('av_bprint_init_for_buffer');
  late final _av_bprint_init_for_buffer =
      _av_bprint_init_for_bufferPtr.asFunction<
          void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>, int)>();

  /// Append a formatted string to a print buffer.
  void av_bprintf(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _av_bprintf(
      buf,
      fmt,
    );
  }

  late final _av_bprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>)>>('av_bprintf');
  late final _av_bprintf = _av_bprintfPtr.asFunction<
      void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>)>();

  /// Append a formatted string to a print buffer.
  void av_vbprintf(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Char> fmt,
    va_list1 vl_arg,
  ) {
    return _av_vbprintf(
      buf,
      fmt,
      vl_arg,
    );
  }

  late final _av_vbprintfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>,
              va_list1)>>('av_vbprintf');
  late final _av_vbprintf = _av_vbprintfPtr.asFunction<
      void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>, va_list1)>();

  /// Append char c n times to a print buffer.
  void av_bprint_chars(
    ffi.Pointer<AVBPrint> buf,
    int c,
    int n,
  ) {
    return _av_bprint_chars(
      buf,
      c,
      n,
    );
  }

  late final _av_bprint_charsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Char,
              ffi.UnsignedInt)>>('av_bprint_chars');
  late final _av_bprint_chars = _av_bprint_charsPtr
      .asFunction<void Function(ffi.Pointer<AVBPrint>, int, int)>();

  /// Append data to a print buffer.
  ///
  /// @param buf  bprint buffer to use
  /// @param data pointer to data
  /// @param size size of data
  void av_bprint_append_data(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Char> data,
    int size,
  ) {
    return _av_bprint_append_data(
      buf,
      data,
      size,
    );
  }

  late final _av_bprint_append_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('av_bprint_append_data');
  late final _av_bprint_append_data = _av_bprint_append_dataPtr.asFunction<
      void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>, int)>();

  /// Append a formatted date and time to a print buffer.
  ///
  /// @param buf  bprint buffer to use
  /// @param fmt  date and time format string, see strftime()
  /// @param tm   broken-down time structure to translate
  ///
  /// @note due to poor design of the standard strftime function, it may
  /// produce poor results if the format string expands to a very long text and
  /// the bprint buffer is near the limit stated by the size_max option.
  void av_bprint_strftime(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Char> fmt,
    ffi.Pointer<tm> tm,
  ) {
    return _av_bprint_strftime(
      buf,
      fmt,
      tm,
    );
  }

  late final _av_bprint_strftimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<tm>)>>('av_bprint_strftime');
  late final _av_bprint_strftime = _av_bprint_strftimePtr.asFunction<
      void Function(
          ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>();

  /// Allocate bytes in the buffer for external use.
  ///
  /// @param[in]  buf          buffer structure
  /// @param[in]  size         required size
  /// @param[out] mem          pointer to the memory area
  /// @param[out] actual_size  size of the memory area after allocation;
  /// can be larger or smaller than size
  void av_bprint_get_buffer(
    ffi.Pointer<AVBPrint> buf,
    int size,
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> mem,
    ffi.Pointer<ffi.UnsignedInt> actual_size,
  ) {
    return _av_bprint_get_buffer(
      buf,
      size,
      mem,
      actual_size,
    );
  }

  late final _av_bprint_get_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVBPrint>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
              ffi.Pointer<ffi.UnsignedInt>)>>('av_bprint_get_buffer');
  late final _av_bprint_get_buffer = _av_bprint_get_bufferPtr.asFunction<
      void Function(
          ffi.Pointer<AVBPrint>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
          ffi.Pointer<ffi.UnsignedInt>)>();

  /// Reset the string to "" but keep internal allocated data.
  void av_bprint_clear(
    ffi.Pointer<AVBPrint> buf,
  ) {
    return _av_bprint_clear(
      buf,
    );
  }

  late final _av_bprint_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVBPrint>)>>(
          'av_bprint_clear');
  late final _av_bprint_clear =
      _av_bprint_clearPtr.asFunction<void Function(ffi.Pointer<AVBPrint>)>();

  /// Finalize a print buffer.
  ///
  /// The print buffer can no longer be used afterwards,
  /// but the len and size fields are still valid.
  ///
  /// @arg[out] ret_str  if not NULL, used to return a permanent copy of the
  /// buffer contents, or NULL if memory allocation fails;
  /// if NULL, the buffer is discarded and freed
  /// @return  0 for success or error code (probably AVERROR(ENOMEM))
  int av_bprint_finalize(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Pointer<ffi.Char>> ret_str,
  ) {
    return _av_bprint_finalize(
      buf,
      ret_str,
    );
  }

  late final _av_bprint_finalizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVBPrint>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('av_bprint_finalize');
  late final _av_bprint_finalize = _av_bprint_finalizePtr.asFunction<
      int Function(
          ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Escape the content in src and append it to dstbuf.
  ///
  /// @param dstbuf        already inited destination bprint buffer
  /// @param src           string containing the text to escape
  /// @param special_chars string containing the special characters which
  /// need to be escaped, can be NULL
  /// @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
  /// Any unknown value for mode will be considered equivalent to
  /// AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
  /// notice.
  /// @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros
  void av_bprint_escape(
    ffi.Pointer<AVBPrint> dstbuf,
    ffi.Pointer<ffi.Char> src,
    ffi.Pointer<ffi.Char> special_chars,
    AVEscapeMode mode,
    int flags,
  ) {
    return _av_bprint_escape(
      dstbuf,
      src,
      special_chars,
      mode.value,
      flags,
    );
  }

  late final _av_bprint_escapePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVBPrint>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Int)>>('av_bprint_escape');
  late final _av_bprint_escape = _av_bprint_escapePtr.asFunction<
      void Function(ffi.Pointer<AVBPrint>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, int, int)>();

  /// Allocate an AVDynamicHDRPlus structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVDynamicHDRPlus filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVDynamicHDRPlus> av_dynamic_hdr_plus_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_dynamic_hdr_plus_alloc(
      size,
    );
  }

  late final _av_dynamic_hdr_plus_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDynamicHDRPlus> Function(
              ffi.Pointer<ffi.Size>)>>('av_dynamic_hdr_plus_alloc');
  late final _av_dynamic_hdr_plus_alloc =
      _av_dynamic_hdr_plus_allocPtr.asFunction<
          ffi.Pointer<AVDynamicHDRPlus> Function(ffi.Pointer<ffi.Size>)>();

  /// Allocate a complete AVDynamicHDRPlus and add it to the frame.
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVDynamicHDRPlus structure to be filled by caller or NULL
  /// on failure.
  ffi.Pointer<AVDynamicHDRPlus> av_dynamic_hdr_plus_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_dynamic_hdr_plus_create_side_data(
      frame,
    );
  }

  late final _av_dynamic_hdr_plus_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDynamicHDRPlus> Function(
              ffi.Pointer<AVFrame>)>>('av_dynamic_hdr_plus_create_side_data');
  late final _av_dynamic_hdr_plus_create_side_data =
      _av_dynamic_hdr_plus_create_side_dataPtr.asFunction<
          ffi.Pointer<AVDynamicHDRPlus> Function(ffi.Pointer<AVFrame>)>();

  /// Parse the user data registered ITU-T T.35 to AVbuffer (AVDynamicHDRPlus).
  /// The T.35 buffer must begin with the application mode, skipping the
  /// country code, terminal provider codes, and application identifier.
  /// @param s A pointer containing the decoded AVDynamicHDRPlus structure.
  /// @param data The byte array containing the raw ITU-T T.35 data.
  /// @param size Size of the data array in bytes.
  ///
  /// @return >= 0 on success. Otherwise, returns the appropriate AVERROR.
  int av_dynamic_hdr_plus_from_t35(
    ffi.Pointer<AVDynamicHDRPlus> s,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    return _av_dynamic_hdr_plus_from_t35(
      s,
      data,
      size,
    );
  }

  late final _av_dynamic_hdr_plus_from_t35Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVDynamicHDRPlus>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_dynamic_hdr_plus_from_t35');
  late final _av_dynamic_hdr_plus_from_t35 =
      _av_dynamic_hdr_plus_from_t35Ptr.asFunction<
          int Function(
              ffi.Pointer<AVDynamicHDRPlus>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Serialize dynamic HDR10+ metadata to a user data registered ITU-T T.35 buffer,
  /// excluding the first 48 bytes of the header, and beginning with the application mode.
  /// @param s A pointer containing the decoded AVDynamicHDRPlus structure.
  /// @param[in,out] data A pointer to pointer to a byte buffer to be filled with the
  /// serialized metadata.
  /// If *data is NULL, a buffer be will be allocated and a pointer to
  /// it stored in its place. The caller assumes ownership of the buffer.
  /// May be NULL, in which case the function will only store the
  /// required buffer size in *size.
  /// @param[in,out] size A pointer to a size to be set to the returned buffer's size.
  /// If *data is not NULL, *size must contain the size of the input
  /// buffer. May be NULL only if *data is NULL.
  ///
  /// @return >= 0 on success. Otherwise, returns the appropriate AVERROR.
  int av_dynamic_hdr_plus_to_t35(
    ffi.Pointer<AVDynamicHDRPlus> s,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_dynamic_hdr_plus_to_t35(
      s,
      data,
      size,
    );
  }

  late final _av_dynamic_hdr_plus_to_t35Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVDynamicHDRPlus>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Size>)>>('av_dynamic_hdr_plus_to_t35');
  late final _av_dynamic_hdr_plus_to_t35 =
      _av_dynamic_hdr_plus_to_t35Ptr.asFunction<
          int Function(ffi.Pointer<AVDynamicHDRPlus>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>, ffi.Pointer<ffi.Size>)>();

  /// Allocate an AVAESCTR context.
  ffi.Pointer<AVAESCTR> av_aes_ctr_alloc() {
    return _av_aes_ctr_alloc();
  }

  late final _av_aes_ctr_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVAESCTR> Function()>>(
          'av_aes_ctr_alloc');
  late final _av_aes_ctr_alloc =
      _av_aes_ctr_allocPtr.asFunction<ffi.Pointer<AVAESCTR> Function()>();

  /// Initialize an AVAESCTR context.
  ///
  /// @param a The AVAESCTR context to initialize
  /// @param key encryption key, must have a length of AES_CTR_KEY_SIZE
  int av_aes_ctr_init(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> key,
  ) {
    return _av_aes_ctr_init(
      a,
      key,
    );
  }

  late final _av_aes_ctr_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVAESCTR>,
              ffi.Pointer<ffi.Uint8>)>>('av_aes_ctr_init');
  late final _av_aes_ctr_init = _av_aes_ctr_initPtr.asFunction<
      int Function(ffi.Pointer<AVAESCTR>, ffi.Pointer<ffi.Uint8>)>();

  /// Release an AVAESCTR context.
  ///
  /// @param a The AVAESCTR context
  void av_aes_ctr_free(
    ffi.Pointer<AVAESCTR> a,
  ) {
    return _av_aes_ctr_free(
      a,
    );
  }

  late final _av_aes_ctr_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVAESCTR>)>>(
          'av_aes_ctr_free');
  late final _av_aes_ctr_free =
      _av_aes_ctr_freePtr.asFunction<void Function(ffi.Pointer<AVAESCTR>)>();

  /// Process a buffer using a previously initialized context.
  ///
  /// @param a The AVAESCTR context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param size the size of src and dst
  void av_aes_ctr_crypt(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int size,
  ) {
    return _av_aes_ctr_crypt(
      a,
      dst,
      src,
      size,
    );
  }

  late final _av_aes_ctr_cryptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVAESCTR>, ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>, ffi.Int)>>('av_aes_ctr_crypt');
  late final _av_aes_ctr_crypt = _av_aes_ctr_cryptPtr.asFunction<
      void Function(ffi.Pointer<AVAESCTR>, ffi.Pointer<ffi.Uint8>,
          ffi.Pointer<ffi.Uint8>, int)>();

  /// Get the current iv
  ffi.Pointer<ffi.Uint8> av_aes_ctr_get_iv(
    ffi.Pointer<AVAESCTR> a,
  ) {
    return _av_aes_ctr_get_iv(
      a,
    );
  }

  late final _av_aes_ctr_get_ivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(
              ffi.Pointer<AVAESCTR>)>>('av_aes_ctr_get_iv');
  late final _av_aes_ctr_get_iv = _av_aes_ctr_get_ivPtr
      .asFunction<ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<AVAESCTR>)>();

  /// Generate a random iv
  void av_aes_ctr_set_random_iv(
    ffi.Pointer<AVAESCTR> a,
  ) {
    return _av_aes_ctr_set_random_iv(
      a,
    );
  }

  late final _av_aes_ctr_set_random_ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVAESCTR>)>>(
          'av_aes_ctr_set_random_iv');
  late final _av_aes_ctr_set_random_iv = _av_aes_ctr_set_random_ivPtr
      .asFunction<void Function(ffi.Pointer<AVAESCTR>)>();

  /// Forcefully change the 8-byte iv
  void av_aes_ctr_set_iv(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> iv,
  ) {
    return _av_aes_ctr_set_iv(
      a,
      iv,
    );
  }

  late final _av_aes_ctr_set_ivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVAESCTR>,
              ffi.Pointer<ffi.Uint8>)>>('av_aes_ctr_set_iv');
  late final _av_aes_ctr_set_iv = _av_aes_ctr_set_ivPtr.asFunction<
      void Function(ffi.Pointer<AVAESCTR>, ffi.Pointer<ffi.Uint8>)>();

  /// Forcefully change the "full" 16-byte iv, including the counter
  void av_aes_ctr_set_full_iv(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> iv,
  ) {
    return _av_aes_ctr_set_full_iv(
      a,
      iv,
    );
  }

  late final _av_aes_ctr_set_full_ivPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVAESCTR>,
              ffi.Pointer<ffi.Uint8>)>>('av_aes_ctr_set_full_iv');
  late final _av_aes_ctr_set_full_iv = _av_aes_ctr_set_full_ivPtr.asFunction<
      void Function(ffi.Pointer<AVAESCTR>, ffi.Pointer<ffi.Uint8>)>();

  /// Increment the top 64 bit of the iv (performed after each frame)
  void av_aes_ctr_increment_iv(
    ffi.Pointer<AVAESCTR> a,
  ) {
    return _av_aes_ctr_increment_iv(
      a,
    );
  }

  late final _av_aes_ctr_increment_ivPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVAESCTR>)>>(
          'av_aes_ctr_increment_iv');
  late final _av_aes_ctr_increment_iv = _av_aes_ctr_increment_ivPtr
      .asFunction<void Function(ffi.Pointer<AVAESCTR>)>();

  /// Fill the provided buffer with a string containing a timestamp time
  /// representation.
  ///
  /// @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE
  /// @param ts the timestamp to represent
  /// @param tb the timebase of the timestamp
  /// @return the buffer in input
  ffi.Pointer<ffi.Char> av_ts_make_time_string2(
    ffi.Pointer<ffi.Char> buf,
    int ts,
    AVRational tb,
  ) {
    return _av_ts_make_time_string2(
      buf,
      ts,
      tb,
    );
  }

  late final _av_ts_make_time_string2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Int64,
              AVRational)>>('av_ts_make_time_string2');
  late final _av_ts_make_time_string2 = _av_ts_make_time_string2Ptr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, int, AVRational)>();

  /// Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.
  ///
  /// If the side data is absent, it is created and added to the frame.
  ///
  /// @param frame the frame for which the side data is to be obtained or created
  ///
  /// @return the AVDownmixInfo structure to be edited by the caller, or NULL if
  /// the structure cannot be allocated.
  ffi.Pointer<AVDownmixInfo> av_downmix_info_update_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_downmix_info_update_side_data(
      frame,
    );
  }

  late final _av_downmix_info_update_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVDownmixInfo> Function(
              ffi.Pointer<AVFrame>)>>('av_downmix_info_update_side_data');
  late final _av_downmix_info_update_side_data =
      _av_downmix_info_update_side_dataPtr.asFunction<
          ffi.Pointer<AVDownmixInfo> Function(ffi.Pointer<AVFrame>)>();

  /// Allocate a hash context for the algorithm specified by name.
  ///
  /// @return  >= 0 for success, a negative error code for failure
  ///
  /// @note The context is not initialized after a call to this function; you must
  /// call av_hash_init() to do so.
  int av_hash_alloc(
    ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _av_hash_alloc(
      ctx,
      name,
    );
  }

  late final _av_hash_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<AVHashContext>>,
              ffi.Pointer<ffi.Char>)>>('av_hash_alloc');
  late final _av_hash_alloc = _av_hash_allocPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<AVHashContext>>, ffi.Pointer<ffi.Char>)>();

  /// Get the names of available hash algorithms.
  ///
  /// This function can be used to enumerate the algorithms.
  ///
  /// @param[in] i  Index of the hash algorithm, starting from 0
  /// @return       Pointer to a static string or `NULL` if `i` is out of range
  ffi.Pointer<ffi.Char> av_hash_names(
    int i,
  ) {
    return _av_hash_names(
      i,
    );
  }

  late final _av_hash_namesPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'av_hash_names');
  late final _av_hash_names =
      _av_hash_namesPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Get the name of the algorithm corresponding to the given hash context.
  ffi.Pointer<ffi.Char> av_hash_get_name(
    ffi.Pointer<AVHashContext> ctx,
  ) {
    return _av_hash_get_name(
      ctx,
    );
  }

  late final _av_hash_get_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<AVHashContext>)>>('av_hash_get_name');
  late final _av_hash_get_name = _av_hash_get_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<AVHashContext>)>();

  /// Get the size of the resulting hash value in bytes.
  ///
  /// The maximum value this function will currently return is available as macro
  /// #AV_HASH_MAX_SIZE.
  ///
  /// @param[in]     ctx Hash context
  /// @return            Size of the hash value in bytes
  int av_hash_get_size(
    ffi.Pointer<AVHashContext> ctx,
  ) {
    return _av_hash_get_size(
      ctx,
    );
  }

  late final _av_hash_get_sizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVHashContext>)>>(
          'av_hash_get_size');
  late final _av_hash_get_size = _av_hash_get_sizePtr
      .asFunction<int Function(ffi.Pointer<AVHashContext>)>();

  /// Initialize or reset a hash context.
  ///
  /// @param[in,out] ctx Hash context
  void av_hash_init(
    ffi.Pointer<AVHashContext> ctx,
  ) {
    return _av_hash_init(
      ctx,
    );
  }

  late final _av_hash_initPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<AVHashContext>)>>(
      'av_hash_init');
  late final _av_hash_init =
      _av_hash_initPtr.asFunction<void Function(ffi.Pointer<AVHashContext>)>();

  /// Update a hash context with additional data.
  ///
  /// @param[in,out] ctx Hash context
  /// @param[in]     src Data to be added to the hash context
  /// @param[in]     len Size of the additional data
  void av_hash_update(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    return _av_hash_update(
      ctx,
      src,
      len,
    );
  }

  late final _av_hash_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('av_hash_update');
  late final _av_hash_update = _av_hash_updatePtr.asFunction<
      void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finalize a hash context and compute the actual hash value.
  ///
  /// The minimum size of `dst` buffer is given by av_hash_get_size() or
  /// #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// @param[in,out] ctx Hash context
  /// @param[out]    dst Where the final hash value will be stored
  ///
  /// @see av_hash_final_bin() provides an alternative API
  void av_hash_final(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
  ) {
    return _av_hash_final(
      ctx,
      dst,
    );
  }

  late final _av_hash_finalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHashContext>,
              ffi.Pointer<ffi.Uint8>)>>('av_hash_final');
  late final _av_hash_final = _av_hash_finalPtr.asFunction<
      void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>)>();

  /// Finalize a hash context and store the actual hash value in a buffer.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// If `size` is smaller than the hash size (given by av_hash_get_size()), the
  /// hash is truncated; if size is larger, the buffer is padded with 0.
  ///
  /// @param[in,out] ctx  Hash context
  /// @param[out]    dst  Where the final hash value will be stored
  /// @param[in]     size Number of bytes to write to `dst`
  void av_hash_final_bin(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    int size,
  ) {
    return _av_hash_final_bin(
      ctx,
      dst,
      size,
    );
  }

  late final _av_hash_final_binPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_hash_final_bin');
  late final _av_hash_final_bin = _av_hash_final_binPtr.asFunction<
      void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finalize a hash context and store the hexadecimal representation of the
  /// actual hash value as a string.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// The string is always 0-terminated.
  ///
  /// If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the
  /// value returned by av_hash_get_size(), the string will be truncated.
  ///
  /// @param[in,out] ctx  Hash context
  /// @param[out]    dst  Where the string will be stored
  /// @param[in]     size Maximum number of bytes to write to `dst`
  void av_hash_final_hex(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    int size,
  ) {
    return _av_hash_final_hex(
      ctx,
      dst,
      size,
    );
  }

  late final _av_hash_final_hexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_hash_final_hex');
  late final _av_hash_final_hex = _av_hash_final_hexPtr.asFunction<
      void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Finalize a hash context and store the Base64 representation of the
  /// actual hash value as a string.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// The string is always 0-terminated.
  ///
  /// If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is
  /// the value returned by av_hash_get_size(), the string will be truncated.
  ///
  /// @param[in,out] ctx  Hash context
  /// @param[out]    dst  Where the final hash value will be stored
  /// @param[in]     size Maximum number of bytes to write to `dst`
  void av_hash_final_b64(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    int size,
  ) {
    return _av_hash_final_b64(
      ctx,
      dst,
      size,
    );
  }

  late final _av_hash_final_b64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>,
              ffi.Int)>>('av_hash_final_b64');
  late final _av_hash_final_b64 = _av_hash_final_b64Ptr.asFunction<
      void Function(ffi.Pointer<AVHashContext>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Free hash context and set hash context pointer to `NULL`.
  ///
  /// @param[in,out] ctx  Pointer to hash context
  void av_hash_freep(
    ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
  ) {
    return _av_hash_freep(
      ctx,
    );
  }

  late final _av_hash_freepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<AVHashContext>>)>>('av_hash_freep');
  late final _av_hash_freep = _av_hash_freepPtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<AVHashContext>>)>();

  /// Allocate an AVFilmGrainParams structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  /// If size is not NULL it will be set to the number of bytes allocated.
  ///
  /// @return An AVFilmGrainParams filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVFilmGrainParams> av_film_grain_params_alloc(
    ffi.Pointer<ffi.Size> size,
  ) {
    return _av_film_grain_params_alloc(
      size,
    );
  }

  late final _av_film_grain_params_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilmGrainParams> Function(
              ffi.Pointer<ffi.Size>)>>('av_film_grain_params_alloc');
  late final _av_film_grain_params_alloc =
      _av_film_grain_params_allocPtr.asFunction<
          ffi.Pointer<AVFilmGrainParams> Function(ffi.Pointer<ffi.Size>)>();

  /// Allocate a complete AVFilmGrainParams and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVFilmGrainParams structure to be filled by caller.
  ffi.Pointer<AVFilmGrainParams> av_film_grain_params_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_film_grain_params_create_side_data(
      frame,
    );
  }

  late final _av_film_grain_params_create_side_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilmGrainParams> Function(
              ffi.Pointer<AVFrame>)>>('av_film_grain_params_create_side_data');
  late final _av_film_grain_params_create_side_data =
      _av_film_grain_params_create_side_dataPtr.asFunction<
          ffi.Pointer<AVFilmGrainParams> Function(ffi.Pointer<AVFrame>)>();

  /// Select the most appropriate film grain parameters set for the frame,
  /// taking into account the frame's format, resolution and video signal
  /// characteristics.
  ///
  /// @note, for H.274, this may select a film grain parameter set with
  /// greater chroma resolution than the frame. Users should take care to
  /// correctly adjust the chroma grain frequency to the frame.
  ffi.Pointer<AVFilmGrainParams> av_film_grain_params_select(
    ffi.Pointer<AVFrame> frame,
  ) {
    return _av_film_grain_params_select(
      frame,
    );
  }

  late final _av_film_grain_params_selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<AVFilmGrainParams> Function(
              ffi.Pointer<AVFrame>)>>('av_film_grain_params_select');
  late final _av_film_grain_params_select =
      _av_film_grain_params_selectPtr.asFunction<
          ffi.Pointer<AVFilmGrainParams> Function(ffi.Pointer<AVFrame>)>();

  /// Return the LIBPOSTPROC_VERSION_INT constant.
  int postproc_version() {
    return _postproc_version();
  }

  late final _postproc_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'postproc_version');
  late final _postproc_version =
      _postproc_versionPtr.asFunction<int Function()>();

  /// Return the libpostproc build-time configuration.
  ffi.Pointer<ffi.Char> postproc_configuration() {
    return _postproc_configuration();
  }

  late final _postproc_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'postproc_configuration');
  late final _postproc_configuration =
      _postproc_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libpostproc license.
  ffi.Pointer<ffi.Char> postproc_license() {
    return _postproc_license();
  }

  late final _postproc_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'postproc_license');
  late final _postproc_license =
      _postproc_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// < a simple help text
  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _pp_help =
      _lookup<ffi.Pointer<ffi.Char>>('pp_help');

  ffi.Pointer<ffi.Char> get pp_help => _pp_help.value;

  set pp_help(ffi.Pointer<ffi.Char> value) => _pp_help.value = value;

  void pp_postprocess(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src,
    ffi.Pointer<ffi.Int> srcStride,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst,
    ffi.Pointer<ffi.Int> dstStride,
    int horizontalSize,
    int verticalSize,
    ffi.Pointer<ffi.Int8> QP_store,
    int QP_stride,
    ffi.Pointer<pp_mode> mode,
    ffi.Pointer<pp_context> ppContext,
    int pict_type,
  ) {
    return _pp_postprocess(
      src,
      srcStride,
      dst,
      dstStride,
      horizontalSize,
      verticalSize,
      QP_store,
      QP_stride,
      mode,
      ppContext,
      pict_type,
    );
  }

  late final _pp_postprocessPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Int8>,
              ffi.Int,
              ffi.Pointer<pp_mode>,
              ffi.Pointer<pp_context>,
              ffi.Int)>>('pp_postprocess');
  late final _pp_postprocess = _pp_postprocessPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          ffi.Pointer<ffi.Int8>,
          int,
          ffi.Pointer<pp_mode>,
          ffi.Pointer<pp_context>,
          int)>();

  /// Return a pp_mode or NULL if an error occurred.
  ///
  /// @param name    the string after "-pp" on the command line
  /// @param quality a number from 0 to PP_QUALITY_MAX
  ffi.Pointer<pp_mode> pp_get_mode_by_name_and_quality(
    ffi.Pointer<ffi.Char> name,
    int quality,
  ) {
    return _pp_get_mode_by_name_and_quality(
      name,
      quality,
    );
  }

  late final _pp_get_mode_by_name_and_qualityPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pp_mode> Function(ffi.Pointer<ffi.Char>,
              ffi.Int)>>('pp_get_mode_by_name_and_quality');
  late final _pp_get_mode_by_name_and_quality =
      _pp_get_mode_by_name_and_qualityPtr.asFunction<
          ffi.Pointer<pp_mode> Function(ffi.Pointer<ffi.Char>, int)>();

  void pp_free_mode(
    ffi.Pointer<pp_mode> mode,
  ) {
    return _pp_free_mode(
      mode,
    );
  }

  late final _pp_free_modePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pp_mode>)>>(
          'pp_free_mode');
  late final _pp_free_mode =
      _pp_free_modePtr.asFunction<void Function(ffi.Pointer<pp_mode>)>();

  ffi.Pointer<pp_context> pp_get_context(
    int width,
    int height,
    int flags,
  ) {
    return _pp_get_context(
      width,
      height,
      flags,
    );
  }

  late final _pp_get_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<pp_context> Function(
              ffi.Int, ffi.Int, ffi.Int)>>('pp_get_context');
  late final _pp_get_context = _pp_get_contextPtr
      .asFunction<ffi.Pointer<pp_context> Function(int, int, int)>();

  void pp_free_context(
    ffi.Pointer<pp_context> ppContext,
  ) {
    return _pp_free_context(
      ppContext,
    );
  }

  late final _pp_free_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<pp_context>)>>(
          'pp_free_context');
  late final _pp_free_context =
      _pp_free_contextPtr.asFunction<void Function(ffi.Pointer<pp_context>)>();

  /// Get the AVClass for SwrContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  /// @return the AVClass of SwrContext
  ffi.Pointer<AVClass> swr_get_class() {
    return _swr_get_class();
  }

  late final _swr_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'swr_get_class');
  late final _swr_get_class =
      _swr_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();

  /// Allocate SwrContext.
  ///
  /// If you use this function you will need to set the parameters (manually or
  /// with swr_alloc_set_opts2()) before calling swr_init().
  ///
  /// @see swr_alloc_set_opts2(), swr_init(), swr_free()
  /// @return NULL on error, allocated context otherwise
  ffi.Pointer<SwrContext> swr_alloc() {
    return _swr_alloc();
  }

  late final _swr_allocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SwrContext> Function()>>(
          'swr_alloc');
  late final _swr_alloc =
      _swr_allocPtr.asFunction<ffi.Pointer<SwrContext> Function()>();

  /// Initialize context after user parameters have been set.
  /// @note The context must be configured using the AVOption API.
  ///
  /// @see av_opt_set_int()
  /// @see av_opt_set_dict()
  ///
  /// @param[in,out]   s Swr context to initialize
  /// @return AVERROR error code in case of failure.
  int swr_init(
    ffi.Pointer<SwrContext> s,
  ) {
    return _swr_init(
      s,
    );
  }

  late final _swr_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SwrContext>)>>(
          'swr_init');
  late final _swr_init =
      _swr_initPtr.asFunction<int Function(ffi.Pointer<SwrContext>)>();

  /// Check whether an swr context has been initialized or not.
  ///
  /// @param[in]       s Swr context to check
  /// @see swr_init()
  /// @return positive if it has been initialized, 0 if not initialized
  int swr_is_initialized(
    ffi.Pointer<SwrContext> s,
  ) {
    return _swr_is_initialized(
      s,
    );
  }

  late final _swr_is_initializedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<SwrContext>)>>(
          'swr_is_initialized');
  late final _swr_is_initialized = _swr_is_initializedPtr
      .asFunction<int Function(ffi.Pointer<SwrContext>)>();

  /// Allocate SwrContext if needed and set/reset common parameters.
  ///
  /// This function does not require *ps to be allocated with swr_alloc(). On the
  /// other hand, swr_alloc() can use swr_alloc_set_opts2() to set the parameters
  /// on the allocated context.
  ///
  /// @param ps              Pointer to an existing Swr context if available, or to NULL if not.
  /// On success, *ps will be set to the allocated context.
  /// @param out_ch_layout   output channel layout (e.g. AV_CHANNEL_LAYOUT_*)
  /// @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).
  /// @param out_sample_rate output sample rate (frequency in Hz)
  /// @param in_ch_layout    input channel layout (e.g. AV_CHANNEL_LAYOUT_*)
  /// @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).
  /// @param in_sample_rate  input sample rate (frequency in Hz)
  /// @param log_offset      logging level offset
  /// @param log_ctx         parent logging context, can be NULL
  ///
  /// @see swr_init(), swr_free()
  /// @return 0 on success, a negative AVERROR code on error.
  /// On error, the Swr context is freed and *ps set to NULL.
  int swr_alloc_set_opts2(
    ffi.Pointer<ffi.Pointer<SwrContext>> ps,
    ffi.Pointer<AVChannelLayout> out_ch_layout,
    AVSampleFormat out_sample_fmt,
    int out_sample_rate,
    ffi.Pointer<AVChannelLayout> in_ch_layout,
    AVSampleFormat in_sample_fmt,
    int in_sample_rate,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    return _swr_alloc_set_opts2(
      ps,
      out_ch_layout,
      out_sample_fmt.value,
      out_sample_rate,
      in_ch_layout,
      in_sample_fmt.value,
      in_sample_rate,
      log_offset,
      log_ctx,
    );
  }

  late final _swr_alloc_set_opts2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<SwrContext>>,
              ffi.Pointer<AVChannelLayout>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<AVChannelLayout>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('swr_alloc_set_opts2');
  late final _swr_alloc_set_opts2 = _swr_alloc_set_opts2Ptr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<SwrContext>>,
          ffi.Pointer<AVChannelLayout>,
          int,
          int,
          ffi.Pointer<AVChannelLayout>,
          int,
          int,
          int,
          ffi.Pointer<ffi.Void>)>();

  /// Free the given SwrContext and set the pointer to NULL.
  ///
  /// @param[in] s a pointer to a pointer to Swr context
  void swr_free(
    ffi.Pointer<ffi.Pointer<SwrContext>> s,
  ) {
    return _swr_free(
      s,
    );
  }

  late final _swr_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Pointer<SwrContext>>)>>('swr_free');
  late final _swr_free = _swr_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Pointer<SwrContext>>)>();

  /// Closes the context so that swr_is_initialized() returns 0.
  ///
  /// The context can be brought back to life by running swr_init(),
  /// swr_init() can also be used without swr_close().
  /// This function is mainly provided for simplifying the usecase
  /// where one tries to support libavresample and libswresample.
  ///
  /// @param[in,out] s Swr context to be closed
  void swr_close(
    ffi.Pointer<SwrContext> s,
  ) {
    return _swr_close(
      s,
    );
  }

  late final _swr_closePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SwrContext>)>>(
          'swr_close');
  late final _swr_close =
      _swr_closePtr.asFunction<void Function(ffi.Pointer<SwrContext>)>();

  /// Convert audio.
  ///
  /// in and in_count can be set to 0 to flush the last few samples out at the
  /// end.
  ///
  /// If more input is provided than output space, then the input will be buffered.
  /// You can avoid this buffering by using swr_get_out_samples() to retrieve an
  /// upper bound on the required number of output samples for the given number of
  /// input samples. Conversion will run directly without copying whenever possible.
  ///
  /// @param s         allocated Swr context, with parameters set
  /// @param out       output buffers, only the first one need be set in case of packed audio
  /// @param out_count amount of space available for output in samples per channel
  /// @param in        input buffers, only the first one need to be set in case of packed audio
  /// @param in_count  number of input samples available in one channel
  ///
  /// @return number of samples output per channel, negative value on error
  int swr_convert(
    ffi.Pointer<SwrContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> out,
    int out_count,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> in1,
    int in_count,
  ) {
    return _swr_convert(
      s,
      out,
      out_count,
      in1,
      in_count,
    );
  }

  late final _swr_convertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SwrContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Int)>>('swr_convert');
  late final _swr_convert = _swr_convertPtr.asFunction<
      int Function(ffi.Pointer<SwrContext>, ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          int, ffi.Pointer<ffi.Pointer<ffi.Uint8>>, int)>();

  /// Convert the next timestamp from input to output
  /// timestamps are in 1/(in_sample_rate * out_sample_rate) units.
  ///
  /// @note There are 2 slightly differently behaving modes.
  /// @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)
  /// in this case timestamps will be passed through with delays compensated
  /// @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)
  /// in this case the output timestamps will match output sample numbers.
  /// See ffmpeg-resampler(1) for the two modes of compensation.
  ///
  /// @param[in] s     initialized Swr context
  /// @param[in] pts   timestamp for the next input sample, INT64_MIN if unknown
  /// @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are
  /// function used internally for timestamp compensation.
  /// @return the output timestamp for the next output sample
  int swr_next_pts(
    ffi.Pointer<SwrContext> s,
    int pts,
  ) {
    return _swr_next_pts(
      s,
      pts,
    );
  }

  late final _swr_next_ptsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<SwrContext>, ffi.Int64)>>('swr_next_pts');
  late final _swr_next_pts =
      _swr_next_ptsPtr.asFunction<int Function(ffi.Pointer<SwrContext>, int)>();

  /// Activate resampling compensation ("soft" compensation). This function is
  /// internally called when needed in swr_next_pts().
  ///
  /// @param[in,out] s             allocated Swr context. If it is not initialized,
  /// or SWR_FLAG_RESAMPLE is not set, swr_init() is
  /// called with the flag set.
  /// @param[in]     sample_delta  delta in PTS per sample
  /// @param[in]     compensation_distance number of samples to compensate for
  /// @return    >= 0 on success, AVERROR error codes if:
  /// @li @c s is NULL,
  /// @li @c compensation_distance is less than 0,
  /// @li @c compensation_distance is 0 but sample_delta is not,
  /// @li compensation unsupported by resampler, or
  /// @li swr_init() fails when called.
  int swr_set_compensation(
    ffi.Pointer<SwrContext> s,
    int sample_delta,
    int compensation_distance,
  ) {
    return _swr_set_compensation(
      s,
      sample_delta,
      compensation_distance,
    );
  }

  late final _swr_set_compensationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Int,
              ffi.Int)>>('swr_set_compensation');
  late final _swr_set_compensation = _swr_set_compensationPtr
      .asFunction<int Function(ffi.Pointer<SwrContext>, int, int)>();

  /// Set a customized input channel mapping.
  ///
  /// @param[in,out] s           allocated Swr context, not yet initialized
  /// @param[in]     channel_map customized input channel mapping (array of channel
  /// indexes, -1 for a muted channel)
  /// @return >= 0 on success, or AVERROR error code in case of failure.
  int swr_set_channel_mapping(
    ffi.Pointer<SwrContext> s,
    ffi.Pointer<ffi.Int> channel_map,
  ) {
    return _swr_set_channel_mapping(
      s,
      channel_map,
    );
  }

  late final _swr_set_channel_mappingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwrContext>,
              ffi.Pointer<ffi.Int>)>>('swr_set_channel_mapping');
  late final _swr_set_channel_mapping = _swr_set_channel_mappingPtr.asFunction<
      int Function(ffi.Pointer<SwrContext>, ffi.Pointer<ffi.Int>)>();

  /// Generate a channel mixing matrix.
  ///
  /// This function is the one used internally by libswresample for building the
  /// default mixing matrix. It is made public just as a utility function for
  /// building custom matrices.
  ///
  /// @param in_layout           input channel layout
  /// @param out_layout          output channel layout
  /// @param center_mix_level    mix level for the center channel
  /// @param surround_mix_level  mix level for the surround channel(s)
  /// @param lfe_mix_level       mix level for the low-frequency effects channel
  /// @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent
  /// overflow. if INT_MAX, coefficients will not be
  /// normalized.
  /// @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
  /// the weight of input channel i in output channel o.
  /// @param stride              distance between adjacent input channels in the
  /// matrix array
  /// @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
  /// @param log_ctx             parent logging context, can be NULL
  /// @return                    0 on success, negative AVERROR code on failure
  int swr_build_matrix2(
    ffi.Pointer<AVChannelLayout> in_layout,
    ffi.Pointer<AVChannelLayout> out_layout,
    double center_mix_level,
    double surround_mix_level,
    double lfe_mix_level,
    double maxval,
    double rematrix_volume,
    ffi.Pointer<ffi.Double> matrix,
    Dart__darwin_ptrdiff_t stride,
    AVMatrixEncoding matrix_encoding,
    ffi.Pointer<ffi.Void> log_context,
  ) {
    return _swr_build_matrix2(
      in_layout,
      out_layout,
      center_mix_level,
      surround_mix_level,
      lfe_mix_level,
      maxval,
      rematrix_volume,
      matrix,
      stride,
      matrix_encoding.value,
      log_context,
    );
  }

  late final _swr_build_matrix2Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVChannelLayout>,
              ffi.Pointer<AVChannelLayout>,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Double,
              ffi.Pointer<ffi.Double>,
              ptrdiff_t,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('swr_build_matrix2');
  late final _swr_build_matrix2 = _swr_build_matrix2Ptr.asFunction<
      int Function(
          ffi.Pointer<AVChannelLayout>,
          ffi.Pointer<AVChannelLayout>,
          double,
          double,
          double,
          double,
          double,
          ffi.Pointer<ffi.Double>,
          int,
          int,
          ffi.Pointer<ffi.Void>)>();

  /// Set a customized remix matrix.
  ///
  /// @param s       allocated Swr context, not yet initialized
  /// @param matrix  remix coefficients; matrix[i + stride * o] is
  /// the weight of input channel i in output channel o
  /// @param stride  offset between lines of the matrix
  /// @return  >= 0 on success, or AVERROR error code in case of failure.
  int swr_set_matrix(
    ffi.Pointer<SwrContext> s,
    ffi.Pointer<ffi.Double> matrix,
    int stride,
  ) {
    return _swr_set_matrix(
      s,
      matrix,
      stride,
    );
  }

  late final _swr_set_matrixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Pointer<ffi.Double>,
              ffi.Int)>>('swr_set_matrix');
  late final _swr_set_matrix = _swr_set_matrixPtr.asFunction<
      int Function(ffi.Pointer<SwrContext>, ffi.Pointer<ffi.Double>, int)>();

  /// Drops the specified number of output samples.
  ///
  /// This function, along with swr_inject_silence(), is called by swr_next_pts()
  /// if needed for "hard" compensation.
  ///
  /// @param s     allocated Swr context
  /// @param count number of samples to be dropped
  ///
  /// @return >= 0 on success, or a negative AVERROR code on failure
  int swr_drop_output(
    ffi.Pointer<SwrContext> s,
    int count,
  ) {
    return _swr_drop_output(
      s,
      count,
    );
  }

  late final _swr_drop_outputPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Int)>>(
      'swr_drop_output');
  late final _swr_drop_output = _swr_drop_outputPtr
      .asFunction<int Function(ffi.Pointer<SwrContext>, int)>();

  /// Injects the specified number of silence samples.
  ///
  /// This function, along with swr_drop_output(), is called by swr_next_pts()
  /// if needed for "hard" compensation.
  ///
  /// @param s     allocated Swr context
  /// @param count number of samples to be dropped
  ///
  /// @return >= 0 on success, or a negative AVERROR code on failure
  int swr_inject_silence(
    ffi.Pointer<SwrContext> s,
    int count,
  ) {
    return _swr_inject_silence(
      s,
      count,
    );
  }

  late final _swr_inject_silencePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Int)>>(
      'swr_inject_silence');
  late final _swr_inject_silence = _swr_inject_silencePtr
      .asFunction<int Function(ffi.Pointer<SwrContext>, int)>();

  /// Gets the delay the next input sample will experience relative to the next output sample.
  ///
  /// Swresample can buffer data if more input has been provided than available
  /// output space, also converting between sample rates needs a delay.
  /// This function returns the sum of all such delays.
  /// The exact delay is not necessarily an integer value in either input or
  /// output sample rate. Especially when downsampling by a large value, the
  /// output sample rate may be a poor choice to represent the delay, similarly
  /// for upsampling and the input sample rate.
  ///
  /// @param s     swr context
  /// @param base  timebase in which the returned delay will be:
  /// @li if it's set to 1 the returned delay is in seconds
  /// @li if it's set to 1000 the returned delay is in milliseconds
  /// @li if it's set to the input sample rate then the returned
  /// delay is in input samples
  /// @li if it's set to the output sample rate then the returned
  /// delay is in output samples
  /// @li if it's the least common multiple of in_sample_rate and
  /// out_sample_rate then an exact rounding-free delay will be
  /// returned
  /// @returns     the delay in 1 / @c base units.
  int swr_get_delay(
    ffi.Pointer<SwrContext> s,
    int base,
  ) {
    return _swr_get_delay(
      s,
      base,
    );
  }

  late final _swr_get_delayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int64 Function(
              ffi.Pointer<SwrContext>, ffi.Int64)>>('swr_get_delay');
  late final _swr_get_delay = _swr_get_delayPtr
      .asFunction<int Function(ffi.Pointer<SwrContext>, int)>();

  /// Find an upper bound on the number of samples that the next swr_convert
  /// call will output, if called with in_samples of input samples. This
  /// depends on the internal state, and anything changing the internal state
  /// (like further swr_convert() calls) will may change the number of samples
  /// swr_get_out_samples() returns for the same number of input samples.
  ///
  /// @param in_samples    number of input samples.
  /// @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()
  /// or swr_set_compensation() invalidates this limit
  /// @note it is recommended to pass the correct available buffer size
  /// to all functions like swr_convert() even if swr_get_out_samples()
  /// indicates that less would be used.
  /// @returns an upper bound on the number of samples that the next swr_convert
  /// will output or a negative value to indicate an error
  int swr_get_out_samples(
    ffi.Pointer<SwrContext> s,
    int in_samples,
  ) {
    return _swr_get_out_samples(
      s,
      in_samples,
    );
  }

  late final _swr_get_out_samplesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Int)>>(
      'swr_get_out_samples');
  late final _swr_get_out_samples = _swr_get_out_samplesPtr
      .asFunction<int Function(ffi.Pointer<SwrContext>, int)>();

  /// Return the @ref LIBSWRESAMPLE_VERSION_INT constant.
  ///
  /// This is useful to check if the build-time libswresample has the same version
  /// as the run-time one.
  ///
  /// @returns     the unsigned int-typed version
  int swresample_version() {
    return _swresample_version();
  }

  late final _swresample_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'swresample_version');
  late final _swresample_version =
      _swresample_versionPtr.asFunction<int Function()>();

  /// Return the swr build-time configuration.
  ///
  /// @returns     the build-time @c ./configure flags
  ffi.Pointer<ffi.Char> swresample_configuration() {
    return _swresample_configuration();
  }

  late final _swresample_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'swresample_configuration');
  late final _swresample_configuration = _swresample_configurationPtr
      .asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the swr license.
  ///
  /// @returns     the license of libswresample, determined at build-time
  ffi.Pointer<ffi.Char> swresample_license() {
    return _swresample_license();
  }

  late final _swresample_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'swresample_license');
  late final _swresample_license =
      _swresample_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Convert the samples in the input AVFrame and write them to the output AVFrame.
  ///
  /// Input and output AVFrames must have channel_layout, sample_rate and format set.
  ///
  /// If the output AVFrame does not have the data pointers allocated the nb_samples
  /// field will be set using av_frame_get_buffer()
  /// is called to allocate the frame.
  ///
  /// The output AVFrame can be NULL or have fewer allocated samples than required.
  /// In this case, any remaining samples not written to the output will be added
  /// to an internal FIFO buffer, to be returned at the next call to this function
  /// or to swr_convert().
  ///
  /// If converting sample rate, there may be data remaining in the internal
  /// resampling delay buffer. swr_get_delay() tells the number of
  /// remaining samples. To get this data as output, call this function or
  /// swr_convert() with NULL input.
  ///
  /// If the SwrContext configuration does not match the output and
  /// input AVFrame settings the conversion does not take place and depending on
  /// which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED
  /// or the result of a bitwise-OR of them is returned.
  ///
  /// @see swr_delay()
  /// @see swr_convert()
  /// @see swr_get_delay()
  ///
  /// @param swr             audio resample context
  /// @param output          output AVFrame
  /// @param input           input AVFrame
  /// @return                0 on success, AVERROR on failure or nonmatching
  /// configuration.
  int swr_convert_frame(
    ffi.Pointer<SwrContext> swr,
    ffi.Pointer<AVFrame> output,
    ffi.Pointer<AVFrame> input,
  ) {
    return _swr_convert_frame(
      swr,
      output,
      input,
    );
  }

  late final _swr_convert_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Pointer<AVFrame>,
              ffi.Pointer<AVFrame>)>>('swr_convert_frame');
  late final _swr_convert_frame = _swr_convert_framePtr.asFunction<
      int Function(ffi.Pointer<SwrContext>, ffi.Pointer<AVFrame>,
          ffi.Pointer<AVFrame>)>();

  /// Configure or reconfigure the SwrContext using the information
  /// provided by the AVFrames.
  ///
  /// The original resampling context is reset even on failure.
  /// The function calls swr_close() internally if the context is open.
  ///
  /// @see swr_close();
  ///
  /// @param swr             audio resample context
  /// @param out             output AVFrame
  /// @param in              input AVFrame
  /// @return                0 on success, AVERROR on failure.
  int swr_config_frame(
    ffi.Pointer<SwrContext> swr,
    ffi.Pointer<AVFrame> out,
    ffi.Pointer<AVFrame> in1,
  ) {
    return _swr_config_frame(
      swr,
      out,
      in1,
    );
  }

  late final _swr_config_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwrContext>, ffi.Pointer<AVFrame>,
              ffi.Pointer<AVFrame>)>>('swr_config_frame');
  late final _swr_config_frame = _swr_config_framePtr.asFunction<
      int Function(ffi.Pointer<SwrContext>, ffi.Pointer<AVFrame>,
          ffi.Pointer<AVFrame>)>();

  /// @defgroup libsws libswscale
  /// Color conversion and scaling library.
  ///
  /// @{
  ///
  /// Return the LIBSWSCALE_VERSION_INT constant.
  int swscale_version() {
    return _swscale_version();
  }

  late final _swscale_versionPtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function()>>(
          'swscale_version');
  late final _swscale_version =
      _swscale_versionPtr.asFunction<int Function()>();

  /// Return the libswscale build-time configuration.
  ffi.Pointer<ffi.Char> swscale_configuration() {
    return _swscale_configuration();
  }

  late final _swscale_configurationPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'swscale_configuration');
  late final _swscale_configuration =
      _swscale_configurationPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return the libswscale license.
  ffi.Pointer<ffi.Char> swscale_license() {
    return _swscale_license();
  }

  late final _swscale_licensePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'swscale_license');
  late final _swscale_license =
      _swscale_licensePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Return a pointer to yuv<->rgb coefficients for the given colorspace
  /// suitable for sws_setColorspaceDetails().
  ///
  /// @param colorspace One of the SWS_CS_* macros. If invalid,
  /// SWS_CS_DEFAULT is used.
  ffi.Pointer<ffi.Int> sws_getCoefficients(
    int colorspace,
  ) {
    return _sws_getCoefficients(
      colorspace,
    );
  }

  late final _sws_getCoefficientsPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Int> Function(ffi.Int)>>(
          'sws_getCoefficients');
  late final _sws_getCoefficients =
      _sws_getCoefficientsPtr.asFunction<ffi.Pointer<ffi.Int> Function(int)>();

  /// Return a positive value if pix_fmt is a supported input format, 0
  /// otherwise.
  int sws_isSupportedInput(
    AVPixelFormat pix_fmt,
  ) {
    return _sws_isSupportedInput(
      pix_fmt.value,
    );
  }

  late final _sws_isSupportedInputPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'sws_isSupportedInput');
  late final _sws_isSupportedInput =
      _sws_isSupportedInputPtr.asFunction<int Function(int)>();

  /// Return a positive value if pix_fmt is a supported output format, 0
  /// otherwise.
  int sws_isSupportedOutput(
    AVPixelFormat pix_fmt,
  ) {
    return _sws_isSupportedOutput(
      pix_fmt.value,
    );
  }

  late final _sws_isSupportedOutputPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'sws_isSupportedOutput');
  late final _sws_isSupportedOutput =
      _sws_isSupportedOutputPtr.asFunction<int Function(int)>();

  /// @param[in]  pix_fmt the pixel format
  /// @return a positive value if an endianness conversion for pix_fmt is
  /// supported, 0 otherwise.
  int sws_isSupportedEndiannessConversion(
    AVPixelFormat pix_fmt,
  ) {
    return _sws_isSupportedEndiannessConversion(
      pix_fmt.value,
    );
  }

  late final _sws_isSupportedEndiannessConversionPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'sws_isSupportedEndiannessConversion');
  late final _sws_isSupportedEndiannessConversion =
      _sws_isSupportedEndiannessConversionPtr.asFunction<int Function(int)>();

  /// Allocate an empty SwsContext. This must be filled and passed to
  /// sws_init_context(). For filling see AVOptions, options.c and
  /// sws_setColorspaceDetails().
  ffi.Pointer<SwsContext> sws_alloc_context() {
    return _sws_alloc_context();
  }

  late final _sws_alloc_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SwsContext> Function()>>(
          'sws_alloc_context');
  late final _sws_alloc_context =
      _sws_alloc_contextPtr.asFunction<ffi.Pointer<SwsContext> Function()>();

  /// Initialize the swscaler context sws_context.
  ///
  /// @return zero or positive value on success, a negative value on
  /// error
  int sws_init_context(
    ffi.Pointer<SwsContext> sws_context,
    ffi.Pointer<SwsFilter> srcFilter,
    ffi.Pointer<SwsFilter> dstFilter,
  ) {
    return _sws_init_context(
      sws_context,
      srcFilter,
      dstFilter,
    );
  }

  late final _sws_init_contextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwsContext>, ffi.Pointer<SwsFilter>,
              ffi.Pointer<SwsFilter>)>>('sws_init_context');
  late final _sws_init_context = _sws_init_contextPtr.asFunction<
      int Function(ffi.Pointer<SwsContext>, ffi.Pointer<SwsFilter>,
          ffi.Pointer<SwsFilter>)>();

  /// Free the swscaler context swsContext.
  /// If swsContext is NULL, then does nothing.
  void sws_freeContext(
    ffi.Pointer<SwsContext> swsContext,
  ) {
    return _sws_freeContext(
      swsContext,
    );
  }

  late final _sws_freeContextPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SwsContext>)>>(
          'sws_freeContext');
  late final _sws_freeContext =
      _sws_freeContextPtr.asFunction<void Function(ffi.Pointer<SwsContext>)>();

  /// Allocate and return an SwsContext. You need it to perform
  /// scaling/conversion operations using sws_scale().
  ///
  /// @param srcW the width of the source image
  /// @param srcH the height of the source image
  /// @param srcFormat the source image format
  /// @param dstW the width of the destination image
  /// @param dstH the height of the destination image
  /// @param dstFormat the destination image format
  /// @param flags specify which algorithm and options to use for rescaling
  /// @param param extra parameters to tune the used scaler
  /// For SWS_BICUBIC param[0] and [1] tune the shape of the basis
  /// function, param[0] tunes f(1) and param[1] f´(1)
  /// For SWS_GAUSS param[0] tunes the exponent and thus cutoff
  /// frequency
  /// For SWS_LANCZOS param[0] tunes the width of the window function
  /// @return a pointer to an allocated context, or NULL in case of error
  /// @note this function is to be removed after a saner alternative is
  /// written
  ffi.Pointer<SwsContext> sws_getContext(
    int srcW,
    int srcH,
    AVPixelFormat srcFormat,
    int dstW,
    int dstH,
    AVPixelFormat dstFormat,
    int flags,
    ffi.Pointer<SwsFilter> srcFilter,
    ffi.Pointer<SwsFilter> dstFilter,
    ffi.Pointer<ffi.Double> param,
  ) {
    return _sws_getContext(
      srcW,
      srcH,
      srcFormat.value,
      dstW,
      dstH,
      dstFormat.value,
      flags,
      srcFilter,
      dstFilter,
      param,
    );
  }

  late final _sws_getContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SwsContext> Function(
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<SwsFilter>,
              ffi.Pointer<SwsFilter>,
              ffi.Pointer<ffi.Double>)>>('sws_getContext');
  late final _sws_getContext = _sws_getContextPtr.asFunction<
      ffi.Pointer<SwsContext> Function(
          int,
          int,
          int,
          int,
          int,
          int,
          int,
          ffi.Pointer<SwsFilter>,
          ffi.Pointer<SwsFilter>,
          ffi.Pointer<ffi.Double>)>();

  /// Scale the image slice in srcSlice and put the resulting scaled
  /// slice in the image in dst. A slice is a sequence of consecutive
  /// rows in an image.
  ///
  /// Slices have to be provided in sequential order, either in
  /// top-bottom or bottom-top order. If slices are provided in
  /// non-sequential order the behavior of the function is undefined.
  ///
  /// @param c         the scaling context previously created with
  /// sws_getContext()
  /// @param srcSlice  the array containing the pointers to the planes of
  /// the source slice
  /// @param srcStride the array containing the strides for each plane of
  /// the source image
  /// @param srcSliceY the position in the source image of the slice to
  /// process, that is the number (counted starting from
  /// zero) in the image of the first row of the slice
  /// @param srcSliceH the height of the source slice, that is the number
  /// of rows in the slice
  /// @param dst       the array containing the pointers to the planes of
  /// the destination image
  /// @param dstStride the array containing the strides for each plane of
  /// the destination image
  /// @return          the height of the output slice
  int sws_scale(
    ffi.Pointer<SwsContext> c,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> srcSlice,
    ffi.Pointer<ffi.Int> srcStride,
    int srcSliceY,
    int srcSliceH,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst,
    ffi.Pointer<ffi.Int> dstStride,
  ) {
    return _sws_scale(
      c,
      srcSlice,
      srcStride,
      srcSliceY,
      srcSliceH,
      dst,
      dstStride,
    );
  }

  late final _sws_scalePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SwsContext>,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
              ffi.Pointer<ffi.Int>)>>('sws_scale');
  late final _sws_scale = _sws_scalePtr.asFunction<
      int Function(
          ffi.Pointer<SwsContext>,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>,
          int,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
          ffi.Pointer<ffi.Int>)>();

  /// Scale source data from src and write the output to dst.
  ///
  /// This is merely a convenience wrapper around
  /// - sws_frame_start()
  /// - sws_send_slice(0, src->height)
  /// - sws_receive_slice(0, dst->height)
  /// - sws_frame_end()
  ///
  /// @param c   The scaling context
  /// @param dst The destination frame. See documentation for sws_frame_start() for
  /// more details.
  /// @param src The source frame.
  ///
  /// @return 0 on success, a negative AVERROR code on failure
  int sws_scale_frame(
    ffi.Pointer<SwsContext> c,
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _sws_scale_frame(
      c,
      dst,
      src,
    );
  }

  late final _sws_scale_framePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwsContext>, ffi.Pointer<AVFrame>,
              ffi.Pointer<AVFrame>)>>('sws_scale_frame');
  late final _sws_scale_frame = _sws_scale_framePtr.asFunction<
      int Function(ffi.Pointer<SwsContext>, ffi.Pointer<AVFrame>,
          ffi.Pointer<AVFrame>)>();

  /// Initialize the scaling process for a given pair of source/destination frames.
  /// Must be called before any calls to sws_send_slice() and sws_receive_slice().
  ///
  /// This function will retain references to src and dst, so they must both use
  /// refcounted buffers (if allocated by the caller, in case of dst).
  ///
  /// @param c   The scaling context
  /// @param dst The destination frame.
  ///
  /// The data buffers may either be already allocated by the caller or
  /// left clear, in which case they will be allocated by the scaler.
  /// The latter may have performance advantages - e.g. in certain cases
  /// some output planes may be references to input planes, rather than
  /// copies.
  ///
  /// Output data will be written into this frame in successful
  /// sws_receive_slice() calls.
  /// @param src The source frame. The data buffers must be allocated, but the
  /// frame data does not have to be ready at this point. Data
  /// availability is then signalled by sws_send_slice().
  /// @return 0 on success, a negative AVERROR code on failure
  ///
  /// @see sws_frame_end()
  int sws_frame_start(
    ffi.Pointer<SwsContext> c,
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    return _sws_frame_start(
      c,
      dst,
      src,
    );
  }

  late final _sws_frame_startPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwsContext>, ffi.Pointer<AVFrame>,
              ffi.Pointer<AVFrame>)>>('sws_frame_start');
  late final _sws_frame_start = _sws_frame_startPtr.asFunction<
      int Function(ffi.Pointer<SwsContext>, ffi.Pointer<AVFrame>,
          ffi.Pointer<AVFrame>)>();

  /// Finish the scaling process for a pair of source/destination frames previously
  /// submitted with sws_frame_start(). Must be called after all sws_send_slice()
  /// and sws_receive_slice() calls are done, before any new sws_frame_start()
  /// calls.
  ///
  /// @param c   The scaling context
  void sws_frame_end(
    ffi.Pointer<SwsContext> c,
  ) {
    return _sws_frame_end(
      c,
    );
  }

  late final _sws_frame_endPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SwsContext>)>>(
          'sws_frame_end');
  late final _sws_frame_end =
      _sws_frame_endPtr.asFunction<void Function(ffi.Pointer<SwsContext>)>();

  /// Indicate that a horizontal slice of input data is available in the source
  /// frame previously provided to sws_frame_start(). The slices may be provided in
  /// any order, but may not overlap. For vertically subsampled pixel formats, the
  /// slices must be aligned according to subsampling.
  ///
  /// @param c   The scaling context
  /// @param slice_start first row of the slice
  /// @param slice_height number of rows in the slice
  ///
  /// @return a non-negative number on success, a negative AVERROR code on failure.
  int sws_send_slice(
    ffi.Pointer<SwsContext> c,
    int slice_start,
    int slice_height,
  ) {
    return _sws_send_slice(
      c,
      slice_start,
      slice_height,
    );
  }

  late final _sws_send_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwsContext>, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('sws_send_slice');
  late final _sws_send_slice = _sws_send_slicePtr
      .asFunction<int Function(ffi.Pointer<SwsContext>, int, int)>();

  /// Request a horizontal slice of the output data to be written into the frame
  /// previously provided to sws_frame_start().
  ///
  /// @param c   The scaling context
  /// @param slice_start first row of the slice; must be a multiple of
  /// sws_receive_slice_alignment()
  /// @param slice_height number of rows in the slice; must be a multiple of
  /// sws_receive_slice_alignment(), except for the last slice
  /// (i.e. when slice_start+slice_height is equal to output
  /// frame height)
  ///
  /// @return a non-negative number if the data was successfully written into the output
  /// AVERROR(EAGAIN) if more input data needs to be provided before the
  /// output can be produced
  /// another negative AVERROR code on other kinds of scaling failure
  int sws_receive_slice(
    ffi.Pointer<SwsContext> c,
    int slice_start,
    int slice_height,
  ) {
    return _sws_receive_slice(
      c,
      slice_start,
      slice_height,
    );
  }

  late final _sws_receive_slicePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<SwsContext>, ffi.UnsignedInt,
              ffi.UnsignedInt)>>('sws_receive_slice');
  late final _sws_receive_slice = _sws_receive_slicePtr
      .asFunction<int Function(ffi.Pointer<SwsContext>, int, int)>();

  /// Get the alignment required for slices
  ///
  /// @param c   The scaling context
  /// @return alignment required for output slices requested with sws_receive_slice().
  /// Slice offsets and sizes passed to sws_receive_slice() must be
  /// multiples of the value returned from this function.
  int sws_receive_slice_alignment(
    ffi.Pointer<SwsContext> c,
  ) {
    return _sws_receive_slice_alignment(
      c,
    );
  }

  late final _sws_receive_slice_alignmentPtr = _lookup<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<SwsContext>)>>(
      'sws_receive_slice_alignment');
  late final _sws_receive_slice_alignment = _sws_receive_slice_alignmentPtr
      .asFunction<int Function(ffi.Pointer<SwsContext>)>();

  /// @param c the scaling context
  /// @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
  /// @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
  /// @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
  /// @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
  /// @param brightness 16.16 fixed point brightness correction
  /// @param contrast 16.16 fixed point contrast correction
  /// @param saturation 16.16 fixed point saturation correction
  ///
  /// @return A negative error code on error, non negative otherwise.
  /// If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported.
  int sws_setColorspaceDetails(
    ffi.Pointer<SwsContext> c,
    ffi.Pointer<ffi.Int> inv_table,
    int srcRange,
    ffi.Pointer<ffi.Int> table,
    int dstRange,
    int brightness,
    int contrast,
    int saturation,
  ) {
    return _sws_setColorspaceDetails(
      c,
      inv_table,
      srcRange,
      table,
      dstRange,
      brightness,
      contrast,
      saturation,
    );
  }

  late final _sws_setColorspaceDetailsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SwsContext>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int)>>('sws_setColorspaceDetails');
  late final _sws_setColorspaceDetails =
      _sws_setColorspaceDetailsPtr.asFunction<
          int Function(ffi.Pointer<SwsContext>, ffi.Pointer<ffi.Int>, int,
              ffi.Pointer<ffi.Int>, int, int, int, int)>();

  /// @return A negative error code on error, non negative otherwise.
  /// If `LIBSWSCALE_VERSION_MAJOR < 7`, returns -1 if not supported.
  int sws_getColorspaceDetails(
    ffi.Pointer<SwsContext> c,
    ffi.Pointer<ffi.Pointer<ffi.Int>> inv_table,
    ffi.Pointer<ffi.Int> srcRange,
    ffi.Pointer<ffi.Pointer<ffi.Int>> table,
    ffi.Pointer<ffi.Int> dstRange,
    ffi.Pointer<ffi.Int> brightness,
    ffi.Pointer<ffi.Int> contrast,
    ffi.Pointer<ffi.Int> saturation,
  ) {
    return _sws_getColorspaceDetails(
      c,
      inv_table,
      srcRange,
      table,
      dstRange,
      brightness,
      contrast,
      saturation,
    );
  }

  late final _sws_getColorspaceDetailsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<SwsContext>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('sws_getColorspaceDetails');
  late final _sws_getColorspaceDetails =
      _sws_getColorspaceDetailsPtr.asFunction<
          int Function(
              ffi.Pointer<SwsContext>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>();

  /// Allocate and return an uninitialized vector with length coefficients.
  ffi.Pointer<SwsVector> sws_allocVec(
    int length,
  ) {
    return _sws_allocVec(
      length,
    );
  }

  late final _sws_allocVecPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SwsVector> Function(ffi.Int)>>(
          'sws_allocVec');
  late final _sws_allocVec =
      _sws_allocVecPtr.asFunction<ffi.Pointer<SwsVector> Function(int)>();

  /// Return a normalized Gaussian curve used to filter stuff
  /// quality = 3 is high quality, lower is lower quality.
  ffi.Pointer<SwsVector> sws_getGaussianVec(
    double variance,
    double quality,
  ) {
    return _sws_getGaussianVec(
      variance,
      quality,
    );
  }

  late final _sws_getGaussianVecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SwsVector> Function(
              ffi.Double, ffi.Double)>>('sws_getGaussianVec');
  late final _sws_getGaussianVec = _sws_getGaussianVecPtr
      .asFunction<ffi.Pointer<SwsVector> Function(double, double)>();

  /// Scale all the coefficients of a by the scalar value.
  void sws_scaleVec(
    ffi.Pointer<SwsVector> a,
    double scalar,
  ) {
    return _sws_scaleVec(
      a,
      scalar,
    );
  }

  late final _sws_scaleVecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SwsVector>, ffi.Double)>>('sws_scaleVec');
  late final _sws_scaleVec = _sws_scaleVecPtr
      .asFunction<void Function(ffi.Pointer<SwsVector>, double)>();

  /// Scale all the coefficients of a so that their sum equals height.
  void sws_normalizeVec(
    ffi.Pointer<SwsVector> a,
    double height,
  ) {
    return _sws_normalizeVec(
      a,
      height,
    );
  }

  late final _sws_normalizeVecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<SwsVector>, ffi.Double)>>('sws_normalizeVec');
  late final _sws_normalizeVec = _sws_normalizeVecPtr
      .asFunction<void Function(ffi.Pointer<SwsVector>, double)>();

  void sws_freeVec(
    ffi.Pointer<SwsVector> a,
  ) {
    return _sws_freeVec(
      a,
    );
  }

  late final _sws_freeVecPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SwsVector>)>>(
          'sws_freeVec');
  late final _sws_freeVec =
      _sws_freeVecPtr.asFunction<void Function(ffi.Pointer<SwsVector>)>();

  ffi.Pointer<SwsFilter> sws_getDefaultFilter(
    double lumaGBlur,
    double chromaGBlur,
    double lumaSharpen,
    double chromaSharpen,
    double chromaHShift,
    double chromaVShift,
    int verbose,
  ) {
    return _sws_getDefaultFilter(
      lumaGBlur,
      chromaGBlur,
      lumaSharpen,
      chromaSharpen,
      chromaHShift,
      chromaVShift,
      verbose,
    );
  }

  late final _sws_getDefaultFilterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SwsFilter> Function(
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Float,
              ffi.Int)>>('sws_getDefaultFilter');
  late final _sws_getDefaultFilter = _sws_getDefaultFilterPtr.asFunction<
      ffi.Pointer<SwsFilter> Function(
          double, double, double, double, double, double, int)>();

  void sws_freeFilter(
    ffi.Pointer<SwsFilter> filter,
  ) {
    return _sws_freeFilter(
      filter,
    );
  }

  late final _sws_freeFilterPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SwsFilter>)>>(
          'sws_freeFilter');
  late final _sws_freeFilter =
      _sws_freeFilterPtr.asFunction<void Function(ffi.Pointer<SwsFilter>)>();

  /// Check if context can be reused, otherwise reallocate a new one.
  ///
  /// If context is NULL, just calls sws_getContext() to get a new
  /// context. Otherwise, checks if the parameters are the ones already
  /// saved in context. If that is the case, returns the current
  /// context. Otherwise, frees context and gets a new context with
  /// the new parameters.
  ///
  /// Be warned that srcFilter and dstFilter are not checked, they
  /// are assumed to remain the same.
  ffi.Pointer<SwsContext> sws_getCachedContext(
    ffi.Pointer<SwsContext> context,
    int srcW,
    int srcH,
    AVPixelFormat srcFormat,
    int dstW,
    int dstH,
    AVPixelFormat dstFormat,
    int flags,
    ffi.Pointer<SwsFilter> srcFilter,
    ffi.Pointer<SwsFilter> dstFilter,
    ffi.Pointer<ffi.Double> param,
  ) {
    return _sws_getCachedContext(
      context,
      srcW,
      srcH,
      srcFormat.value,
      dstW,
      dstH,
      dstFormat.value,
      flags,
      srcFilter,
      dstFilter,
      param,
    );
  }

  late final _sws_getCachedContextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<SwsContext> Function(
              ffi.Pointer<SwsContext>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<SwsFilter>,
              ffi.Pointer<SwsFilter>,
              ffi.Pointer<ffi.Double>)>>('sws_getCachedContext');
  late final _sws_getCachedContext = _sws_getCachedContextPtr.asFunction<
      ffi.Pointer<SwsContext> Function(
          ffi.Pointer<SwsContext>,
          int,
          int,
          int,
          int,
          int,
          int,
          int,
          ffi.Pointer<SwsFilter>,
          ffi.Pointer<SwsFilter>,
          ffi.Pointer<ffi.Double>)>();

  /// Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
  ///
  /// The output frame will have the same packed format as the palette.
  ///
  /// @param src        source frame buffer
  /// @param dst        destination frame buffer
  /// @param num_pixels number of pixels to convert
  /// @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
  void sws_convertPalette8ToPacked32(
    ffi.Pointer<ffi.Uint8> src,
    ffi.Pointer<ffi.Uint8> dst,
    int num_pixels,
    ffi.Pointer<ffi.Uint8> palette,
  ) {
    return _sws_convertPalette8ToPacked32(
      src,
      dst,
      num_pixels,
      palette,
    );
  }

  late final _sws_convertPalette8ToPacked32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>)>>('sws_convertPalette8ToPacked32');
  late final _sws_convertPalette8ToPacked32 =
      _sws_convertPalette8ToPacked32Ptr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>)>();

  /// Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
  ///
  /// With the palette format "ABCD", the destination frame ends up with the format "ABC".
  ///
  /// @param src        source frame buffer
  /// @param dst        destination frame buffer
  /// @param num_pixels number of pixels to convert
  /// @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
  void sws_convertPalette8ToPacked24(
    ffi.Pointer<ffi.Uint8> src,
    ffi.Pointer<ffi.Uint8> dst,
    int num_pixels,
    ffi.Pointer<ffi.Uint8> palette,
  ) {
    return _sws_convertPalette8ToPacked24(
      src,
      dst,
      num_pixels,
      palette,
    );
  }

  late final _sws_convertPalette8ToPacked24Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Uint8>,
              ffi.Pointer<ffi.Uint8>,
              ffi.Int,
              ffi.Pointer<ffi.Uint8>)>>('sws_convertPalette8ToPacked24');
  late final _sws_convertPalette8ToPacked24 =
      _sws_convertPalette8ToPacked24Ptr.asFunction<
          void Function(ffi.Pointer<ffi.Uint8>, ffi.Pointer<ffi.Uint8>, int,
              ffi.Pointer<ffi.Uint8>)>();

  /// Get the AVClass for swsContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> sws_get_class() {
    return _sws_get_class();
  }

  late final _sws_get_classPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<AVClass> Function()>>(
          'sws_get_class');
  late final _sws_get_class =
      _sws_get_classPtr.asFunction<ffi.Pointer<AVClass> Function()>();
}

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// Audio sample formats
///
/// - The data described by the sample format is always in native-endian order.
/// Sample values can be expressed by native C types, hence the lack of a signed
/// 24-bit sample format even though it is a common raw audio data format.
///
/// - The floating-point formats are based on full volume being in the range
/// [-1.0, 1.0]. Any values outside this range are beyond full volume level.
///
/// - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg
/// (such as AVFrame in libavcodec) is as follows:
///
/// @par
/// For planar sample formats, each audio channel is in a separate data plane,
/// and linesize is the buffer size, in bytes, for a single plane. All data
/// planes must be the same size. For packed sample formats, only the first data
/// plane is used, and samples for each channel are interleaved. In this case,
/// linesize is the buffer size, in bytes, for the 1 plane.
enum AVSampleFormat {
  AV_SAMPLE_FMT_NONE(-1),

  /// < unsigned 8 bits
  AV_SAMPLE_FMT_U8(0),

  /// < signed 16 bits
  AV_SAMPLE_FMT_S16(1),

  /// < signed 32 bits
  AV_SAMPLE_FMT_S32(2),

  /// < float
  AV_SAMPLE_FMT_FLT(3),

  /// < double
  AV_SAMPLE_FMT_DBL(4),

  /// < unsigned 8 bits, planar
  AV_SAMPLE_FMT_U8P(5),

  /// < signed 16 bits, planar
  AV_SAMPLE_FMT_S16P(6),

  /// < signed 32 bits, planar
  AV_SAMPLE_FMT_S32P(7),

  /// < float, planar
  AV_SAMPLE_FMT_FLTP(8),

  /// < double, planar
  AV_SAMPLE_FMT_DBLP(9),

  /// < signed 64 bits
  AV_SAMPLE_FMT_S64(10),

  /// < signed 64 bits, planar
  AV_SAMPLE_FMT_S64P(11),

  /// < Number of sample formats. DO NOT USE if linking dynamically
  AV_SAMPLE_FMT_NB(12);

  final int value;
  const AVSampleFormat(this.value);

  static AVSampleFormat fromValue(int value) => switch (value) {
        -1 => AV_SAMPLE_FMT_NONE,
        0 => AV_SAMPLE_FMT_U8,
        1 => AV_SAMPLE_FMT_S16,
        2 => AV_SAMPLE_FMT_S32,
        3 => AV_SAMPLE_FMT_FLT,
        4 => AV_SAMPLE_FMT_DBL,
        5 => AV_SAMPLE_FMT_U8P,
        6 => AV_SAMPLE_FMT_S16P,
        7 => AV_SAMPLE_FMT_S32P,
        8 => AV_SAMPLE_FMT_FLTP,
        9 => AV_SAMPLE_FMT_DBLP,
        10 => AV_SAMPLE_FMT_S64,
        11 => AV_SAMPLE_FMT_S64P,
        12 => AV_SAMPLE_FMT_NB,
        _ => throw ArgumentError("Unknown value for AVSampleFormat: $value"),
      };
}

/// @addtogroup lavu_media Media Type
/// @brief Media Type
enum AVMediaType {
  /// < Usually treated as AVMEDIA_TYPE_DATA
  AVMEDIA_TYPE_UNKNOWN(-1),
  AVMEDIA_TYPE_VIDEO(0),
  AVMEDIA_TYPE_AUDIO(1),

  /// < Opaque data information usually continuous
  AVMEDIA_TYPE_DATA(2),
  AVMEDIA_TYPE_SUBTITLE(3),

  /// < Opaque data information usually sparse
  AVMEDIA_TYPE_ATTACHMENT(4),
  AVMEDIA_TYPE_NB(5);

  final int value;
  const AVMediaType(this.value);

  static AVMediaType fromValue(int value) => switch (value) {
        -1 => AVMEDIA_TYPE_UNKNOWN,
        0 => AVMEDIA_TYPE_VIDEO,
        1 => AVMEDIA_TYPE_AUDIO,
        2 => AVMEDIA_TYPE_DATA,
        3 => AVMEDIA_TYPE_SUBTITLE,
        4 => AVMEDIA_TYPE_ATTACHMENT,
        5 => AVMEDIA_TYPE_NB,
        _ => throw ArgumentError("Unknown value for AVMediaType: $value"),
      };
}

/// @}
/// @}
/// @defgroup lavu_picture Image related
///
/// AVPicture types, pixel formats and basic image planes manipulation.
///
/// @{
enum AVPictureType {
  /// < Undefined
  AV_PICTURE_TYPE_NONE(0),

  /// < Intra
  AV_PICTURE_TYPE_I(1),

  /// < Predicted
  AV_PICTURE_TYPE_P(2),

  /// < Bi-dir predicted
  AV_PICTURE_TYPE_B(3),

  /// < S(GMC)-VOP MPEG-4
  AV_PICTURE_TYPE_S(4),

  /// < Switching Intra
  AV_PICTURE_TYPE_SI(5),

  /// < Switching Predicted
  AV_PICTURE_TYPE_SP(6),

  /// < BI type
  AV_PICTURE_TYPE_BI(7);

  final int value;
  const AVPictureType(this.value);

  static AVPictureType fromValue(int value) => switch (value) {
        0 => AV_PICTURE_TYPE_NONE,
        1 => AV_PICTURE_TYPE_I,
        2 => AV_PICTURE_TYPE_P,
        3 => AV_PICTURE_TYPE_B,
        4 => AV_PICTURE_TYPE_S,
        5 => AV_PICTURE_TYPE_SI,
        6 => AV_PICTURE_TYPE_SP,
        7 => AV_PICTURE_TYPE_BI,
        _ => throw ArgumentError("Unknown value for AVPictureType: $value"),
      };
}

typedef intmax_t = ffi.Long;
typedef Dartintmax_t = int;

final class imaxdiv_t extends ffi.Struct {
  @intmax_t()
  external int quot;

  @intmax_t()
  external int rem;
}

typedef uintmax_t = ffi.UnsignedLong;
typedef Dartuintmax_t = int;

final class __float2 extends ffi.Struct {
  @ffi.Float()
  external double __sinval;

  @ffi.Float()
  external double __cosval;
}

final class __double2 extends ffi.Struct {
  @ffi.Double()
  external double __sinval;

  @ffi.Double()
  external double __cosval;
}

final class exception extends ffi.Struct {
  @ffi.Int()
  external int type;

  external ffi.Pointer<ffi.Char> name;

  @ffi.Double()
  external double arg1;

  @ffi.Double()
  external double arg2;

  @ffi.Double()
  external double retval;
}

final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

final class __sFILEX extends ffi.Opaque {}

final class __sFILE extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _p;

  @ffi.Int()
  external int _r;

  @ffi.Int()
  external int _w;

  @ffi.Short()
  external int _flags;

  @ffi.Short()
  external int _file;

  external __sbuf _bf;

  @ffi.Int()
  external int _lbfsize;

  external ffi.Pointer<ffi.Void> _cookie;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      _close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _read;

  external ffi.Pointer<
      ffi.NativeFunction<
          fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>> _seek;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)>> _write;

  external __sbuf _ub;

  external ffi.Pointer<__sFILEX> _extra;

  @ffi.Int()
  external int _ur;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  external __sbuf _lb;

  @ffi.Int()
  external int _blksize;

  @fpos_t()
  external int _offset;
}

typedef fpos_t = __darwin_off_t;
typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;
typedef FILE = __sFILE;
typedef va_list = __darwin_va_list;
typedef __darwin_va_list = __builtin_va_list;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef off_t = __darwin_off_t;
typedef ssize_t = __darwin_ssize_t;
typedef __darwin_ssize_t = ffi.Long;
typedef Dart__darwin_ssize_t = int;

enum idtype_t {
  P_ALL(0),
  P_PID(1),
  P_PGID(2);

  final int value;
  const idtype_t(this.value);

  static idtype_t fromValue(int value) => switch (value) {
        0 => P_ALL,
        1 => P_PID,
        2 => P_PGID,
        _ => throw ArgumentError("Unknown value for idtype_t: $value"),
      };
}

final class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

final class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  @__darwin_sigset_t()
  external int uc_sigmask;

  external __darwin_sigaltstack uc_stack;

  external ffi.Pointer<__darwin_ucontext> uc_link;

  @__darwin_size_t()
  external int uc_mcsize;

  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef __darwin_sigset_t = __uint32_t;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

final class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;

final class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

final class sigvec extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  @ffi.Int()
  external int sv_mask;

  @ffi.Int()
  external int sv_flags;
}

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_suseconds_t = __int32_t;

final class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

final class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

typedef rlim_t = __uint64_t;

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

typedef id_t = __darwin_id_t;
typedef __darwin_id_t = __uint32_t;

final class wait extends ffi.Opaque {}

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef __darwin_dev_t = __int32_t;
typedef mode_t = __darwin_mode_t;
typedef __darwin_mode_t = __uint16_t;
typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;
typedef errno_t = ffi.Int;
typedef Darterrno_t = int;
typedef rsize_t = __darwin_size_t;

/// Rational number (pair of numerator and denominator).
final class AVRational extends ffi.Struct {
  /// < Numerator
  @ffi.Int()
  external int num;

  /// < Denominator
  @ffi.Int()
  external int den;
}

final class av_intfloat32 extends ffi.Union {
  @ffi.Uint32()
  external int i;

  @ffi.Float()
  external double f;
}

final class av_intfloat64 extends ffi.Union {
  @ffi.Uint64()
  external int i;

  @ffi.Double()
  external double f;
}

/// Rounding methods.
enum AVRounding {
  /// < Round toward zero.
  AV_ROUND_ZERO(0),

  /// < Round away from zero.
  AV_ROUND_INF(1),

  /// < Round toward -infinity.
  AV_ROUND_DOWN(2),

  /// < Round toward +infinity.
  AV_ROUND_UP(3),

  /// < Round to nearest and halfway cases away from zero.
  AV_ROUND_NEAR_INF(5),

  /// Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
  /// unchanged, avoiding special cases for #AV_NOPTS_VALUE.
  ///
  /// Unlike other values of the enumeration AVRounding, this value is a
  /// bitmask that must be used in conjunction with another value of the
  /// enumeration through a bitwise OR, in order to set behavior for normal
  /// cases.
  ///
  /// @code{.c}
  /// av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
  /// // Rescaling 3:
  /// //     Calculating 3 * 1 / 2
  /// //     3 / 2 is rounded up to 2
  /// //     => 2
  ///
  /// av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
  /// // Rescaling AV_NOPTS_VALUE:
  /// //     AV_NOPTS_VALUE == INT64_MIN
  /// //     AV_NOPTS_VALUE is passed through
  /// //     => AV_NOPTS_VALUE
  /// @endcode
  AV_ROUND_PASS_MINMAX(8192);

  final int value;
  const AVRounding(this.value);

  static AVRounding fromValue(int value) => switch (value) {
        0 => AV_ROUND_ZERO,
        1 => AV_ROUND_INF,
        2 => AV_ROUND_DOWN,
        3 => AV_ROUND_UP,
        5 => AV_ROUND_NEAR_INF,
        8192 => AV_ROUND_PASS_MINMAX,
        _ => throw ArgumentError("Unknown value for AVRounding: $value"),
      };
}

enum AVClassCategory {
  AV_CLASS_CATEGORY_NA(0),
  AV_CLASS_CATEGORY_INPUT(1),
  AV_CLASS_CATEGORY_OUTPUT(2),
  AV_CLASS_CATEGORY_MUXER(3),
  AV_CLASS_CATEGORY_DEMUXER(4),
  AV_CLASS_CATEGORY_ENCODER(5),
  AV_CLASS_CATEGORY_DECODER(6),
  AV_CLASS_CATEGORY_FILTER(7),
  AV_CLASS_CATEGORY_BITSTREAM_FILTER(8),
  AV_CLASS_CATEGORY_SWSCALER(9),
  AV_CLASS_CATEGORY_SWRESAMPLER(10),
  AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT(40),
  AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT(41),
  AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT(42),
  AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT(43),
  AV_CLASS_CATEGORY_DEVICE_OUTPUT(44),
  AV_CLASS_CATEGORY_DEVICE_INPUT(45),

  /// < not part of ABI/API
  AV_CLASS_CATEGORY_NB(46);

  final int value;
  const AVClassCategory(this.value);

  static AVClassCategory fromValue(int value) => switch (value) {
        0 => AV_CLASS_CATEGORY_NA,
        1 => AV_CLASS_CATEGORY_INPUT,
        2 => AV_CLASS_CATEGORY_OUTPUT,
        3 => AV_CLASS_CATEGORY_MUXER,
        4 => AV_CLASS_CATEGORY_DEMUXER,
        5 => AV_CLASS_CATEGORY_ENCODER,
        6 => AV_CLASS_CATEGORY_DECODER,
        7 => AV_CLASS_CATEGORY_FILTER,
        8 => AV_CLASS_CATEGORY_BITSTREAM_FILTER,
        9 => AV_CLASS_CATEGORY_SWSCALER,
        10 => AV_CLASS_CATEGORY_SWRESAMPLER,
        40 => AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT,
        41 => AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT,
        42 => AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT,
        43 => AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT,
        44 => AV_CLASS_CATEGORY_DEVICE_OUTPUT,
        45 => AV_CLASS_CATEGORY_DEVICE_INPUT,
        46 => AV_CLASS_CATEGORY_NB,
        _ => throw ArgumentError("Unknown value for AVClassCategory: $value"),
      };
}

/// List of AVOptionRange structs.
final class AVOptionRanges extends ffi.Struct {
  /// Array of option ranges.
  ///
  /// Most of option types use just one component.
  /// Following describes multi-component option types:
  ///
  /// AV_OPT_TYPE_IMAGE_SIZE:
  /// component index 0: range of pixel count (width * height).
  /// component index 1: range of width.
  /// component index 2: range of height.
  ///
  /// @note To obtain multi-component version of this structure, user must
  /// provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or
  /// av_opt_query_ranges_default function.
  ///
  /// Multi-component range can be read as in following example:
  ///
  /// @code
  /// int range_index, component_index;
  /// AVOptionRanges *ranges;
  /// AVOptionRange *range[3]; //may require more than 3 in the future.
  /// av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);
  /// for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {
  /// for (component_index = 0; component_index < ranges->nb_components; component_index++)
  /// range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];
  /// //do something with range here.
  /// }
  /// av_opt_freep_ranges(&ranges);
  /// @endcode
  external ffi.Pointer<ffi.Pointer<AVOptionRange>> range;

  /// Number of ranges per component.
  @ffi.Int()
  external int nb_ranges;

  /// Number of componentes.
  @ffi.Int()
  external int nb_components;
}

/// A single allowed range of values, or a single allowed value.
final class AVOptionRange extends ffi.Struct {
  external ffi.Pointer<ffi.Char> str;

  /// Value range.
  /// For string ranges this represents the min/max length.
  /// For dimensions this represents the min/max pixel count or width/height in multi-component case.
  @ffi.Double()
  external double value_min;

  @ffi.Double()
  external double value_max;

  /// Value's component range.
  /// For string this represents the unicode range for chars, 0-127 limits to ASCII.
  @ffi.Double()
  external double component_min;

  @ffi.Double()
  external double component_max;

  /// Range flag.
  /// If set to 1 the struct encodes a range, if set to 0 a single value.
  @ffi.Int()
  external int is_range;
}

/// Describe the class of an AVClass context structure. That is an
/// arbitrary struct of which the first field is a pointer to an
/// AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
final class AVClass extends ffi.Struct {
  /// The name of the class; usually it is the same name as the
  /// context structure type to which the AVClass is associated.
  external ffi.Pointer<ffi.Char> class_name;

  /// A pointer to a function which returns the name of a context
  /// instance ctx associated with the class.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Void> ctx)>> item_name;

  /// a pointer to the first option specified in the class if any or NULL
  ///
  /// @see av_set_default_options()
  external ffi.Pointer<AVOption> option;

  /// LIBAVUTIL_VERSION with which this structure was created.
  /// This is used to allow fields to be added without requiring major
  /// version bumps everywhere.
  @ffi.Int()
  external int version;

  /// Offset in the structure where log_level_offset is stored.
  /// 0 means there is no such variable
  @ffi.Int()
  external int log_level_offset_offset;

  /// Offset in the structure where a pointer to the parent context for
  /// logging is stored. For example a decoder could pass its AVCodecContext
  /// to eval as such a parent context, which an av_log() implementation
  /// could then leverage to display the parent context.
  /// The offset can be NULL.
  @ffi.Int()
  external int parent_log_context_offset;

  /// Category used for visualization (like color)
  /// This is only set if the category is equal for all objects using this class.
  /// available since version (51 << 16 | 56 << 8 | 100)
  @ffi.UnsignedInt()
  external int categoryAsInt;

  AVClassCategory get category => AVClassCategory.fromValue(categoryAsInt);

  /// Callback to return the category.
  /// available since version (51 << 16 | 59 << 8 | 100)
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<ffi.Void> ctx)>>
      get_category;

  /// Callback to return the supported/allowed ranges.
  /// available since version (52.12)
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<AVOptionRanges>>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>> query_ranges;

  /// Return next AVOptions-enabled child or NULL
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Pointer<ffi.Void> Function(
                  ffi.Pointer<ffi.Void> obj, ffi.Pointer<ffi.Void> prev)>>
      child_next;

  /// Iterate over the AVClasses corresponding to potential AVOptions-enabled
  /// children.
  ///
  /// @param iter pointer to opaque iteration state. The caller must initialize
  /// *iter to NULL before the first call.
  /// @return AVClass for the next AVOptions-enabled child or NULL if there are
  /// no more such children.
  ///
  /// @note The difference between child_next and this is that child_next
  /// iterates over _already existing_ objects, while child_class_iterate
  /// iterates over _all possible_ children.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<AVClass> Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>> iter)>> child_class_iterate;
}

/// AVOption
final class AVOption extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  /// short English help text
  /// @todo What about other languages?
  external ffi.Pointer<ffi.Char> help;

  /// Native access only.
  ///
  /// The offset relative to the context structure where the option
  /// value is stored. It should be 0 for named constants.
  @ffi.Int()
  external int offset;

  @ffi.UnsignedInt()
  external int typeAsInt;

  AVOptionType get type => AVOptionType.fromValue(typeAsInt);

  external UnnamedUnion1 default_val;

  /// < minimum valid value for the option
  @ffi.Double()
  external double min;

  /// < maximum valid value for the option
  @ffi.Double()
  external double max;

  /// A combination of AV_OPT_FLAG_*.
  @ffi.Int()
  external int flags;

  /// The logical unit to which the option belongs. Non-constant
  /// options and corresponding named constants share the same
  /// unit. May be NULL.
  external ffi.Pointer<ffi.Char> unit;
}

/// An option type determines:
/// - for native access, the underlying C type of the field that an AVOption
/// refers to;
/// - for foreign access, the semantics of accessing the option through this API,
/// e.g. which av_opt_get_*() and av_opt_set_*() functions can be called, or
/// what format will av_opt_get()/av_opt_set() expect/produce.
enum AVOptionType {
  /// Underlying C type is unsigned int.
  AV_OPT_TYPE_FLAGS(1),

  /// Underlying C type is int.
  AV_OPT_TYPE_INT(2),

  /// Underlying C type is int64_t.
  AV_OPT_TYPE_INT64(3),

  /// Underlying C type is double.
  AV_OPT_TYPE_DOUBLE(4),

  /// Underlying C type is float.
  AV_OPT_TYPE_FLOAT(5),

  /// Underlying C type is a uint8_t* that is either NULL or points to a C
  /// string allocated with the av_malloc() family of functions.
  AV_OPT_TYPE_STRING(6),

  /// Underlying C type is AVRational.
  AV_OPT_TYPE_RATIONAL(7),

  /// Underlying C type is a uint8_t* that is either NULL or points to an array
  /// allocated with the av_malloc() family of functions. The pointer is
  /// immediately followed by an int containing the array length in bytes.
  AV_OPT_TYPE_BINARY(8),

  /// Underlying C type is AVDictionary*.
  AV_OPT_TYPE_DICT(9),

  /// Underlying C type is uint64_t.
  AV_OPT_TYPE_UINT64(10),

  /// Special option type for declaring named constants. Does not correspond to
  /// an actual field in the object, offset must be 0.
  AV_OPT_TYPE_CONST(11),

  /// Underlying C type is two consecutive integers.
  AV_OPT_TYPE_IMAGE_SIZE(12),

  /// Underlying C type is enum AVPixelFormat.
  AV_OPT_TYPE_PIXEL_FMT(13),

  /// Underlying C type is enum AVSampleFormat.
  AV_OPT_TYPE_SAMPLE_FMT(14),

  /// Underlying C type is AVRational.
  AV_OPT_TYPE_VIDEO_RATE(15),

  /// Underlying C type is int64_t.
  AV_OPT_TYPE_DURATION(16),

  /// Underlying C type is uint8_t[4].
  AV_OPT_TYPE_COLOR(17),

  /// Underlying C type is int.
  AV_OPT_TYPE_BOOL(18),

  /// Underlying C type is AVChannelLayout.
  AV_OPT_TYPE_CHLAYOUT(19),

  /// Underlying C type is unsigned int.
  AV_OPT_TYPE_UINT(20),

  /// May be combined with another regular option type to declare an array
  /// option.
  ///
  /// For array options, @ref AVOption.offset should refer to a pointer
  /// corresponding to the option type. The pointer should be immediately
  /// followed by an unsigned int that will store the number of elements in the
  /// array.
  AV_OPT_TYPE_FLAG_ARRAY(65536);

  final int value;
  const AVOptionType(this.value);

  static AVOptionType fromValue(int value) => switch (value) {
        1 => AV_OPT_TYPE_FLAGS,
        2 => AV_OPT_TYPE_INT,
        3 => AV_OPT_TYPE_INT64,
        4 => AV_OPT_TYPE_DOUBLE,
        5 => AV_OPT_TYPE_FLOAT,
        6 => AV_OPT_TYPE_STRING,
        7 => AV_OPT_TYPE_RATIONAL,
        8 => AV_OPT_TYPE_BINARY,
        9 => AV_OPT_TYPE_DICT,
        10 => AV_OPT_TYPE_UINT64,
        11 => AV_OPT_TYPE_CONST,
        12 => AV_OPT_TYPE_IMAGE_SIZE,
        13 => AV_OPT_TYPE_PIXEL_FMT,
        14 => AV_OPT_TYPE_SAMPLE_FMT,
        15 => AV_OPT_TYPE_VIDEO_RATE,
        16 => AV_OPT_TYPE_DURATION,
        17 => AV_OPT_TYPE_COLOR,
        18 => AV_OPT_TYPE_BOOL,
        19 => AV_OPT_TYPE_CHLAYOUT,
        20 => AV_OPT_TYPE_UINT,
        65536 => AV_OPT_TYPE_FLAG_ARRAY,
        _ => throw ArgumentError("Unknown value for AVOptionType: $value"),
      };
}

/// Native access only, except when documented otherwise.
/// the default value for scalar options
final class UnnamedUnion1 extends ffi.Union {
  @ffi.Int64()
  external int i64;

  @ffi.Double()
  external double dbl;

  external ffi.Pointer<ffi.Char> str;

  external AVRational q;

  /// Used for AV_OPT_TYPE_FLAG_ARRAY options. May be NULL.
  ///
  /// Foreign access to some members allowed, as noted in AVOptionArrayDef
  /// documentation.
  external ffi.Pointer<AVOptionArrayDef> arr;
}

/// May be set as default_val for AV_OPT_TYPE_FLAG_ARRAY options.
final class AVOptionArrayDef extends ffi.Struct {
  /// Native access only.
  ///
  /// Default value of the option, as would be serialized by av_opt_get() (i.e.
  /// using the value of sep as the separator).
  external ffi.Pointer<ffi.Char> def;

  /// Minimum number of elements in the array. When this field is non-zero, def
  /// must be non-NULL and contain at least this number of elements.
  @ffi.UnsignedInt()
  external int size_min;

  /// Maximum number of elements in the array, 0 when unlimited.
  @ffi.UnsignedInt()
  external int size_max;

  /// Separator between array elements in string representations of this
  /// option, used by av_opt_set() and av_opt_get(). It must be a printable
  /// ASCII character, excluding alphanumeric and the backslash. A comma is
  /// used when sep=0.
  ///
  /// The separator and the backslash must be backslash-escaped in order to
  /// appear in string representations of the option value.
  @ffi.Char()
  external int sep;
}

typedef va_list1 = __builtin_va_list;

/// Pixel format.
///
/// @note
/// AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
/// color is put together as:
/// (A << 24) | (R << 16) | (G << 8) | B
/// This is stored as BGRA on little-endian CPU architectures and ARGB on
/// big-endian CPUs.
///
/// @note
/// If the resolution is not a multiple of the chroma subsampling factor
/// then the chroma plane resolution must be rounded up.
///
/// @par
/// When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
/// image data is stored in AVFrame.data[0]. The palette is transported in
/// AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
/// formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
/// also endian-specific). Note also that the individual RGB32 palette
/// components stored in AVFrame.data[1] should be in the range 0..255.
/// This is important as many custom PAL8 video codecs that were designed
/// to run on the IBM VGA graphics adapter use 6-bit palette components.
///
/// @par
/// For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
/// for pal8. This palette is filled in automatically by the function
/// allocating the picture.
enum AVPixelFormat {
  AV_PIX_FMT_NONE(-1),

  /// < planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
  AV_PIX_FMT_YUV420P(0),

  /// < packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
  AV_PIX_FMT_YUYV422(1),

  /// < packed RGB 8:8:8, 24bpp, RGBRGB...
  AV_PIX_FMT_RGB24(2),

  /// < packed RGB 8:8:8, 24bpp, BGRBGR...
  AV_PIX_FMT_BGR24(3),

  /// < planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
  AV_PIX_FMT_YUV422P(4),

  /// < planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)
  AV_PIX_FMT_YUV444P(5),

  /// < planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
  AV_PIX_FMT_YUV410P(6),

  /// < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
  AV_PIX_FMT_YUV411P(7),

  /// <        Y        ,  8bpp
  AV_PIX_FMT_GRAY8(8),

  /// <        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
  AV_PIX_FMT_MONOWHITE(9),

  /// <        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
  AV_PIX_FMT_MONOBLACK(10),

  /// < 8 bits with AV_PIX_FMT_RGB32 palette
  AV_PIX_FMT_PAL8(11),

  /// < planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range
  AV_PIX_FMT_YUVJ420P(12),

  /// < planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range
  AV_PIX_FMT_YUVJ422P(13),

  /// < planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range
  AV_PIX_FMT_YUVJ444P(14),

  /// < packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
  AV_PIX_FMT_UYVY422(15),

  /// < packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
  AV_PIX_FMT_UYYVYY411(16),

  /// < packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
  AV_PIX_FMT_BGR8(17),

  /// < packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
  AV_PIX_FMT_BGR4(18),

  /// < packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
  AV_PIX_FMT_BGR4_BYTE(19),

  /// < packed RGB 3:3:2,  8bpp, (msb)3R 3G 2B(lsb)
  AV_PIX_FMT_RGB8(20),

  /// < packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
  AV_PIX_FMT_RGB4(21),

  /// < packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
  AV_PIX_FMT_RGB4_BYTE(22),

  /// < planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
  AV_PIX_FMT_NV12(23),

  /// < as above, but U and V bytes are swapped
  AV_PIX_FMT_NV21(24),

  /// < packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
  AV_PIX_FMT_ARGB(25),

  /// < packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
  AV_PIX_FMT_RGBA(26),

  /// < packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
  AV_PIX_FMT_ABGR(27),

  /// < packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
  AV_PIX_FMT_BGRA(28),

  /// <        Y        , 16bpp, big-endian
  AV_PIX_FMT_GRAY16BE(29),

  /// <        Y        , 16bpp, little-endian
  AV_PIX_FMT_GRAY16LE(30),

  /// < planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
  AV_PIX_FMT_YUV440P(31),

  /// < planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range
  AV_PIX_FMT_YUVJ440P(32),

  /// < planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
  AV_PIX_FMT_YUVA420P(33),

  /// < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
  AV_PIX_FMT_RGB48BE(34),

  /// < packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
  AV_PIX_FMT_RGB48LE(35),

  /// < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
  AV_PIX_FMT_RGB565BE(36),

  /// < packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
  AV_PIX_FMT_RGB565LE(37),

  /// < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined
  AV_PIX_FMT_RGB555BE(38),

  /// < packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined
  AV_PIX_FMT_RGB555LE(39),

  /// < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
  AV_PIX_FMT_BGR565BE(40),

  /// < packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
  AV_PIX_FMT_BGR565LE(41),

  /// < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined
  AV_PIX_FMT_BGR555BE(42),

  /// < packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined
  AV_PIX_FMT_BGR555LE(43),

  /// Hardware acceleration through VA-API, data[3] contains a
  /// VASurfaceID.
  AV_PIX_FMT_VAAPI(44),

  /// < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  AV_PIX_FMT_YUV420P16LE(45),

  /// < planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  AV_PIX_FMT_YUV420P16BE(46),

  /// < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  AV_PIX_FMT_YUV422P16LE(47),

  /// < planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  AV_PIX_FMT_YUV422P16BE(48),

  /// < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  AV_PIX_FMT_YUV444P16LE(49),

  /// < planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  AV_PIX_FMT_YUV444P16BE(50),

  /// < HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
  AV_PIX_FMT_DXVA2_VLD(51),

  /// < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined
  AV_PIX_FMT_RGB444LE(52),

  /// < packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined
  AV_PIX_FMT_RGB444BE(53),

  /// < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined
  AV_PIX_FMT_BGR444LE(54),

  /// < packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined
  AV_PIX_FMT_BGR444BE(55),

  /// < 8 bits gray, 8 bits alpha
  AV_PIX_FMT_YA8(56),

  /// < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian
  AV_PIX_FMT_BGR48BE(57),

  /// < packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian
  AV_PIX_FMT_BGR48LE(58),

  /// < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  AV_PIX_FMT_YUV420P9BE(59),

  /// < planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  AV_PIX_FMT_YUV420P9LE(60),

  /// < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  AV_PIX_FMT_YUV420P10BE(61),

  /// < planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  AV_PIX_FMT_YUV420P10LE(62),

  /// < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  AV_PIX_FMT_YUV422P10BE(63),

  /// < planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  AV_PIX_FMT_YUV422P10LE(64),

  /// < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  AV_PIX_FMT_YUV444P9BE(65),

  /// < planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  AV_PIX_FMT_YUV444P9LE(66),

  /// < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  AV_PIX_FMT_YUV444P10BE(67),

  /// < planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  AV_PIX_FMT_YUV444P10LE(68),

  /// < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  AV_PIX_FMT_YUV422P9BE(69),

  /// < planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  AV_PIX_FMT_YUV422P9LE(70),

  /// < planar GBR 4:4:4 24bpp
  AV_PIX_FMT_GBRP(71),

  /// < planar GBR 4:4:4 27bpp, big-endian
  AV_PIX_FMT_GBRP9BE(72),

  /// < planar GBR 4:4:4 27bpp, little-endian
  AV_PIX_FMT_GBRP9LE(73),

  /// < planar GBR 4:4:4 30bpp, big-endian
  AV_PIX_FMT_GBRP10BE(74),

  /// < planar GBR 4:4:4 30bpp, little-endian
  AV_PIX_FMT_GBRP10LE(75),

  /// < planar GBR 4:4:4 48bpp, big-endian
  AV_PIX_FMT_GBRP16BE(76),

  /// < planar GBR 4:4:4 48bpp, little-endian
  AV_PIX_FMT_GBRP16LE(77),

  /// < planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
  AV_PIX_FMT_YUVA422P(78),

  /// < planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
  AV_PIX_FMT_YUVA444P(79),

  /// < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian
  AV_PIX_FMT_YUVA420P9BE(80),

  /// < planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian
  AV_PIX_FMT_YUVA420P9LE(81),

  /// < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian
  AV_PIX_FMT_YUVA422P9BE(82),

  /// < planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian
  AV_PIX_FMT_YUVA422P9LE(83),

  /// < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
  AV_PIX_FMT_YUVA444P9BE(84),

  /// < planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
  AV_PIX_FMT_YUVA444P9LE(85),

  /// < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
  AV_PIX_FMT_YUVA420P10BE(86),

  /// < planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
  AV_PIX_FMT_YUVA420P10LE(87),

  /// < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
  AV_PIX_FMT_YUVA422P10BE(88),

  /// < planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
  AV_PIX_FMT_YUVA422P10LE(89),

  /// < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
  AV_PIX_FMT_YUVA444P10BE(90),

  /// < planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
  AV_PIX_FMT_YUVA444P10LE(91),

  /// < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
  AV_PIX_FMT_YUVA420P16BE(92),

  /// < planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
  AV_PIX_FMT_YUVA420P16LE(93),

  /// < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
  AV_PIX_FMT_YUVA422P16BE(94),

  /// < planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
  AV_PIX_FMT_YUVA422P16LE(95),

  /// < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
  AV_PIX_FMT_YUVA444P16BE(96),

  /// < planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
  AV_PIX_FMT_YUVA444P16LE(97),

  /// < HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface
  AV_PIX_FMT_VDPAU(98),

  /// < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0
  AV_PIX_FMT_XYZ12LE(99),

  /// < packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0
  AV_PIX_FMT_XYZ12BE(100),

  /// < interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
  AV_PIX_FMT_NV16(101),

  /// < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  AV_PIX_FMT_NV20LE(102),

  /// < interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  AV_PIX_FMT_NV20BE(103),

  /// < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
  AV_PIX_FMT_RGBA64BE(104),

  /// < packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
  AV_PIX_FMT_RGBA64LE(105),

  /// < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
  AV_PIX_FMT_BGRA64BE(106),

  /// < packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
  AV_PIX_FMT_BGRA64LE(107),

  /// < packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb
  AV_PIX_FMT_YVYU422(108),

  /// < 16 bits gray, 16 bits alpha (big-endian)
  AV_PIX_FMT_YA16BE(109),

  /// < 16 bits gray, 16 bits alpha (little-endian)
  AV_PIX_FMT_YA16LE(110),

  /// < planar GBRA 4:4:4:4 32bpp
  AV_PIX_FMT_GBRAP(111),

  /// < planar GBRA 4:4:4:4 64bpp, big-endian
  AV_PIX_FMT_GBRAP16BE(112),

  /// < planar GBRA 4:4:4:4 64bpp, little-endian
  AV_PIX_FMT_GBRAP16LE(113),

  /// HW acceleration through QSV, data[3] contains a pointer to the
  /// mfxFrameSurface1 structure.
  ///
  /// Before FFmpeg 5.0:
  /// mfxFrameSurface1.Data.MemId contains a pointer when importing
  /// the following frames as QSV frames:
  ///
  /// VAAPI:
  /// mfxFrameSurface1.Data.MemId contains a pointer to VASurfaceID
  ///
  /// DXVA2:
  /// mfxFrameSurface1.Data.MemId contains a pointer to IDirect3DSurface9
  ///
  /// FFmpeg 5.0 and above:
  /// mfxFrameSurface1.Data.MemId contains a pointer to the mfxHDLPair
  /// structure when importing the following frames as QSV frames:
  ///
  /// VAAPI:
  /// mfxHDLPair.first contains a VASurfaceID pointer.
  /// mfxHDLPair.second is always MFX_INFINITE.
  ///
  /// DXVA2:
  /// mfxHDLPair.first contains IDirect3DSurface9 pointer.
  /// mfxHDLPair.second is always MFX_INFINITE.
  ///
  /// D3D11:
  /// mfxHDLPair.first contains a ID3D11Texture2D pointer.
  /// mfxHDLPair.second contains the texture array index of the frame if the
  /// ID3D11Texture2D is an array texture, or always MFX_INFINITE if it is a
  /// normal texture.
  AV_PIX_FMT_QSV(114),

  /// HW acceleration though MMAL, data[3] contains a pointer to the
  /// MMAL_BUFFER_HEADER_T structure.
  AV_PIX_FMT_MMAL(115),

  /// < HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer
  AV_PIX_FMT_D3D11VA_VLD(116),

  /// HW acceleration through CUDA. data[i] contain CUdeviceptr pointers
  /// exactly as for system memory frames.
  AV_PIX_FMT_CUDA(117),

  /// < packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined
  AV_PIX_FMT_0RGB(118),

  /// < packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined
  AV_PIX_FMT_RGB0(119),

  /// < packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined
  AV_PIX_FMT_0BGR(120),

  /// < packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined
  AV_PIX_FMT_BGR0(121),

  /// < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  AV_PIX_FMT_YUV420P12BE(122),

  /// < planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  AV_PIX_FMT_YUV420P12LE(123),

  /// < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  AV_PIX_FMT_YUV420P14BE(124),

  /// < planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  AV_PIX_FMT_YUV420P14LE(125),

  /// < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  AV_PIX_FMT_YUV422P12BE(126),

  /// < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  AV_PIX_FMT_YUV422P12LE(127),

  /// < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  AV_PIX_FMT_YUV422P14BE(128),

  /// < planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  AV_PIX_FMT_YUV422P14LE(129),

  /// < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  AV_PIX_FMT_YUV444P12BE(130),

  /// < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  AV_PIX_FMT_YUV444P12LE(131),

  /// < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  AV_PIX_FMT_YUV444P14BE(132),

  /// < planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  AV_PIX_FMT_YUV444P14LE(133),

  /// < planar GBR 4:4:4 36bpp, big-endian
  AV_PIX_FMT_GBRP12BE(134),

  /// < planar GBR 4:4:4 36bpp, little-endian
  AV_PIX_FMT_GBRP12LE(135),

  /// < planar GBR 4:4:4 42bpp, big-endian
  AV_PIX_FMT_GBRP14BE(136),

  /// < planar GBR 4:4:4 42bpp, little-endian
  AV_PIX_FMT_GBRP14LE(137),

  /// < planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range
  AV_PIX_FMT_YUVJ411P(138),

  /// < bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples
  AV_PIX_FMT_BAYER_BGGR8(139),

  /// < bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples
  AV_PIX_FMT_BAYER_RGGB8(140),

  /// < bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples
  AV_PIX_FMT_BAYER_GBRG8(141),

  /// < bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples
  AV_PIX_FMT_BAYER_GRBG8(142),

  /// < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian
  AV_PIX_FMT_BAYER_BGGR16LE(143),

  /// < bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian
  AV_PIX_FMT_BAYER_BGGR16BE(144),

  /// < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian
  AV_PIX_FMT_BAYER_RGGB16LE(145),

  /// < bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian
  AV_PIX_FMT_BAYER_RGGB16BE(146),

  /// < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian
  AV_PIX_FMT_BAYER_GBRG16LE(147),

  /// < bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian
  AV_PIX_FMT_BAYER_GBRG16BE(148),

  /// < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian
  AV_PIX_FMT_BAYER_GRBG16LE(149),

  /// < bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian
  AV_PIX_FMT_BAYER_GRBG16BE(150),

  /// < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
  AV_PIX_FMT_YUV440P10LE(151),

  /// < planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
  AV_PIX_FMT_YUV440P10BE(152),

  /// < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
  AV_PIX_FMT_YUV440P12LE(153),

  /// < planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
  AV_PIX_FMT_YUV440P12BE(154),

  /// < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
  AV_PIX_FMT_AYUV64LE(155),

  /// < packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
  AV_PIX_FMT_AYUV64BE(156),

  /// < hardware decoding through Videotoolbox
  AV_PIX_FMT_VIDEOTOOLBOX(157),

  /// < like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian
  AV_PIX_FMT_P010LE(158),

  /// < like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian
  AV_PIX_FMT_P010BE(159),

  /// < planar GBR 4:4:4:4 48bpp, big-endian
  AV_PIX_FMT_GBRAP12BE(160),

  /// < planar GBR 4:4:4:4 48bpp, little-endian
  AV_PIX_FMT_GBRAP12LE(161),

  /// < planar GBR 4:4:4:4 40bpp, big-endian
  AV_PIX_FMT_GBRAP10BE(162),

  /// < planar GBR 4:4:4:4 40bpp, little-endian
  AV_PIX_FMT_GBRAP10LE(163),

  /// < hardware decoding through MediaCodec
  AV_PIX_FMT_MEDIACODEC(164),

  /// <        Y        , 12bpp, big-endian
  AV_PIX_FMT_GRAY12BE(165),

  /// <        Y        , 12bpp, little-endian
  AV_PIX_FMT_GRAY12LE(166),

  /// <        Y        , 10bpp, big-endian
  AV_PIX_FMT_GRAY10BE(167),

  /// <        Y        , 10bpp, little-endian
  AV_PIX_FMT_GRAY10LE(168),

  /// < like NV12, with 16bpp per component, little-endian
  AV_PIX_FMT_P016LE(169),

  /// < like NV12, with 16bpp per component, big-endian
  AV_PIX_FMT_P016BE(170),

  /// Hardware surfaces for Direct3D11.
  ///
  /// This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11
  /// hwaccel API and filtering support AV_PIX_FMT_D3D11 only.
  ///
  /// data[0] contains a ID3D11Texture2D pointer, and data[1] contains the
  /// texture array index of the frame as intptr_t if the ID3D11Texture2D is
  /// an array texture (or always 0 if it's a normal texture).
  AV_PIX_FMT_D3D11(171),

  /// <        Y        , 9bpp, big-endian
  AV_PIX_FMT_GRAY9BE(172),

  /// <        Y        , 9bpp, little-endian
  AV_PIX_FMT_GRAY9LE(173),

  /// < IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian
  AV_PIX_FMT_GBRPF32BE(174),

  /// < IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian
  AV_PIX_FMT_GBRPF32LE(175),

  /// < IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian
  AV_PIX_FMT_GBRAPF32BE(176),

  /// < IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian
  AV_PIX_FMT_GBRAPF32LE(177),

  /// DRM-managed buffers exposed through PRIME buffer sharing.
  ///
  /// data[0] points to an AVDRMFrameDescriptor.
  AV_PIX_FMT_DRM_PRIME(178),

  /// Hardware surfaces for OpenCL.
  ///
  /// data[i] contain 2D image objects (typed in C as cl_mem, used
  /// in OpenCL as image2d_t) for each plane of the surface.
  AV_PIX_FMT_OPENCL(179),

  /// <        Y        , 14bpp, big-endian
  AV_PIX_FMT_GRAY14BE(180),

  /// <        Y        , 14bpp, little-endian
  AV_PIX_FMT_GRAY14LE(181),

  /// < IEEE-754 single precision Y, 32bpp, big-endian
  AV_PIX_FMT_GRAYF32BE(182),

  /// < IEEE-754 single precision Y, 32bpp, little-endian
  AV_PIX_FMT_GRAYF32LE(183),

  /// < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian
  AV_PIX_FMT_YUVA422P12BE(184),

  /// < planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian
  AV_PIX_FMT_YUVA422P12LE(185),

  /// < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian
  AV_PIX_FMT_YUVA444P12BE(186),

  /// < planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian
  AV_PIX_FMT_YUVA444P12LE(187),

  /// < planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
  AV_PIX_FMT_NV24(188),

  /// < as above, but U and V bytes are swapped
  AV_PIX_FMT_NV42(189),

  /// Vulkan hardware images.
  ///
  /// data[0] points to an AVVkFrame
  AV_PIX_FMT_VULKAN(190),

  /// < packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian
  AV_PIX_FMT_Y210BE(191),

  /// < packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian
  AV_PIX_FMT_Y210LE(192),

  /// < packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined
  AV_PIX_FMT_X2RGB10LE(193),

  /// < packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined
  AV_PIX_FMT_X2RGB10BE(194),

  /// < packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), little-endian, X=unused/undefined
  AV_PIX_FMT_X2BGR10LE(195),

  /// < packed BGR 10:10:10, 30bpp, (msb)2X 10B 10G 10R(lsb), big-endian, X=unused/undefined
  AV_PIX_FMT_X2BGR10BE(196),

  /// < interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, big-endian
  AV_PIX_FMT_P210BE(197),

  /// < interleaved chroma YUV 4:2:2, 20bpp, data in the high bits, little-endian
  AV_PIX_FMT_P210LE(198),

  /// < interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, big-endian
  AV_PIX_FMT_P410BE(199),

  /// < interleaved chroma YUV 4:4:4, 30bpp, data in the high bits, little-endian
  AV_PIX_FMT_P410LE(200),

  /// < interleaved chroma YUV 4:2:2, 32bpp, big-endian
  AV_PIX_FMT_P216BE(201),

  /// < interleaved chroma YUV 4:2:2, 32bpp, little-endian
  AV_PIX_FMT_P216LE(202),

  /// < interleaved chroma YUV 4:4:4, 48bpp, big-endian
  AV_PIX_FMT_P416BE(203),

  /// < interleaved chroma YUV 4:4:4, 48bpp, little-endian
  AV_PIX_FMT_P416LE(204),

  /// < packed VUYA 4:4:4, 32bpp, VUYAVUYA...
  AV_PIX_FMT_VUYA(205),

  /// < IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., big-endian
  AV_PIX_FMT_RGBAF16BE(206),

  /// < IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., little-endian
  AV_PIX_FMT_RGBAF16LE(207),

  /// < packed VUYX 4:4:4, 32bpp, Variant of VUYA where alpha channel is left undefined
  AV_PIX_FMT_VUYX(208),

  /// < like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, little-endian
  AV_PIX_FMT_P012LE(209),

  /// < like NV12, with 12bpp per component, data in the high bits, zeros in the low bits, big-endian
  AV_PIX_FMT_P012BE(210),

  /// < packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, big-endian
  AV_PIX_FMT_Y212BE(211),

  /// < packed YUV 4:2:2 like YUYV422, 24bpp, data in the high bits, zeros in the low bits, little-endian
  AV_PIX_FMT_Y212LE(212),

  /// < packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), big-endian, variant of Y410 where alpha channel is left undefined
  AV_PIX_FMT_XV30BE(213),

  /// < packed XVYU 4:4:4, 32bpp, (msb)2X 10V 10Y 10U(lsb), little-endian, variant of Y410 where alpha channel is left undefined
  AV_PIX_FMT_XV30LE(214),

  /// < packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, big-endian, variant of Y412 where alpha channel is left undefined
  AV_PIX_FMT_XV36BE(215),

  /// < packed XVYU 4:4:4, 48bpp, data in the high bits, zeros in the low bits, little-endian, variant of Y412 where alpha channel is left undefined
  AV_PIX_FMT_XV36LE(216),

  /// < IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., big-endian
  AV_PIX_FMT_RGBF32BE(217),

  /// < IEEE-754 single precision packed RGB 32:32:32, 96bpp, RGBRGB..., little-endian
  AV_PIX_FMT_RGBF32LE(218),

  /// < IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., big-endian
  AV_PIX_FMT_RGBAF32BE(219),

  /// < IEEE-754 single precision packed RGBA 32:32:32:32, 128bpp, RGBARGBA..., little-endian
  AV_PIX_FMT_RGBAF32LE(220),

  /// < interleaved chroma YUV 4:2:2, 24bpp, data in the high bits, big-endian
  AV_PIX_FMT_P212BE(221),

  /// < interleaved chroma YUV 4:2:2, 24bpp, data in the high bits, little-endian
  AV_PIX_FMT_P212LE(222),

  /// < interleaved chroma YUV 4:4:4, 36bpp, data in the high bits, big-endian
  AV_PIX_FMT_P412BE(223),

  /// < interleaved chroma YUV 4:4:4, 36bpp, data in the high bits, little-endian
  AV_PIX_FMT_P412LE(224),

  /// < planar GBR 4:4:4:4 56bpp, big-endian
  AV_PIX_FMT_GBRAP14BE(225),

  /// < planar GBR 4:4:4:4 56bpp, little-endian
  AV_PIX_FMT_GBRAP14LE(226),

  /// Hardware surfaces for Direct3D 12.
  ///
  /// data[0] points to an AVD3D12VAFrame
  AV_PIX_FMT_D3D12(227),

  /// < number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
  AV_PIX_FMT_NB(228);

  /// < alias for AV_PIX_FMT_YA8
  static const AV_PIX_FMT_Y400A = AV_PIX_FMT_YA8;

  /// < alias for AV_PIX_FMT_YA8
  static const AV_PIX_FMT_GRAY8A = AV_PIX_FMT_YA8;
  static const AV_PIX_FMT_GBR24P = AV_PIX_FMT_GBRP;

  final int value;
  const AVPixelFormat(this.value);

  static AVPixelFormat fromValue(int value) => switch (value) {
        -1 => AV_PIX_FMT_NONE,
        0 => AV_PIX_FMT_YUV420P,
        1 => AV_PIX_FMT_YUYV422,
        2 => AV_PIX_FMT_RGB24,
        3 => AV_PIX_FMT_BGR24,
        4 => AV_PIX_FMT_YUV422P,
        5 => AV_PIX_FMT_YUV444P,
        6 => AV_PIX_FMT_YUV410P,
        7 => AV_PIX_FMT_YUV411P,
        8 => AV_PIX_FMT_GRAY8,
        9 => AV_PIX_FMT_MONOWHITE,
        10 => AV_PIX_FMT_MONOBLACK,
        11 => AV_PIX_FMT_PAL8,
        12 => AV_PIX_FMT_YUVJ420P,
        13 => AV_PIX_FMT_YUVJ422P,
        14 => AV_PIX_FMT_YUVJ444P,
        15 => AV_PIX_FMT_UYVY422,
        16 => AV_PIX_FMT_UYYVYY411,
        17 => AV_PIX_FMT_BGR8,
        18 => AV_PIX_FMT_BGR4,
        19 => AV_PIX_FMT_BGR4_BYTE,
        20 => AV_PIX_FMT_RGB8,
        21 => AV_PIX_FMT_RGB4,
        22 => AV_PIX_FMT_RGB4_BYTE,
        23 => AV_PIX_FMT_NV12,
        24 => AV_PIX_FMT_NV21,
        25 => AV_PIX_FMT_ARGB,
        26 => AV_PIX_FMT_RGBA,
        27 => AV_PIX_FMT_ABGR,
        28 => AV_PIX_FMT_BGRA,
        29 => AV_PIX_FMT_GRAY16BE,
        30 => AV_PIX_FMT_GRAY16LE,
        31 => AV_PIX_FMT_YUV440P,
        32 => AV_PIX_FMT_YUVJ440P,
        33 => AV_PIX_FMT_YUVA420P,
        34 => AV_PIX_FMT_RGB48BE,
        35 => AV_PIX_FMT_RGB48LE,
        36 => AV_PIX_FMT_RGB565BE,
        37 => AV_PIX_FMT_RGB565LE,
        38 => AV_PIX_FMT_RGB555BE,
        39 => AV_PIX_FMT_RGB555LE,
        40 => AV_PIX_FMT_BGR565BE,
        41 => AV_PIX_FMT_BGR565LE,
        42 => AV_PIX_FMT_BGR555BE,
        43 => AV_PIX_FMT_BGR555LE,
        44 => AV_PIX_FMT_VAAPI,
        45 => AV_PIX_FMT_YUV420P16LE,
        46 => AV_PIX_FMT_YUV420P16BE,
        47 => AV_PIX_FMT_YUV422P16LE,
        48 => AV_PIX_FMT_YUV422P16BE,
        49 => AV_PIX_FMT_YUV444P16LE,
        50 => AV_PIX_FMT_YUV444P16BE,
        51 => AV_PIX_FMT_DXVA2_VLD,
        52 => AV_PIX_FMT_RGB444LE,
        53 => AV_PIX_FMT_RGB444BE,
        54 => AV_PIX_FMT_BGR444LE,
        55 => AV_PIX_FMT_BGR444BE,
        56 => AV_PIX_FMT_YA8,
        57 => AV_PIX_FMT_BGR48BE,
        58 => AV_PIX_FMT_BGR48LE,
        59 => AV_PIX_FMT_YUV420P9BE,
        60 => AV_PIX_FMT_YUV420P9LE,
        61 => AV_PIX_FMT_YUV420P10BE,
        62 => AV_PIX_FMT_YUV420P10LE,
        63 => AV_PIX_FMT_YUV422P10BE,
        64 => AV_PIX_FMT_YUV422P10LE,
        65 => AV_PIX_FMT_YUV444P9BE,
        66 => AV_PIX_FMT_YUV444P9LE,
        67 => AV_PIX_FMT_YUV444P10BE,
        68 => AV_PIX_FMT_YUV444P10LE,
        69 => AV_PIX_FMT_YUV422P9BE,
        70 => AV_PIX_FMT_YUV422P9LE,
        71 => AV_PIX_FMT_GBRP,
        72 => AV_PIX_FMT_GBRP9BE,
        73 => AV_PIX_FMT_GBRP9LE,
        74 => AV_PIX_FMT_GBRP10BE,
        75 => AV_PIX_FMT_GBRP10LE,
        76 => AV_PIX_FMT_GBRP16BE,
        77 => AV_PIX_FMT_GBRP16LE,
        78 => AV_PIX_FMT_YUVA422P,
        79 => AV_PIX_FMT_YUVA444P,
        80 => AV_PIX_FMT_YUVA420P9BE,
        81 => AV_PIX_FMT_YUVA420P9LE,
        82 => AV_PIX_FMT_YUVA422P9BE,
        83 => AV_PIX_FMT_YUVA422P9LE,
        84 => AV_PIX_FMT_YUVA444P9BE,
        85 => AV_PIX_FMT_YUVA444P9LE,
        86 => AV_PIX_FMT_YUVA420P10BE,
        87 => AV_PIX_FMT_YUVA420P10LE,
        88 => AV_PIX_FMT_YUVA422P10BE,
        89 => AV_PIX_FMT_YUVA422P10LE,
        90 => AV_PIX_FMT_YUVA444P10BE,
        91 => AV_PIX_FMT_YUVA444P10LE,
        92 => AV_PIX_FMT_YUVA420P16BE,
        93 => AV_PIX_FMT_YUVA420P16LE,
        94 => AV_PIX_FMT_YUVA422P16BE,
        95 => AV_PIX_FMT_YUVA422P16LE,
        96 => AV_PIX_FMT_YUVA444P16BE,
        97 => AV_PIX_FMT_YUVA444P16LE,
        98 => AV_PIX_FMT_VDPAU,
        99 => AV_PIX_FMT_XYZ12LE,
        100 => AV_PIX_FMT_XYZ12BE,
        101 => AV_PIX_FMT_NV16,
        102 => AV_PIX_FMT_NV20LE,
        103 => AV_PIX_FMT_NV20BE,
        104 => AV_PIX_FMT_RGBA64BE,
        105 => AV_PIX_FMT_RGBA64LE,
        106 => AV_PIX_FMT_BGRA64BE,
        107 => AV_PIX_FMT_BGRA64LE,
        108 => AV_PIX_FMT_YVYU422,
        109 => AV_PIX_FMT_YA16BE,
        110 => AV_PIX_FMT_YA16LE,
        111 => AV_PIX_FMT_GBRAP,
        112 => AV_PIX_FMT_GBRAP16BE,
        113 => AV_PIX_FMT_GBRAP16LE,
        114 => AV_PIX_FMT_QSV,
        115 => AV_PIX_FMT_MMAL,
        116 => AV_PIX_FMT_D3D11VA_VLD,
        117 => AV_PIX_FMT_CUDA,
        118 => AV_PIX_FMT_0RGB,
        119 => AV_PIX_FMT_RGB0,
        120 => AV_PIX_FMT_0BGR,
        121 => AV_PIX_FMT_BGR0,
        122 => AV_PIX_FMT_YUV420P12BE,
        123 => AV_PIX_FMT_YUV420P12LE,
        124 => AV_PIX_FMT_YUV420P14BE,
        125 => AV_PIX_FMT_YUV420P14LE,
        126 => AV_PIX_FMT_YUV422P12BE,
        127 => AV_PIX_FMT_YUV422P12LE,
        128 => AV_PIX_FMT_YUV422P14BE,
        129 => AV_PIX_FMT_YUV422P14LE,
        130 => AV_PIX_FMT_YUV444P12BE,
        131 => AV_PIX_FMT_YUV444P12LE,
        132 => AV_PIX_FMT_YUV444P14BE,
        133 => AV_PIX_FMT_YUV444P14LE,
        134 => AV_PIX_FMT_GBRP12BE,
        135 => AV_PIX_FMT_GBRP12LE,
        136 => AV_PIX_FMT_GBRP14BE,
        137 => AV_PIX_FMT_GBRP14LE,
        138 => AV_PIX_FMT_YUVJ411P,
        139 => AV_PIX_FMT_BAYER_BGGR8,
        140 => AV_PIX_FMT_BAYER_RGGB8,
        141 => AV_PIX_FMT_BAYER_GBRG8,
        142 => AV_PIX_FMT_BAYER_GRBG8,
        143 => AV_PIX_FMT_BAYER_BGGR16LE,
        144 => AV_PIX_FMT_BAYER_BGGR16BE,
        145 => AV_PIX_FMT_BAYER_RGGB16LE,
        146 => AV_PIX_FMT_BAYER_RGGB16BE,
        147 => AV_PIX_FMT_BAYER_GBRG16LE,
        148 => AV_PIX_FMT_BAYER_GBRG16BE,
        149 => AV_PIX_FMT_BAYER_GRBG16LE,
        150 => AV_PIX_FMT_BAYER_GRBG16BE,
        151 => AV_PIX_FMT_YUV440P10LE,
        152 => AV_PIX_FMT_YUV440P10BE,
        153 => AV_PIX_FMT_YUV440P12LE,
        154 => AV_PIX_FMT_YUV440P12BE,
        155 => AV_PIX_FMT_AYUV64LE,
        156 => AV_PIX_FMT_AYUV64BE,
        157 => AV_PIX_FMT_VIDEOTOOLBOX,
        158 => AV_PIX_FMT_P010LE,
        159 => AV_PIX_FMT_P010BE,
        160 => AV_PIX_FMT_GBRAP12BE,
        161 => AV_PIX_FMT_GBRAP12LE,
        162 => AV_PIX_FMT_GBRAP10BE,
        163 => AV_PIX_FMT_GBRAP10LE,
        164 => AV_PIX_FMT_MEDIACODEC,
        165 => AV_PIX_FMT_GRAY12BE,
        166 => AV_PIX_FMT_GRAY12LE,
        167 => AV_PIX_FMT_GRAY10BE,
        168 => AV_PIX_FMT_GRAY10LE,
        169 => AV_PIX_FMT_P016LE,
        170 => AV_PIX_FMT_P016BE,
        171 => AV_PIX_FMT_D3D11,
        172 => AV_PIX_FMT_GRAY9BE,
        173 => AV_PIX_FMT_GRAY9LE,
        174 => AV_PIX_FMT_GBRPF32BE,
        175 => AV_PIX_FMT_GBRPF32LE,
        176 => AV_PIX_FMT_GBRAPF32BE,
        177 => AV_PIX_FMT_GBRAPF32LE,
        178 => AV_PIX_FMT_DRM_PRIME,
        179 => AV_PIX_FMT_OPENCL,
        180 => AV_PIX_FMT_GRAY14BE,
        181 => AV_PIX_FMT_GRAY14LE,
        182 => AV_PIX_FMT_GRAYF32BE,
        183 => AV_PIX_FMT_GRAYF32LE,
        184 => AV_PIX_FMT_YUVA422P12BE,
        185 => AV_PIX_FMT_YUVA422P12LE,
        186 => AV_PIX_FMT_YUVA444P12BE,
        187 => AV_PIX_FMT_YUVA444P12LE,
        188 => AV_PIX_FMT_NV24,
        189 => AV_PIX_FMT_NV42,
        190 => AV_PIX_FMT_VULKAN,
        191 => AV_PIX_FMT_Y210BE,
        192 => AV_PIX_FMT_Y210LE,
        193 => AV_PIX_FMT_X2RGB10LE,
        194 => AV_PIX_FMT_X2RGB10BE,
        195 => AV_PIX_FMT_X2BGR10LE,
        196 => AV_PIX_FMT_X2BGR10BE,
        197 => AV_PIX_FMT_P210BE,
        198 => AV_PIX_FMT_P210LE,
        199 => AV_PIX_FMT_P410BE,
        200 => AV_PIX_FMT_P410LE,
        201 => AV_PIX_FMT_P216BE,
        202 => AV_PIX_FMT_P216LE,
        203 => AV_PIX_FMT_P416BE,
        204 => AV_PIX_FMT_P416LE,
        205 => AV_PIX_FMT_VUYA,
        206 => AV_PIX_FMT_RGBAF16BE,
        207 => AV_PIX_FMT_RGBAF16LE,
        208 => AV_PIX_FMT_VUYX,
        209 => AV_PIX_FMT_P012LE,
        210 => AV_PIX_FMT_P012BE,
        211 => AV_PIX_FMT_Y212BE,
        212 => AV_PIX_FMT_Y212LE,
        213 => AV_PIX_FMT_XV30BE,
        214 => AV_PIX_FMT_XV30LE,
        215 => AV_PIX_FMT_XV36BE,
        216 => AV_PIX_FMT_XV36LE,
        217 => AV_PIX_FMT_RGBF32BE,
        218 => AV_PIX_FMT_RGBF32LE,
        219 => AV_PIX_FMT_RGBAF32BE,
        220 => AV_PIX_FMT_RGBAF32LE,
        221 => AV_PIX_FMT_P212BE,
        222 => AV_PIX_FMT_P212LE,
        223 => AV_PIX_FMT_P412BE,
        224 => AV_PIX_FMT_P412LE,
        225 => AV_PIX_FMT_GBRAP14BE,
        226 => AV_PIX_FMT_GBRAP14LE,
        227 => AV_PIX_FMT_D3D12,
        228 => AV_PIX_FMT_NB,
        _ => throw ArgumentError("Unknown value for AVPixelFormat: $value"),
      };

  @override
  String toString() {
    if (this == AV_PIX_FMT_YA8)
      return "AVPixelFormat.AV_PIX_FMT_YA8, AVPixelFormat.AV_PIX_FMT_Y400A, AVPixelFormat.AV_PIX_FMT_GRAY8A";
    if (this == AV_PIX_FMT_GBRP)
      return "AVPixelFormat.AV_PIX_FMT_GBRP, AVPixelFormat.AV_PIX_FMT_GBR24P";
    return super.toString();
  }
}

/// Chromaticity coordinates of the source primaries.
/// These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273.
enum AVColorPrimaries {
  AVCOL_PRI_RESERVED0(0),

  /// < also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B
  AVCOL_PRI_BT709(1),
  AVCOL_PRI_UNSPECIFIED(2),
  AVCOL_PRI_RESERVED(3),

  /// < also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
  AVCOL_PRI_BT470M(4),

  /// < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
  AVCOL_PRI_BT470BG(5),

  /// < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
  AVCOL_PRI_SMPTE170M(6),

  /// < identical to above, also called "SMPTE C" even though it uses D65
  AVCOL_PRI_SMPTE240M(7),

  /// < colour filters using Illuminant C
  AVCOL_PRI_FILM(8),

  /// < ITU-R BT2020
  AVCOL_PRI_BT2020(9),

  /// < SMPTE ST 428-1 (CIE 1931 XYZ)
  AVCOL_PRI_SMPTE428(10),

  /// < SMPTE ST 431-2 (2011) / DCI P3
  AVCOL_PRI_SMPTE431(11),

  /// < SMPTE ST 432-1 (2010) / P3 D65 / Display P3
  AVCOL_PRI_SMPTE432(12),

  /// < EBU Tech. 3213-E (nothing there) / one of JEDEC P22 group phosphors
  AVCOL_PRI_EBU3213(22),

  /// < Not part of ABI
  AVCOL_PRI_NB(23);

  static const AVCOL_PRI_SMPTEST428_1 = AVCOL_PRI_SMPTE428;
  static const AVCOL_PRI_JEDEC_P22 = AVCOL_PRI_EBU3213;

  final int value;
  const AVColorPrimaries(this.value);

  static AVColorPrimaries fromValue(int value) => switch (value) {
        0 => AVCOL_PRI_RESERVED0,
        1 => AVCOL_PRI_BT709,
        2 => AVCOL_PRI_UNSPECIFIED,
        3 => AVCOL_PRI_RESERVED,
        4 => AVCOL_PRI_BT470M,
        5 => AVCOL_PRI_BT470BG,
        6 => AVCOL_PRI_SMPTE170M,
        7 => AVCOL_PRI_SMPTE240M,
        8 => AVCOL_PRI_FILM,
        9 => AVCOL_PRI_BT2020,
        10 => AVCOL_PRI_SMPTE428,
        11 => AVCOL_PRI_SMPTE431,
        12 => AVCOL_PRI_SMPTE432,
        22 => AVCOL_PRI_EBU3213,
        23 => AVCOL_PRI_NB,
        _ => throw ArgumentError("Unknown value for AVColorPrimaries: $value"),
      };

  @override
  String toString() {
    if (this == AVCOL_PRI_SMPTE428)
      return "AVColorPrimaries.AVCOL_PRI_SMPTE428, AVColorPrimaries.AVCOL_PRI_SMPTEST428_1";
    if (this == AVCOL_PRI_EBU3213)
      return "AVColorPrimaries.AVCOL_PRI_EBU3213, AVColorPrimaries.AVCOL_PRI_JEDEC_P22";
    return super.toString();
  }
}

/// Color Transfer Characteristic.
/// These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2.
enum AVColorTransferCharacteristic {
  AVCOL_TRC_RESERVED0(0),

  /// < also ITU-R BT1361
  AVCOL_TRC_BT709(1),
  AVCOL_TRC_UNSPECIFIED(2),
  AVCOL_TRC_RESERVED(3),

  /// < also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
  AVCOL_TRC_GAMMA22(4),

  /// < also ITU-R BT470BG
  AVCOL_TRC_GAMMA28(5),

  /// < also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC
  AVCOL_TRC_SMPTE170M(6),
  AVCOL_TRC_SMPTE240M(7),

  /// < "Linear transfer characteristics"
  AVCOL_TRC_LINEAR(8),

  /// < "Logarithmic transfer characteristic (100:1 range)"
  AVCOL_TRC_LOG(9),

  /// < "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"
  AVCOL_TRC_LOG_SQRT(10),

  /// < IEC 61966-2-4
  AVCOL_TRC_IEC61966_2_4(11),

  /// < ITU-R BT1361 Extended Colour Gamut
  AVCOL_TRC_BT1361_ECG(12),

  /// < IEC 61966-2-1 (sRGB or sYCC)
  AVCOL_TRC_IEC61966_2_1(13),

  /// < ITU-R BT2020 for 10-bit system
  AVCOL_TRC_BT2020_10(14),

  /// < ITU-R BT2020 for 12-bit system
  AVCOL_TRC_BT2020_12(15),

  /// < SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems
  AVCOL_TRC_SMPTE2084(16),

  /// < SMPTE ST 428-1
  AVCOL_TRC_SMPTE428(17),

  /// < ARIB STD-B67, known as "Hybrid log-gamma"
  AVCOL_TRC_ARIB_STD_B67(18),

  /// < Not part of ABI
  AVCOL_TRC_NB(19);

  static const AVCOL_TRC_SMPTEST2084 = AVCOL_TRC_SMPTE2084;
  static const AVCOL_TRC_SMPTEST428_1 = AVCOL_TRC_SMPTE428;

  final int value;
  const AVColorTransferCharacteristic(this.value);

  static AVColorTransferCharacteristic fromValue(int value) => switch (value) {
        0 => AVCOL_TRC_RESERVED0,
        1 => AVCOL_TRC_BT709,
        2 => AVCOL_TRC_UNSPECIFIED,
        3 => AVCOL_TRC_RESERVED,
        4 => AVCOL_TRC_GAMMA22,
        5 => AVCOL_TRC_GAMMA28,
        6 => AVCOL_TRC_SMPTE170M,
        7 => AVCOL_TRC_SMPTE240M,
        8 => AVCOL_TRC_LINEAR,
        9 => AVCOL_TRC_LOG,
        10 => AVCOL_TRC_LOG_SQRT,
        11 => AVCOL_TRC_IEC61966_2_4,
        12 => AVCOL_TRC_BT1361_ECG,
        13 => AVCOL_TRC_IEC61966_2_1,
        14 => AVCOL_TRC_BT2020_10,
        15 => AVCOL_TRC_BT2020_12,
        16 => AVCOL_TRC_SMPTE2084,
        17 => AVCOL_TRC_SMPTE428,
        18 => AVCOL_TRC_ARIB_STD_B67,
        19 => AVCOL_TRC_NB,
        _ => throw ArgumentError(
            "Unknown value for AVColorTransferCharacteristic: $value"),
      };

  @override
  String toString() {
    if (this == AVCOL_TRC_SMPTE2084)
      return "AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084, AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST2084";
    if (this == AVCOL_TRC_SMPTE428)
      return "AVColorTransferCharacteristic.AVCOL_TRC_SMPTE428, AVColorTransferCharacteristic.AVCOL_TRC_SMPTEST428_1";
    return super.toString();
  }
}

/// YUV colorspace type.
/// These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3.
enum AVColorSpace {
  /// < order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB), YZX and ST 428-1
  AVCOL_SPC_RGB(0),

  /// < also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / derived in SMPTE RP 177 Annex B
  AVCOL_SPC_BT709(1),
  AVCOL_SPC_UNSPECIFIED(2),

  /// < reserved for future use by ITU-T and ISO/IEC just like 15-255 are
  AVCOL_SPC_RESERVED(3),

  /// < FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
  AVCOL_SPC_FCC(4),

  /// < also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
  AVCOL_SPC_BT470BG(5),

  /// < also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above
  AVCOL_SPC_SMPTE170M(6),

  /// < derived from 170M primaries and D65 white point, 170M is derived from BT470 System M's primaries
  AVCOL_SPC_SMPTE240M(7),

  /// < used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
  AVCOL_SPC_YCGCO(8),

  /// < ITU-R BT2020 non-constant luminance system
  AVCOL_SPC_BT2020_NCL(9),

  /// < ITU-R BT2020 constant luminance system
  AVCOL_SPC_BT2020_CL(10),

  /// < SMPTE 2085, Y'D'zD'x
  AVCOL_SPC_SMPTE2085(11),

  /// < Chromaticity-derived non-constant luminance system
  AVCOL_SPC_CHROMA_DERIVED_NCL(12),

  /// < Chromaticity-derived constant luminance system
  AVCOL_SPC_CHROMA_DERIVED_CL(13),

  /// < ITU-R BT.2100-0, ICtCp
  AVCOL_SPC_ICTCP(14),

  /// < SMPTE ST 2128, IPT-C2
  AVCOL_SPC_IPT_C2(15),

  /// < YCgCo-R, even addition of bits
  AVCOL_SPC_YCGCO_RE(16),

  /// < YCgCo-R, odd addition of bits
  AVCOL_SPC_YCGCO_RO(17),

  /// < Not part of ABI
  AVCOL_SPC_NB(18);

  static const AVCOL_SPC_YCOCG = AVCOL_SPC_YCGCO;

  final int value;
  const AVColorSpace(this.value);

  static AVColorSpace fromValue(int value) => switch (value) {
        0 => AVCOL_SPC_RGB,
        1 => AVCOL_SPC_BT709,
        2 => AVCOL_SPC_UNSPECIFIED,
        3 => AVCOL_SPC_RESERVED,
        4 => AVCOL_SPC_FCC,
        5 => AVCOL_SPC_BT470BG,
        6 => AVCOL_SPC_SMPTE170M,
        7 => AVCOL_SPC_SMPTE240M,
        8 => AVCOL_SPC_YCGCO,
        9 => AVCOL_SPC_BT2020_NCL,
        10 => AVCOL_SPC_BT2020_CL,
        11 => AVCOL_SPC_SMPTE2085,
        12 => AVCOL_SPC_CHROMA_DERIVED_NCL,
        13 => AVCOL_SPC_CHROMA_DERIVED_CL,
        14 => AVCOL_SPC_ICTCP,
        15 => AVCOL_SPC_IPT_C2,
        16 => AVCOL_SPC_YCGCO_RE,
        17 => AVCOL_SPC_YCGCO_RO,
        18 => AVCOL_SPC_NB,
        _ => throw ArgumentError("Unknown value for AVColorSpace: $value"),
      };

  @override
  String toString() {
    if (this == AVCOL_SPC_YCGCO)
      return "AVColorSpace.AVCOL_SPC_YCGCO, AVColorSpace.AVCOL_SPC_YCOCG";
    return super.toString();
  }
}

/// Visual content value range.
///
/// These values are based on definitions that can be found in multiple
/// specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance
/// and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital
/// Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit
/// integer representation). At the time of writing, the BT.2100 one is
/// recommended, as it also defines the full range representation.
///
/// Common definitions:
/// - For RGB and luma planes such as Y in YCbCr and I in ICtCp,
/// 'E' is the original value in range of 0.0 to 1.0.
/// - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original
/// value in range of -0.5 to 0.5.
/// - 'n' is the output bit depth.
/// - For additional definitions such as rounding and clipping to valid n
/// bit unsigned integer range, please refer to BT.2100 (Table 9).
enum AVColorRange {
  AVCOL_RANGE_UNSPECIFIED(0),

  /// Narrow or limited range content.
  ///
  /// - For luma planes:
  ///
  /// (219 * E + 16) * 2^(n-8)
  ///
  /// F.ex. the range of 16-235 for 8 bits
  ///
  /// - For chroma planes:
  ///
  /// (224 * E + 128) * 2^(n-8)
  ///
  /// F.ex. the range of 16-240 for 8 bits
  AVCOL_RANGE_MPEG(1),

  /// Full range content.
  ///
  /// - For RGB and luma planes:
  ///
  /// (2^n - 1) * E
  ///
  /// F.ex. the range of 0-255 for 8 bits
  ///
  /// - For chroma planes:
  ///
  /// (2^n - 1) * E + 2^(n - 1)
  ///
  /// F.ex. the range of 1-255 for 8 bits
  AVCOL_RANGE_JPEG(2),

  /// < Not part of ABI
  AVCOL_RANGE_NB(3);

  final int value;
  const AVColorRange(this.value);

  static AVColorRange fromValue(int value) => switch (value) {
        0 => AVCOL_RANGE_UNSPECIFIED,
        1 => AVCOL_RANGE_MPEG,
        2 => AVCOL_RANGE_JPEG,
        3 => AVCOL_RANGE_NB,
        _ => throw ArgumentError("Unknown value for AVColorRange: $value"),
      };
}

/// Location of chroma samples.
///
/// Illustration showing the location of the first (top left) chroma sample of the
/// image, the left shows only luma, the right
/// shows the location of the chroma sample, the 2 could be imagined to overlay
/// each other but are drawn separately due to limitations of ASCII
///
/// 1st 2nd       1st 2nd horizontal luma sample positions
/// v   v         v   v
/// ______        ______
/// 1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
/// |             |1 2           1-6 are possible chroma positions
/// 2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
enum AVChromaLocation {
  AVCHROMA_LOC_UNSPECIFIED(0),

  /// < MPEG-2/4 4:2:0, H.264 default for 4:2:0
  AVCHROMA_LOC_LEFT(1),

  /// < MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0
  AVCHROMA_LOC_CENTER(2),

  /// < ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2
  AVCHROMA_LOC_TOPLEFT(3),
  AVCHROMA_LOC_TOP(4),
  AVCHROMA_LOC_BOTTOMLEFT(5),
  AVCHROMA_LOC_BOTTOM(6),

  /// < Not part of ABI
  AVCHROMA_LOC_NB(7);

  final int value;
  const AVChromaLocation(this.value);

  static AVChromaLocation fromValue(int value) => switch (value) {
        0 => AVCHROMA_LOC_UNSPECIFIED,
        1 => AVCHROMA_LOC_LEFT,
        2 => AVCHROMA_LOC_CENTER,
        3 => AVCHROMA_LOC_TOPLEFT,
        4 => AVCHROMA_LOC_TOP,
        5 => AVCHROMA_LOC_BOTTOMLEFT,
        6 => AVCHROMA_LOC_BOTTOM,
        7 => AVCHROMA_LOC_NB,
        _ => throw ArgumentError("Unknown value for AVChromaLocation: $value"),
      };
}

final class AVBuffer extends ffi.Opaque {}

/// A reference to a data buffer.
///
/// The size of this struct is not a part of the public ABI and it is not meant
/// to be allocated directly.
final class AVBufferRef extends ffi.Struct {
  external ffi.Pointer<AVBuffer> buffer;

  /// The data buffer. It is considered writable if and only if
  /// this is the only reference to the buffer, in which case
  /// av_buffer_is_writable() returns 1.
  external ffi.Pointer<ffi.Uint8> data;

  /// Size of data in bytes.
  @ffi.Size()
  external int size;
}

final class AVBufferPool extends ffi.Opaque {}

/// @defgroup lavu_audio_channels Audio channels
/// @ingroup lavu_audio
///
/// Audio channel layout utility functions
///
/// @{
enum AVChannel {
  AV_CHAN_NONE(-1),
  AV_CHAN_FRONT_LEFT(0),
  AV_CHAN_FRONT_RIGHT(1),
  AV_CHAN_FRONT_CENTER(2),
  AV_CHAN_LOW_FREQUENCY(3),
  AV_CHAN_BACK_LEFT(4),
  AV_CHAN_BACK_RIGHT(5),
  AV_CHAN_FRONT_LEFT_OF_CENTER(6),
  AV_CHAN_FRONT_RIGHT_OF_CENTER(7),
  AV_CHAN_BACK_CENTER(8),
  AV_CHAN_SIDE_LEFT(9),
  AV_CHAN_SIDE_RIGHT(10),
  AV_CHAN_TOP_CENTER(11),
  AV_CHAN_TOP_FRONT_LEFT(12),
  AV_CHAN_TOP_FRONT_CENTER(13),
  AV_CHAN_TOP_FRONT_RIGHT(14),
  AV_CHAN_TOP_BACK_LEFT(15),
  AV_CHAN_TOP_BACK_CENTER(16),
  AV_CHAN_TOP_BACK_RIGHT(17),

  /// Stereo downmix.
  AV_CHAN_STEREO_LEFT(29),

  /// See above.
  AV_CHAN_STEREO_RIGHT(30),
  AV_CHAN_WIDE_LEFT(31),
  AV_CHAN_WIDE_RIGHT(32),
  AV_CHAN_SURROUND_DIRECT_LEFT(33),
  AV_CHAN_SURROUND_DIRECT_RIGHT(34),
  AV_CHAN_LOW_FREQUENCY_2(35),
  AV_CHAN_TOP_SIDE_LEFT(36),
  AV_CHAN_TOP_SIDE_RIGHT(37),
  AV_CHAN_BOTTOM_FRONT_CENTER(38),
  AV_CHAN_BOTTOM_FRONT_LEFT(39),
  AV_CHAN_BOTTOM_FRONT_RIGHT(40),

  /// <  +90 degrees, Lss, SiL
  AV_CHAN_SIDE_SURROUND_LEFT(41),

  /// <  -90 degrees, Rss, SiR
  AV_CHAN_SIDE_SURROUND_RIGHT(42),

  /// < +110 degrees, Lvs, TpLS
  AV_CHAN_TOP_SURROUND_LEFT(43),

  /// < -110 degrees, Rvs, TpRS
  AV_CHAN_TOP_SURROUND_RIGHT(44),

  /// Channel is empty can be safely skipped.
  AV_CHAN_UNUSED(512),

  /// Channel contains data, but its position is unknown.
  AV_CHAN_UNKNOWN(768),

  /// Range of channels between AV_CHAN_AMBISONIC_BASE and
  /// AV_CHAN_AMBISONIC_END represent Ambisonic components using the ACN system.
  ///
  /// Given a channel id `<i>` between AV_CHAN_AMBISONIC_BASE and
  /// AV_CHAN_AMBISONIC_END (inclusive), the ACN index of the channel `<n>` is
  /// `<n> = <i> - AV_CHAN_AMBISONIC_BASE`.
  ///
  /// @note these values are only used for AV_CHANNEL_ORDER_CUSTOM channel
  /// orderings, the AV_CHANNEL_ORDER_AMBISONIC ordering orders the channels
  /// implicitly by their position in the stream.
  AV_CHAN_AMBISONIC_BASE(1024),
  AV_CHAN_AMBISONIC_END(2047);

  final int value;
  const AVChannel(this.value);

  static AVChannel fromValue(int value) => switch (value) {
        -1 => AV_CHAN_NONE,
        0 => AV_CHAN_FRONT_LEFT,
        1 => AV_CHAN_FRONT_RIGHT,
        2 => AV_CHAN_FRONT_CENTER,
        3 => AV_CHAN_LOW_FREQUENCY,
        4 => AV_CHAN_BACK_LEFT,
        5 => AV_CHAN_BACK_RIGHT,
        6 => AV_CHAN_FRONT_LEFT_OF_CENTER,
        7 => AV_CHAN_FRONT_RIGHT_OF_CENTER,
        8 => AV_CHAN_BACK_CENTER,
        9 => AV_CHAN_SIDE_LEFT,
        10 => AV_CHAN_SIDE_RIGHT,
        11 => AV_CHAN_TOP_CENTER,
        12 => AV_CHAN_TOP_FRONT_LEFT,
        13 => AV_CHAN_TOP_FRONT_CENTER,
        14 => AV_CHAN_TOP_FRONT_RIGHT,
        15 => AV_CHAN_TOP_BACK_LEFT,
        16 => AV_CHAN_TOP_BACK_CENTER,
        17 => AV_CHAN_TOP_BACK_RIGHT,
        29 => AV_CHAN_STEREO_LEFT,
        30 => AV_CHAN_STEREO_RIGHT,
        31 => AV_CHAN_WIDE_LEFT,
        32 => AV_CHAN_WIDE_RIGHT,
        33 => AV_CHAN_SURROUND_DIRECT_LEFT,
        34 => AV_CHAN_SURROUND_DIRECT_RIGHT,
        35 => AV_CHAN_LOW_FREQUENCY_2,
        36 => AV_CHAN_TOP_SIDE_LEFT,
        37 => AV_CHAN_TOP_SIDE_RIGHT,
        38 => AV_CHAN_BOTTOM_FRONT_CENTER,
        39 => AV_CHAN_BOTTOM_FRONT_LEFT,
        40 => AV_CHAN_BOTTOM_FRONT_RIGHT,
        41 => AV_CHAN_SIDE_SURROUND_LEFT,
        42 => AV_CHAN_SIDE_SURROUND_RIGHT,
        43 => AV_CHAN_TOP_SURROUND_LEFT,
        44 => AV_CHAN_TOP_SURROUND_RIGHT,
        512 => AV_CHAN_UNUSED,
        768 => AV_CHAN_UNKNOWN,
        1024 => AV_CHAN_AMBISONIC_BASE,
        2047 => AV_CHAN_AMBISONIC_END,
        _ => throw ArgumentError("Unknown value for AVChannel: $value"),
      };
}

enum AVChannelOrder {
  /// Only the channel count is specified, without any further information
  /// about the channel order.
  AV_CHANNEL_ORDER_UNSPEC(0),

  /// The native channel order, i.e. the channels are in the same order in
  /// which they are defined in the AVChannel enum. This supports up to 63
  /// different channels.
  AV_CHANNEL_ORDER_NATIVE(1),

  /// The channel order does not correspond to any other predefined order and
  /// is stored as an explicit map. For example, this could be used to support
  /// layouts with 64 or more channels, or with empty/skipped (AV_CHAN_UNUSED)
  /// channels at arbitrary positions.
  AV_CHANNEL_ORDER_CUSTOM(2),

  /// The audio is represented as the decomposition of the sound field into
  /// spherical harmonics. Each channel corresponds to a single expansion
  /// component. Channels are ordered according to ACN (Ambisonic Channel
  /// Number).
  ///
  /// The channel with the index n in the stream contains the spherical
  /// harmonic of degree l and order m given by
  /// @code{.unparsed}
  /// l   = floor(sqrt(n)),
  /// m   = n - l * (l + 1).
  /// @endcode
  ///
  /// Conversely given a spherical harmonic of degree l and order m, the
  /// corresponding channel index n is given by
  /// @code{.unparsed}
  /// n = l * (l + 1) + m.
  /// @endcode
  ///
  /// Normalization is assumed to be SN3D (Schmidt Semi-Normalization)
  /// as defined in AmbiX format $ 2.1.
  AV_CHANNEL_ORDER_AMBISONIC(3),

  /// Number of channel orders, not part of ABI/API
  FF_CHANNEL_ORDER_NB(4);

  final int value;
  const AVChannelOrder(this.value);

  static AVChannelOrder fromValue(int value) => switch (value) {
        0 => AV_CHANNEL_ORDER_UNSPEC,
        1 => AV_CHANNEL_ORDER_NATIVE,
        2 => AV_CHANNEL_ORDER_CUSTOM,
        3 => AV_CHANNEL_ORDER_AMBISONIC,
        4 => FF_CHANNEL_ORDER_NB,
        _ => throw ArgumentError("Unknown value for AVChannelOrder: $value"),
      };
}

enum AVMatrixEncoding {
  AV_MATRIX_ENCODING_NONE(0),
  AV_MATRIX_ENCODING_DOLBY(1),
  AV_MATRIX_ENCODING_DPLII(2),
  AV_MATRIX_ENCODING_DPLIIX(3),
  AV_MATRIX_ENCODING_DPLIIZ(4),
  AV_MATRIX_ENCODING_DOLBYEX(5),
  AV_MATRIX_ENCODING_DOLBYHEADPHONE(6),
  AV_MATRIX_ENCODING_NB(7);

  final int value;
  const AVMatrixEncoding(this.value);

  static AVMatrixEncoding fromValue(int value) => switch (value) {
        0 => AV_MATRIX_ENCODING_NONE,
        1 => AV_MATRIX_ENCODING_DOLBY,
        2 => AV_MATRIX_ENCODING_DPLII,
        3 => AV_MATRIX_ENCODING_DPLIIX,
        4 => AV_MATRIX_ENCODING_DPLIIZ,
        5 => AV_MATRIX_ENCODING_DOLBYEX,
        6 => AV_MATRIX_ENCODING_DOLBYHEADPHONE,
        7 => AV_MATRIX_ENCODING_NB,
        _ => throw ArgumentError("Unknown value for AVMatrixEncoding: $value"),
      };
}

/// An AVChannelCustom defines a single channel within a custom order layout
///
/// Unlike most structures in FFmpeg, sizeof(AVChannelCustom) is a part of the
/// public ABI.
///
/// No new fields may be added to it without a major version bump.
final class AVChannelCustom extends ffi.Struct {
  @ffi.Int()
  external int idAsInt;

  AVChannel get id => AVChannel.fromValue(idAsInt);

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> name;

  external ffi.Pointer<ffi.Void> opaque;
}

/// An AVChannelLayout holds information about the channel layout of audio data.
///
/// A channel layout here is defined as a set of channels ordered in a specific
/// way (unless the channel order is AV_CHANNEL_ORDER_UNSPEC, in which case an
/// AVChannelLayout carries only the channel count).
/// All orders may be treated as if they were AV_CHANNEL_ORDER_UNSPEC by
/// ignoring everything but the channel count, as long as av_channel_layout_check()
/// considers they are valid.
///
/// Unlike most structures in FFmpeg, sizeof(AVChannelLayout) is a part of the
/// public ABI and may be used by the caller. E.g. it may be allocated on stack
/// or embedded in caller-defined structs.
///
/// AVChannelLayout can be initialized as follows:
/// - default initialization with {0}, followed by setting all used fields
/// correctly;
/// - by assigning one of the predefined AV_CHANNEL_LAYOUT_* initializers;
/// - with a constructor function, such as av_channel_layout_default(),
/// av_channel_layout_from_mask() or av_channel_layout_from_string().
///
/// The channel layout must be unitialized with av_channel_layout_uninit()
///
/// Copying an AVChannelLayout via assigning is forbidden,
/// av_channel_layout_copy() must be used instead (and its return value should
/// be checked)
///
/// No new fields may be added to it without a major version bump, except for
/// new elements of the union fitting in sizeof(uint64_t).
final class AVChannelLayout extends ffi.Struct {
  /// Channel order used in this layout.
  /// This is a mandatory field.
  @ffi.UnsignedInt()
  external int orderAsInt;

  AVChannelOrder get order => AVChannelOrder.fromValue(orderAsInt);

  /// Number of channels in this layout. Mandatory field.
  @ffi.Int()
  external int nb_channels;

  external UnnamedUnion2 u;

  /// For some private data of the user.
  external ffi.Pointer<ffi.Void> opaque;
}

/// Details about which channels are present in this layout.
/// For AV_CHANNEL_ORDER_UNSPEC, this field is undefined and must not be
/// used.
final class UnnamedUnion2 extends ffi.Union {
  /// This member must be used for AV_CHANNEL_ORDER_NATIVE, and may be used
  /// for AV_CHANNEL_ORDER_AMBISONIC to signal non-diegetic channels.
  /// It is a bitmask, where the position of each set bit means that the
  /// AVChannel with the corresponding value is present.
  ///
  /// I.e. when (mask & (1 << AV_CHAN_FOO)) is non-zero, then AV_CHAN_FOO
  /// is present in the layout. Otherwise it is not present.
  ///
  /// @note when a channel layout using a bitmask is constructed or
  /// modified manually (i.e.  not using any of the av_channel_layout_*
  /// functions), the code doing it must ensure that the number of set bits
  /// is equal to nb_channels.
  @ffi.Uint64()
  external int mask;

  /// This member must be used when the channel order is
  /// AV_CHANNEL_ORDER_CUSTOM. It is a nb_channels-sized array, with each
  /// element signalling the presence of the AVChannel with the
  /// corresponding value in map[i].id.
  ///
  /// I.e. when map[i].id is equal to AV_CHAN_FOO, then AV_CH_FOO is the
  /// i-th channel in the audio data.
  ///
  /// When map[i].id is in the range between AV_CHAN_AMBISONIC_BASE and
  /// AV_CHAN_AMBISONIC_END (inclusive), the channel contains an ambisonic
  /// component with ACN index (as defined above)
  /// n = map[i].id - AV_CHAN_AMBISONIC_BASE.
  ///
  /// map[i].name may be filled with a 0-terminated string, in which case
  /// it will be used for the purpose of identifying the channel with the
  /// convenience functions below. Otherise it must be zeroed.
  external ffi.Pointer<AVChannelCustom> map;
}

/// Buffer to print data progressively
///
/// The string buffer grows as necessary and is always 0-terminated.
/// The content of the string is never accessed, and thus is
/// encoding-agnostic and can even hold binary data.
///
/// Small buffers are kept in the structure itself, and thus require no
/// memory allocation at all (unless the contents of the buffer is needed
/// after the structure goes out of scope). This is almost as lightweight as
/// declaring a local `char buf[512]`.
///
/// The length of the string can go beyond the allocated size: the buffer is
/// then truncated, but the functions still keep account of the actual total
/// length.
///
/// In other words, AVBPrint.len can be greater than AVBPrint.size and records
/// the total length of what would have been to the buffer if there had been
/// enough memory.
///
/// Append operations do not need to be tested for failure: if a memory
/// allocation fails, data stop being appended to the buffer, but the length
/// is still updated. This situation can be tested with
/// av_bprint_is_complete().
///
/// The AVBPrint.size_max field determines several possible behaviours:
/// - `size_max = -1` (= `UINT_MAX`) or any large value will let the buffer be
/// reallocated as necessary, with an amortized linear cost.
/// - `size_max = 0` prevents writing anything to the buffer: only the total
/// length is computed. The write operations can then possibly be repeated in
/// a buffer with exactly the necessary size
/// (using `size_init = size_max = len + 1`).
/// - `size_max = 1` is automatically replaced by the exact size available in the
/// structure itself, thus ensuring no dynamic memory allocation. The
/// internal buffer is large enough to hold a reasonable paragraph of text,
/// such as the current paragraph.
final class AVBPrint extends ffi.Struct {
  external ffi.Pointer<ffi.Char> str;

  @ffi.UnsignedInt()
  external int len;

  @ffi.UnsignedInt()
  external int size;

  @ffi.UnsignedInt()
  external int size_max;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> reserved_internal_buffer;

  @ffi.Array.multi([1000])
  external ffi.Array<ffi.Char> reserved_padding;
}

/// @}
final class AVDictionaryEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

final class AVDictionary extends ffi.Opaque {}

/// @defgroup lavu_frame AVFrame
/// @ingroup lavu_data
///
/// @{
/// AVFrame is an abstraction for reference-counted raw multimedia data.
enum AVFrameSideDataType {
  /// The data is the AVPanScan struct defined in libavcodec.
  AV_FRAME_DATA_PANSCAN(0),

  /// ATSC A53 Part 4 Closed Captions.
  /// A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.
  /// The number of bytes of CC data is AVFrameSideData.size.
  AV_FRAME_DATA_A53_CC(1),

  /// Stereoscopic 3d metadata.
  /// The data is the AVStereo3D struct defined in libavutil/stereo3d.h.
  AV_FRAME_DATA_STEREO3D(2),

  /// The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h.
  AV_FRAME_DATA_MATRIXENCODING(3),

  /// Metadata relevant to a downmix procedure.
  /// The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.
  AV_FRAME_DATA_DOWNMIX_INFO(4),

  /// ReplayGain information in the form of the AVReplayGain struct.
  AV_FRAME_DATA_REPLAYGAIN(5),

  /// This side data contains a 3x3 transformation matrix describing an affine
  /// transformation that needs to be applied to the frame for correct
  /// presentation.
  ///
  /// See libavutil/display.h for a detailed description of the data.
  AV_FRAME_DATA_DISPLAYMATRIX(6),

  /// Active Format Description data consisting of a single byte as specified
  /// in ETSI TS 101 154 using AVActiveFormatDescription enum.
  AV_FRAME_DATA_AFD(7),

  /// Motion vectors exported by some codecs (on demand through the export_mvs
  /// flag set in the libavcodec AVCodecContext flags2 option).
  /// The data is the AVMotionVector struct defined in
  /// libavutil/motion_vector.h.
  AV_FRAME_DATA_MOTION_VECTORS(8),

  /// Recommmends skipping the specified number of samples. This is exported
  /// only if the "skip_manual" AVOption is set in libavcodec.
  /// This has the same format as AV_PKT_DATA_SKIP_SAMPLES.
  /// @code
  /// u32le number of samples to skip from start of this packet
  /// u32le number of samples to skip from end of this packet
  /// u8    reason for start skip
  /// u8    reason for end   skip (0=padding silence, 1=convergence)
  /// @endcode
  AV_FRAME_DATA_SKIP_SAMPLES(9),

  /// This side data must be associated with an audio frame and corresponds to
  /// enum AVAudioServiceType defined in avcodec.h.
  AV_FRAME_DATA_AUDIO_SERVICE_TYPE(10),

  /// Mastering display metadata associated with a video frame. The payload is
  /// an AVMasteringDisplayMetadata type and contains information about the
  /// mastering display color volume.
  AV_FRAME_DATA_MASTERING_DISPLAY_METADATA(11),

  /// The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.
  /// This is set on the first frame of a GOP that has a temporal reference of 0.
  AV_FRAME_DATA_GOP_TIMECODE(12),

  /// The data represents the AVSphericalMapping structure defined in
  /// libavutil/spherical.h.
  AV_FRAME_DATA_SPHERICAL(13),

  /// Content light level (based on CTA-861.3). This payload contains data in
  /// the form of the AVContentLightMetadata struct.
  AV_FRAME_DATA_CONTENT_LIGHT_LEVEL(14),

  /// The data contains an ICC profile as an opaque octet buffer following the
  /// format described by ISO 15076-1 with an optional name defined in the
  /// metadata key entry "name".
  AV_FRAME_DATA_ICC_PROFILE(15),

  /// Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t
  /// where the first uint32_t describes how many (1-3) of the other timecodes are used.
  /// The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()
  /// function in libavutil/timecode.h.
  AV_FRAME_DATA_S12M_TIMECODE(16),

  /// HDR dynamic metadata associated with a video frame. The payload is
  /// an AVDynamicHDRPlus type and contains information for color
  /// volume transform - application 4 of SMPTE 2094-40:2016 standard.
  AV_FRAME_DATA_DYNAMIC_HDR_PLUS(17),

  /// Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of
  /// array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size.
  AV_FRAME_DATA_REGIONS_OF_INTEREST(18),

  /// Encoding parameters for a video frame, as described by AVVideoEncParams.
  AV_FRAME_DATA_VIDEO_ENC_PARAMS(19),

  /// User data unregistered metadata associated with a video frame.
  /// This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose
  /// The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of
  /// uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte.
  AV_FRAME_DATA_SEI_UNREGISTERED(20),

  /// Film grain parameters for a frame, described by AVFilmGrainParams.
  /// Must be present for every frame which should have film grain applied.
  ///
  /// May be present multiple times, for example when there are multiple
  /// alternative parameter sets for different video signal characteristics.
  /// The user should select the most appropriate set for the application.
  AV_FRAME_DATA_FILM_GRAIN_PARAMS(21),

  /// Bounding boxes for object detection and classification,
  /// as described by AVDetectionBBoxHeader.
  AV_FRAME_DATA_DETECTION_BBOXES(22),

  /// Dolby Vision RPU raw data, suitable for passing to x265
  /// or other libraries. Array of uint8_t, with NAL emulation
  /// bytes intact.
  AV_FRAME_DATA_DOVI_RPU_BUFFER(23),

  /// Parsed Dolby Vision metadata, suitable for passing to a software
  /// implementation. The payload is the AVDOVIMetadata struct defined in
  /// libavutil/dovi_meta.h.
  AV_FRAME_DATA_DOVI_METADATA(24),

  /// HDR Vivid dynamic metadata associated with a video frame. The payload is
  /// an AVDynamicHDRVivid type and contains information for color
  /// volume transform - CUVA 005.1-2021.
  AV_FRAME_DATA_DYNAMIC_HDR_VIVID(25),

  /// Ambient viewing environment metadata, as defined by H.274.
  AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT(26),

  /// Provide encoder-specific hinting information about changed/unchanged
  /// portions of a frame.  It can be used to pass information about which
  /// macroblocks can be skipped because they didn't change from the
  /// corresponding ones in the previous frame. This could be useful for
  /// applications which know this information in advance to speed up
  /// encoding.
  AV_FRAME_DATA_VIDEO_HINT(27),

  /// Raw LCEVC payload data, as a uint8_t array, with NAL emulation
  /// bytes intact.
  AV_FRAME_DATA_LCEVC(28),

  /// This side data must be associated with a video frame.
  /// The presence of this side data indicates that the video stream is
  /// composed of multiple views (e.g. stereoscopic 3D content,
  /// cf. H.264 Annex H or H.265 Annex G).
  /// The data is an int storing the view ID.
  AV_FRAME_DATA_VIEW_ID(29);

  final int value;
  const AVFrameSideDataType(this.value);

  static AVFrameSideDataType fromValue(int value) => switch (value) {
        0 => AV_FRAME_DATA_PANSCAN,
        1 => AV_FRAME_DATA_A53_CC,
        2 => AV_FRAME_DATA_STEREO3D,
        3 => AV_FRAME_DATA_MATRIXENCODING,
        4 => AV_FRAME_DATA_DOWNMIX_INFO,
        5 => AV_FRAME_DATA_REPLAYGAIN,
        6 => AV_FRAME_DATA_DISPLAYMATRIX,
        7 => AV_FRAME_DATA_AFD,
        8 => AV_FRAME_DATA_MOTION_VECTORS,
        9 => AV_FRAME_DATA_SKIP_SAMPLES,
        10 => AV_FRAME_DATA_AUDIO_SERVICE_TYPE,
        11 => AV_FRAME_DATA_MASTERING_DISPLAY_METADATA,
        12 => AV_FRAME_DATA_GOP_TIMECODE,
        13 => AV_FRAME_DATA_SPHERICAL,
        14 => AV_FRAME_DATA_CONTENT_LIGHT_LEVEL,
        15 => AV_FRAME_DATA_ICC_PROFILE,
        16 => AV_FRAME_DATA_S12M_TIMECODE,
        17 => AV_FRAME_DATA_DYNAMIC_HDR_PLUS,
        18 => AV_FRAME_DATA_REGIONS_OF_INTEREST,
        19 => AV_FRAME_DATA_VIDEO_ENC_PARAMS,
        20 => AV_FRAME_DATA_SEI_UNREGISTERED,
        21 => AV_FRAME_DATA_FILM_GRAIN_PARAMS,
        22 => AV_FRAME_DATA_DETECTION_BBOXES,
        23 => AV_FRAME_DATA_DOVI_RPU_BUFFER,
        24 => AV_FRAME_DATA_DOVI_METADATA,
        25 => AV_FRAME_DATA_DYNAMIC_HDR_VIVID,
        26 => AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT,
        27 => AV_FRAME_DATA_VIDEO_HINT,
        28 => AV_FRAME_DATA_LCEVC,
        29 => AV_FRAME_DATA_VIEW_ID,
        _ =>
          throw ArgumentError("Unknown value for AVFrameSideDataType: $value"),
      };
}

enum AVActiveFormatDescription {
  AV_AFD_SAME(8),
  AV_AFD_4_3(9),
  AV_AFD_16_9(10),
  AV_AFD_14_9(11),
  AV_AFD_4_3_SP_14_9(13),
  AV_AFD_16_9_SP_14_9(14),
  AV_AFD_SP_4_3(15);

  final int value;
  const AVActiveFormatDescription(this.value);

  static AVActiveFormatDescription fromValue(int value) => switch (value) {
        8 => AV_AFD_SAME,
        9 => AV_AFD_4_3,
        10 => AV_AFD_16_9,
        11 => AV_AFD_14_9,
        13 => AV_AFD_4_3_SP_14_9,
        14 => AV_AFD_16_9_SP_14_9,
        15 => AV_AFD_SP_4_3,
        _ => throw ArgumentError(
            "Unknown value for AVActiveFormatDescription: $value"),
      };
}

/// Structure to hold side data for an AVFrame.
///
/// sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
final class AVFrameSideData extends ffi.Struct {
  @ffi.UnsignedInt()
  external int typeAsInt;

  AVFrameSideDataType get type => AVFrameSideDataType.fromValue(typeAsInt);

  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;

  external ffi.Pointer<AVDictionary> metadata;

  external ffi.Pointer<AVBufferRef> buf;
}

enum AVSideDataProps {
  /// The side data type can be used in stream-global structures.
  /// Side data types without this property are only meaningful on per-frame
  /// basis.
  AV_SIDE_DATA_PROP_GLOBAL(1),

  /// Multiple instances of this side data type can be meaningfully present in
  /// a single side data array.
  AV_SIDE_DATA_PROP_MULTI(2);

  final int value;
  const AVSideDataProps(this.value);

  static AVSideDataProps fromValue(int value) => switch (value) {
        1 => AV_SIDE_DATA_PROP_GLOBAL,
        2 => AV_SIDE_DATA_PROP_MULTI,
        _ => throw ArgumentError("Unknown value for AVSideDataProps: $value"),
      };
}

/// This struct describes the properties of a side data type. Its instance
/// corresponding to a given type can be obtained from av_frame_side_data_desc().
final class AVSideDataDescriptor extends ffi.Struct {
  /// Human-readable side data description.
  external ffi.Pointer<ffi.Char> name;

  /// Side data property flags, a combination of AVSideDataProps values.
  @ffi.UnsignedInt()
  external int props;
}

/// Structure describing a single Region Of Interest.
///
/// When multiple regions are defined in a single side-data block, they
/// should be ordered from most to least important - some encoders are only
/// capable of supporting a limited number of distinct regions, so will have
/// to truncate the list.
///
/// When overlapping regions are defined, the first region containing a given
/// area of the frame applies.
final class AVRegionOfInterest extends ffi.Struct {
  /// Must be set to the size of this data structure (that is,
  /// sizeof(AVRegionOfInterest)).
  @ffi.Uint32()
  external int self_size;

  /// Distance in pixels from the top edge of the frame to the top and
  /// bottom edges and from the left edge of the frame to the left and
  /// right edges of the rectangle defining this region of interest.
  ///
  /// The constraints on a region are encoder dependent, so the region
  /// actually affected may be slightly larger for alignment or other
  /// reasons.
  @ffi.Int()
  external int top;

  @ffi.Int()
  external int bottom;

  @ffi.Int()
  external int left;

  @ffi.Int()
  external int right;

  /// Quantisation offset.
  ///
  /// Must be in the range -1 to +1.  A value of zero indicates no quality
  /// change.  A negative value asks for better quality (less quantisation),
  /// while a positive value asks for worse quality (greater quantisation).
  ///
  /// The range is calibrated so that the extreme values indicate the
  /// largest possible offset - if the rest of the frame is encoded with the
  /// worst possible quality, an offset of -1 indicates that this region
  /// should be encoded with the best possible quality anyway.  Intermediate
  /// values are then interpolated in some codec-dependent way.
  ///
  /// For example, in 10-bit H.264 the quantisation parameter varies between
  /// -12 and 51.  A typical qoffset value of -1/10 therefore indicates that
  /// this region should be encoded with a QP around one-tenth of the full
  /// range better than the rest of the frame.  So, if most of the frame
  /// were to be encoded with a QP of around 30, this region would get a QP
  /// of around 24 (an offset of approximately -1/10 * (51 - -12) = -6.3).
  /// An extreme value of -1 would indicate that this region should be
  /// encoded with the best possible quality regardless of the treatment of
  /// the rest of the frame - that is, should be encoded at a QP of -12.
  external AVRational qoffset;
}

/// This structure describes decoded (raw) audio or video data.
///
/// AVFrame must be allocated using av_frame_alloc(). Note that this only
/// allocates the AVFrame itself, the buffers for the data must be managed
/// through other means (see below).
/// AVFrame must be freed with av_frame_free().
///
/// AVFrame is typically allocated once and then reused multiple times to hold
/// different data (e.g. a single AVFrame to hold frames received from a
/// decoder). In such a case, av_frame_unref() will free any references held by
/// the frame and reset it to its original clean state before it
/// is reused again.
///
/// The data described by an AVFrame is usually reference counted through the
/// AVBuffer API. The underlying buffer references are stored in AVFrame.buf /
/// AVFrame.extended_buf. An AVFrame is considered to be reference counted if at
/// least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,
/// every single data plane must be contained in one of the buffers in
/// AVFrame.buf or AVFrame.extended_buf.
/// There may be a single buffer for all the data, or one separate buffer for
/// each plane, or anything in between.
///
/// sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
///
/// Fields can be accessed through AVOptions, the name string used, matches the
/// C structure field name for fields accessible through AVOptions.
final class AVFrame extends ffi.Struct {
  /// pointer to the picture/channel planes.
  /// This might be different from the first allocated byte. For video,
  /// it could even point to the end of the image data.
  ///
  /// All pointers in data and extended_data must point into one of the
  /// AVBufferRef in buf or extended_buf.
  ///
  /// Some decoders access areas outside 0,0 - width,height, please
  /// see avcodec_align_dimensions2(). Some filters and swscale can read
  /// up to 16 bytes beyond the planes, if these filters are to be used,
  /// then 16 extra bytes must be allocated.
  ///
  /// NOTE: Pointers not needed by the format MUST be set to NULL.
  ///
  /// @attention In case of video, the data[] pointers can point to the
  /// end of image data in order to reverse line order, when used in
  /// combination with negative values in the linesize[] array.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<ffi.Uint8>> data;

  /// For video, a positive or negative value, which is typically indicating
  /// the size in bytes of each picture line, but it can also be:
  /// - the negative byte size of lines for vertical flipping
  /// (with data[n] pointing to the end of the data
  /// - a positive or negative multiple of the byte size as for accessing
  /// even and odd fields of a frame (possibly flipped)
  ///
  /// For audio, only linesize[0] may be set. For planar audio, each channel
  /// plane must be the same size.
  ///
  /// For video the linesizes should be multiples of the CPUs alignment
  /// preference, this is 16 or 32 for modern desktop CPUs.
  /// Some code requires such alignment other code can be slower without
  /// correct alignment, for yet other it makes no difference.
  ///
  /// @note The linesize may be larger than the size of usable data -- there
  /// may be extra padding present for performance reasons.
  ///
  /// @attention In case of video, line size values can be negative to achieve
  /// a vertically inverted iteration over image lines.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int> linesize;

  /// pointers to the data planes/channels.
  ///
  /// For video, this should simply point to data[].
  ///
  /// For planar audio, each channel has a separate data pointer, and
  /// linesize[0] contains the size of each channel buffer.
  /// For packed audio, there is just one data pointer, and linesize[0]
  /// contains the total size of the buffer for all channels.
  ///
  /// Note: Both data and extended_data should always be set in a valid frame,
  /// but for planar audio with more channels that can fit in data,
  /// extended_data must be used in order to access all channels.
  external ffi.Pointer<ffi.Pointer<ffi.Uint8>> extended_data;

  /// @name Video dimensions
  /// Video frames only. The coded dimensions (in pixels) of the video frame,
  /// i.e. the size of the rectangle that contains some well-defined values.
  ///
  /// @note The part of the frame intended for display/presentation is further
  /// restricted by the @ref cropping "Cropping rectangle".
  /// @{
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// number of audio samples (per channel) described by this frame
  @ffi.Int()
  external int nb_samples;

  /// format of the frame, -1 if unknown or unset
  /// Values correspond to enum AVPixelFormat for video frames,
  /// enum AVSampleFormat for audio)
  @ffi.Int()
  external int format;

  /// 1 -> keyframe, 0-> not
  ///
  /// @deprecated Use AV_FRAME_FLAG_KEY instead
  @ffi.Int()
  external int key_frame;

  /// Picture type of the frame.
  @ffi.UnsignedInt()
  external int pict_typeAsInt;

  AVPictureType get pict_type => AVPictureType.fromValue(pict_typeAsInt);

  /// Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
  external AVRational sample_aspect_ratio;

  /// Presentation timestamp in time_base units (time when frame should be shown to user).
  @ffi.Int64()
  external int pts;

  /// DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
  /// This is also the Presentation time of this AVFrame calculated from
  /// only AVPacket.dts values without pts values.
  @ffi.Int64()
  external int pkt_dts;

  /// Time base for the timestamps in this frame.
  /// In the future, this field may be set on frames output by decoders or
  /// filters, but its value will be by default ignored on input to encoders
  /// or filters.
  external AVRational time_base;

  /// quality (between 1 (good) and FF_LAMBDA_MAX (bad))
  @ffi.Int()
  external int quality;

  /// Frame owner's private data.
  ///
  /// This field may be set by the code that allocates/owns the frame data.
  /// It is then not touched by any library functions, except:
  /// - it is copied to other references by av_frame_copy_props() (and hence by
  /// av_frame_ref());
  /// - it is set to NULL when the frame is cleared by av_frame_unref()
  /// - on the caller's explicit request. E.g. libavcodec encoders/decoders
  /// will copy this field to/from @ref AVPacket "AVPackets" if the caller sets
  /// @ref AV_CODEC_FLAG_COPY_OPAQUE.
  ///
  /// @see opaque_ref the reference-counted analogue
  external ffi.Pointer<ffi.Void> opaque;

  /// Number of fields in this frame which should be repeated, i.e. the total
  /// duration of this frame should be repeat_pict + 2 normal field durations.
  ///
  /// For interlaced frames this field may be set to 1, which signals that this
  /// frame should be presented as 3 fields: beginning with the first field (as
  /// determined by AV_FRAME_FLAG_TOP_FIELD_FIRST being set or not), followed
  /// by the second field, and then the first field again.
  ///
  /// For progressive frames this field may be set to a multiple of 2, which
  /// signals that this frame's duration should be (repeat_pict + 2) / 2
  /// normal frame durations.
  ///
  /// @note This field is computed from MPEG2 repeat_first_field flag and its
  /// associated flags, H.264 pic_struct from picture timing SEI, and
  /// their analogues in other codecs. Typically it should only be used when
  /// higher-layer timing information is not available.
  @ffi.Int()
  external int repeat_pict;

  /// The content of the picture is interlaced.
  ///
  /// @deprecated Use AV_FRAME_FLAG_INTERLACED instead
  @ffi.Int()
  external int interlaced_frame;

  /// If the content is interlaced, is top field displayed first.
  ///
  /// @deprecated Use AV_FRAME_FLAG_TOP_FIELD_FIRST instead
  @ffi.Int()
  external int top_field_first;

  /// Tell user application that palette has changed from previous frame.
  @ffi.Int()
  external int palette_has_changed;

  /// Sample rate of the audio data.
  @ffi.Int()
  external int sample_rate;

  /// AVBuffer references backing the data for this frame. All the pointers in
  /// data and extended_data must point inside one of the buffers in buf or
  /// extended_buf. This array must be filled contiguously -- if buf[i] is
  /// non-NULL then buf[j] must also be non-NULL for all j < i.
  ///
  /// There may be at most one AVBuffer per data plane, so for video this array
  /// always contains all the references. For planar audio with more than
  /// AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
  /// this array. Then the extra AVBufferRef pointers are stored in the
  /// extended_buf array.
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Pointer<AVBufferRef>> buf;

  /// For planar audio which requires more than AV_NUM_DATA_POINTERS
  /// AVBufferRef pointers, this array will hold all the references which
  /// cannot fit into AVFrame.buf.
  ///
  /// Note that this is different from AVFrame.extended_data, which always
  /// contains all the pointers. This array only contains the extra pointers,
  /// which cannot fit into AVFrame.buf.
  ///
  /// This array is always allocated using av_malloc() by whoever constructs
  /// the frame. It is freed in av_frame_unref().
  external ffi.Pointer<ffi.Pointer<AVBufferRef>> extended_buf;

  /// Number of elements in extended_buf.
  @ffi.Int()
  external int nb_extended_buf;

  external ffi.Pointer<ffi.Pointer<AVFrameSideData>> side_data;

  @ffi.Int()
  external int nb_side_data;

  /// Frame flags, a combination of @ref lavu_frame_flags
  @ffi.Int()
  external int flags;

  /// MPEG vs JPEG YUV range.
  /// - encoding: Set by user
  /// - decoding: Set by libavcodec
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  AVColorPrimaries get color_primaries =>
      AVColorPrimaries.fromValue(color_primariesAsInt);

  @ffi.UnsignedInt()
  external int color_trcAsInt;

  AVColorTransferCharacteristic get color_trc =>
      AVColorTransferCharacteristic.fromValue(color_trcAsInt);

  /// YUV colorspace type.
  /// - encoding: Set by user
  /// - decoding: Set by libavcodec
  @ffi.UnsignedInt()
  external int colorspaceAsInt;

  AVColorSpace get colorspace => AVColorSpace.fromValue(colorspaceAsInt);

  @ffi.UnsignedInt()
  external int chroma_locationAsInt;

  AVChromaLocation get chroma_location =>
      AVChromaLocation.fromValue(chroma_locationAsInt);

  /// frame timestamp estimated using various heuristics, in stream time base
  /// - encoding: unused
  /// - decoding: set by libavcodec, read by user.
  @ffi.Int64()
  external int best_effort_timestamp;

  /// reordered pos from the last AVPacket that has been input into the decoder
  /// - encoding: unused
  /// - decoding: Read by user.
  /// @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
  /// data from packets to frames
  @ffi.Int64()
  external int pkt_pos;

  /// metadata.
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  external ffi.Pointer<AVDictionary> metadata;

  /// decode error flags of the frame, set to a combination of
  /// FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
  /// were errors during the decoding.
  /// - encoding: unused
  /// - decoding: set by libavcodec, read by user.
  @ffi.Int()
  external int decode_error_flags;

  /// size of the corresponding packet containing the compressed
  /// frame.
  /// It is set to a negative value if unknown.
  /// - encoding: unused
  /// - decoding: set by libavcodec, read by user.
  /// @deprecated use AV_CODEC_FLAG_COPY_OPAQUE to pass through arbitrary user
  /// data from packets to frames
  @ffi.Int()
  external int pkt_size;

  /// For hwaccel-format frames, this should be a reference to the
  /// AVHWFramesContext describing the frame.
  external ffi.Pointer<AVBufferRef> hw_frames_ctx;

  /// Frame owner's private data.
  ///
  /// This field may be set by the code that allocates/owns the frame data.
  /// It is then not touched by any library functions, except:
  /// - a new reference to the underlying buffer is propagated by
  /// av_frame_copy_props() (and hence by av_frame_ref());
  /// - it is unreferenced in av_frame_unref();
  /// - on the caller's explicit request. E.g. libavcodec encoders/decoders
  /// will propagate a new reference to/from @ref AVPacket "AVPackets" if the
  /// caller sets @ref AV_CODEC_FLAG_COPY_OPAQUE.
  ///
  /// @see opaque the plain pointer analogue
  external ffi.Pointer<AVBufferRef> opaque_ref;

  /// @anchor cropping
  /// @name Cropping
  /// Video frames only. The number of pixels to discard from the the
  /// top/bottom/left/right border of the frame to obtain the sub-rectangle of
  /// the frame intended for presentation.
  /// @{
  @ffi.Size()
  external int crop_top;

  @ffi.Size()
  external int crop_bottom;

  @ffi.Size()
  external int crop_left;

  @ffi.Size()
  external int crop_right;

  /// AVBufferRef for internal use by a single libav* library.
  /// Must not be used to transfer data between libraries.
  /// Has to be NULL when ownership of the frame leaves the respective library.
  ///
  /// Code outside the FFmpeg libs should never check or change the contents of the buffer ref.
  ///
  /// FFmpeg calls av_buffer_unref() on it when the frame is unreferenced.
  /// av_frame_copy_props() calls create a new reference with av_buffer_ref()
  /// for the target frame's private_ref field.
  external ffi.Pointer<AVBufferRef> private_ref;

  /// Channel layout of the audio data.
  external AVChannelLayout ch_layout;

  /// Duration of the frame, in the same units as pts. 0 if unknown.
  @ffi.Int64()
  external int duration;
}

enum AVHWDeviceType {
  AV_HWDEVICE_TYPE_NONE(0),
  AV_HWDEVICE_TYPE_VDPAU(1),
  AV_HWDEVICE_TYPE_CUDA(2),
  AV_HWDEVICE_TYPE_VAAPI(3),
  AV_HWDEVICE_TYPE_DXVA2(4),
  AV_HWDEVICE_TYPE_QSV(5),
  AV_HWDEVICE_TYPE_VIDEOTOOLBOX(6),
  AV_HWDEVICE_TYPE_D3D11VA(7),
  AV_HWDEVICE_TYPE_DRM(8),
  AV_HWDEVICE_TYPE_OPENCL(9),
  AV_HWDEVICE_TYPE_MEDIACODEC(10),
  AV_HWDEVICE_TYPE_VULKAN(11),
  AV_HWDEVICE_TYPE_D3D12VA(12);

  final int value;
  const AVHWDeviceType(this.value);

  static AVHWDeviceType fromValue(int value) => switch (value) {
        0 => AV_HWDEVICE_TYPE_NONE,
        1 => AV_HWDEVICE_TYPE_VDPAU,
        2 => AV_HWDEVICE_TYPE_CUDA,
        3 => AV_HWDEVICE_TYPE_VAAPI,
        4 => AV_HWDEVICE_TYPE_DXVA2,
        5 => AV_HWDEVICE_TYPE_QSV,
        6 => AV_HWDEVICE_TYPE_VIDEOTOOLBOX,
        7 => AV_HWDEVICE_TYPE_D3D11VA,
        8 => AV_HWDEVICE_TYPE_DRM,
        9 => AV_HWDEVICE_TYPE_OPENCL,
        10 => AV_HWDEVICE_TYPE_MEDIACODEC,
        11 => AV_HWDEVICE_TYPE_VULKAN,
        12 => AV_HWDEVICE_TYPE_D3D12VA,
        _ => throw ArgumentError("Unknown value for AVHWDeviceType: $value"),
      };
}

/// This struct aggregates all the (hardware/vendor-specific) "high-level" state,
/// i.e. state that is not tied to a concrete processing configuration.
/// E.g., in an API that supports hardware-accelerated encoding and decoding,
/// this struct will (if possible) wrap the state that is common to both encoding
/// and decoding and from which specific instances of encoders or decoders can be
/// derived.
///
/// This struct is reference-counted with the AVBuffer mechanism. The
/// av_hwdevice_ctx_alloc() constructor yields a reference, whose data field
/// points to the actual AVHWDeviceContext. Further objects derived from
/// AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with
/// specific properties) will hold an internal reference to it. After all the
/// references are released, the AVHWDeviceContext itself will be freed,
/// optionally invoking a user-specified callback for uninitializing the hardware
/// state.
final class AVHWDeviceContext extends ffi.Struct {
  /// A class for logging. Set by av_hwdevice_ctx_alloc().
  external ffi.Pointer<AVClass> av_class;

  /// This field identifies the underlying API used for hardware access.
  ///
  /// This field is set when this struct is allocated and never changed
  /// afterwards.
  @ffi.UnsignedInt()
  external int typeAsInt;

  AVHWDeviceType get type => AVHWDeviceType.fromValue(typeAsInt);

  /// The format-specific data, allocated and freed by libavutil along with
  /// this context.
  ///
  /// Should be cast by the user to the format-specific context defined in the
  /// corresponding header (hwcontext_*.h) and filled as described in the
  /// documentation before calling av_hwdevice_ctx_init().
  ///
  /// After calling av_hwdevice_ctx_init() this struct should not be modified
  /// by the caller.
  external ffi.Pointer<ffi.Void> hwctx;

  /// This field may be set by the caller before calling av_hwdevice_ctx_init().
  ///
  /// If non-NULL, this callback will be called when the last reference to
  /// this context is unreferenced, immediately before it is freed.
  ///
  /// @note when other objects (e.g an AVHWFramesContext) are derived from this
  /// struct, this callback will be invoked after all such child objects
  /// are fully uninitialized and their respective destructors invoked.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHWDeviceContext> ctx)>> free;

  /// Arbitrary user data, to be used e.g. by the free() callback.
  external ffi.Pointer<ffi.Void> user_opaque;
}

/// This struct describes a set or pool of "hardware" frames (i.e. those with
/// data not located in normal system memory). All the frames in the pool are
/// assumed to be allocated in the same way and interchangeable.
///
/// This struct is reference-counted with the AVBuffer mechanism and tied to a
/// given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor
/// yields a reference, whose data field points to the actual AVHWFramesContext
/// struct.
final class AVHWFramesContext extends ffi.Struct {
  /// A class for logging.
  external ffi.Pointer<AVClass> av_class;

  /// A reference to the parent AVHWDeviceContext. This reference is owned and
  /// managed by the enclosing AVHWFramesContext, but the caller may derive
  /// additional references from it.
  external ffi.Pointer<AVBufferRef> device_ref;

  /// The parent AVHWDeviceContext. This is simply a pointer to
  /// device_ref->data provided for convenience.
  ///
  /// Set by libavutil in av_hwframe_ctx_init().
  external ffi.Pointer<AVHWDeviceContext> device_ctx;

  /// The format-specific data, allocated and freed automatically along with
  /// this context.
  ///
  /// The user shall ignore this field if the corresponding format-specific
  /// header (hwcontext_*.h) does not define a context to be used as
  /// AVHWFramesContext.hwctx.
  ///
  /// Otherwise, it should be cast by the user to said context and filled
  /// as described in the documentation before calling av_hwframe_ctx_init().
  ///
  /// After any frames using this context are created, the contents of this
  /// struct should not be modified by the caller.
  external ffi.Pointer<ffi.Void> hwctx;

  /// This field may be set by the caller before calling av_hwframe_ctx_init().
  ///
  /// If non-NULL, this callback will be called when the last reference to
  /// this context is unreferenced, immediately before it is freed.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVHWFramesContext> ctx)>> free;

  /// Arbitrary user data, to be used e.g. by the free() callback.
  external ffi.Pointer<ffi.Void> user_opaque;

  /// A pool from which the frames are allocated by av_hwframe_get_buffer().
  /// This field may be set by the caller before calling av_hwframe_ctx_init().
  /// The buffers returned by calling av_buffer_pool_get() on this pool must
  /// have the properties described in the documentation in the corresponding hw
  /// type's header (hwcontext_*.h). The pool will be freed strictly before
  /// this struct's free() callback is invoked.
  ///
  /// This field may be NULL, then libavutil will attempt to allocate a pool
  /// internally. Note that certain device types enforce pools allocated at
  /// fixed size (frame count), which cannot be extended dynamically. In such a
  /// case, initial_pool_size must be set appropriately.
  external ffi.Pointer<AVBufferPool> pool;

  /// Initial size of the frame pool. If a device type does not support
  /// dynamically resizing the pool, then this is also the maximum pool size.
  ///
  /// May be set by the caller before calling av_hwframe_ctx_init(). Must be
  /// set if pool is NULL and the device type does not support dynamic pools.
  @ffi.Int()
  external int initial_pool_size;

  /// The pixel format identifying the underlying HW surface type.
  ///
  /// Must be a hwaccel format, i.e. the corresponding descriptor must have the
  /// AV_PIX_FMT_FLAG_HWACCEL flag set.
  ///
  /// Must be set by the user before calling av_hwframe_ctx_init().
  @ffi.Int()
  external int formatAsInt;

  AVPixelFormat get format => AVPixelFormat.fromValue(formatAsInt);

  /// The pixel format identifying the actual data layout of the hardware
  /// frames.
  ///
  /// Must be set by the caller before calling av_hwframe_ctx_init().
  ///
  /// @note when the underlying API does not provide the exact data layout, but
  /// only the colorspace/bit depth, this field should be set to the fully
  /// planar version of that format (e.g. for 8-bit 420 YUV it should be
  /// AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else).
  @ffi.Int()
  external int sw_formatAsInt;

  AVPixelFormat get sw_format => AVPixelFormat.fromValue(sw_formatAsInt);

  /// The allocated dimensions of the frames in this pool.
  ///
  /// Must be set by the user before calling av_hwframe_ctx_init().
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;
}

enum AVHWFrameTransferDirection {
  /// Transfer the data from the queried hw frame.
  AV_HWFRAME_TRANSFER_DIRECTION_FROM(0),

  /// Transfer the data to the queried hw frame.
  AV_HWFRAME_TRANSFER_DIRECTION_TO(1);

  final int value;
  const AVHWFrameTransferDirection(this.value);

  static AVHWFrameTransferDirection fromValue(int value) => switch (value) {
        0 => AV_HWFRAME_TRANSFER_DIRECTION_FROM,
        1 => AV_HWFRAME_TRANSFER_DIRECTION_TO,
        _ => throw ArgumentError(
            "Unknown value for AVHWFrameTransferDirection: $value"),
      };
}

/// This struct describes the constraints on hardware frames attached to
/// a given device with a hardware-specific configuration.  This is returned
/// by av_hwdevice_get_hwframe_constraints() and must be freed by
/// av_hwframe_constraints_free() after use.
final class AVHWFramesConstraints extends ffi.Struct {
  /// A list of possible values for format in the hw_frames_ctx,
  /// terminated by AV_PIX_FMT_NONE.  This member will always be filled.
  external ffi.Pointer<ffi.Int> valid_hw_formats;

  /// A list of possible values for sw_format in the hw_frames_ctx,
  /// terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is
  /// not known.
  external ffi.Pointer<ffi.Int> valid_sw_formats;

  /// The minimum size of frames in this hw_frames_ctx.
  /// (Zero if not known.)
  @ffi.Int()
  external int min_width;

  @ffi.Int()
  external int min_height;

  /// The maximum size of frames in this hw_frames_ctx.
  /// (INT_MAX if not known / no limit.)
  @ffi.Int()
  external int max_width;

  @ffi.Int()
  external int max_height;
}

/// Identify the syntax and semantics of the bitstream.
/// The principle is roughly:
/// Two decoders with the same ID can decode the same streams.
/// Two encoders with the same ID can encode compatible streams.
/// There may be slight deviations from the principle due to implementation
/// details.
///
/// If you add a codec ID to this list, add it so that
/// 1. no value of an existing codec ID changes (that would break ABI),
/// 2. it is as close as possible to similar codecs
///
/// After adding new codec IDs, do not forget to add an entry to the codec
/// descriptor list and bump libavcodec minor version.
enum AVCodecID {
  AV_CODEC_ID_NONE(0),
  AV_CODEC_ID_MPEG1VIDEO(1),

  /// < preferred ID for MPEG-1/2 video decoding
  AV_CODEC_ID_MPEG2VIDEO(2),
  AV_CODEC_ID_H261(3),
  AV_CODEC_ID_H263(4),
  AV_CODEC_ID_RV10(5),
  AV_CODEC_ID_RV20(6),
  AV_CODEC_ID_MJPEG(7),
  AV_CODEC_ID_MJPEGB(8),
  AV_CODEC_ID_LJPEG(9),
  AV_CODEC_ID_SP5X(10),
  AV_CODEC_ID_JPEGLS(11),
  AV_CODEC_ID_MPEG4(12),
  AV_CODEC_ID_RAWVIDEO(13),
  AV_CODEC_ID_MSMPEG4V1(14),
  AV_CODEC_ID_MSMPEG4V2(15),
  AV_CODEC_ID_MSMPEG4V3(16),
  AV_CODEC_ID_WMV1(17),
  AV_CODEC_ID_WMV2(18),
  AV_CODEC_ID_H263P(19),
  AV_CODEC_ID_H263I(20),
  AV_CODEC_ID_FLV1(21),
  AV_CODEC_ID_SVQ1(22),
  AV_CODEC_ID_SVQ3(23),
  AV_CODEC_ID_DVVIDEO(24),
  AV_CODEC_ID_HUFFYUV(25),
  AV_CODEC_ID_CYUV(26),
  AV_CODEC_ID_H264(27),
  AV_CODEC_ID_INDEO3(28),
  AV_CODEC_ID_VP3(29),
  AV_CODEC_ID_THEORA(30),
  AV_CODEC_ID_ASV1(31),
  AV_CODEC_ID_ASV2(32),
  AV_CODEC_ID_FFV1(33),
  AV_CODEC_ID_4XM(34),
  AV_CODEC_ID_VCR1(35),
  AV_CODEC_ID_CLJR(36),
  AV_CODEC_ID_MDEC(37),
  AV_CODEC_ID_ROQ(38),
  AV_CODEC_ID_INTERPLAY_VIDEO(39),
  AV_CODEC_ID_XAN_WC3(40),
  AV_CODEC_ID_XAN_WC4(41),
  AV_CODEC_ID_RPZA(42),
  AV_CODEC_ID_CINEPAK(43),
  AV_CODEC_ID_WS_VQA(44),
  AV_CODEC_ID_MSRLE(45),
  AV_CODEC_ID_MSVIDEO1(46),
  AV_CODEC_ID_IDCIN(47),
  AV_CODEC_ID_8BPS(48),
  AV_CODEC_ID_SMC(49),
  AV_CODEC_ID_FLIC(50),
  AV_CODEC_ID_TRUEMOTION1(51),
  AV_CODEC_ID_VMDVIDEO(52),
  AV_CODEC_ID_MSZH(53),
  AV_CODEC_ID_ZLIB(54),
  AV_CODEC_ID_QTRLE(55),
  AV_CODEC_ID_TSCC(56),
  AV_CODEC_ID_ULTI(57),
  AV_CODEC_ID_QDRAW(58),
  AV_CODEC_ID_VIXL(59),
  AV_CODEC_ID_QPEG(60),
  AV_CODEC_ID_PNG(61),
  AV_CODEC_ID_PPM(62),
  AV_CODEC_ID_PBM(63),
  AV_CODEC_ID_PGM(64),
  AV_CODEC_ID_PGMYUV(65),
  AV_CODEC_ID_PAM(66),
  AV_CODEC_ID_FFVHUFF(67),
  AV_CODEC_ID_RV30(68),
  AV_CODEC_ID_RV40(69),
  AV_CODEC_ID_VC1(70),
  AV_CODEC_ID_WMV3(71),
  AV_CODEC_ID_LOCO(72),
  AV_CODEC_ID_WNV1(73),
  AV_CODEC_ID_AASC(74),
  AV_CODEC_ID_INDEO2(75),
  AV_CODEC_ID_FRAPS(76),
  AV_CODEC_ID_TRUEMOTION2(77),
  AV_CODEC_ID_BMP(78),
  AV_CODEC_ID_CSCD(79),
  AV_CODEC_ID_MMVIDEO(80),
  AV_CODEC_ID_ZMBV(81),
  AV_CODEC_ID_AVS(82),
  AV_CODEC_ID_SMACKVIDEO(83),
  AV_CODEC_ID_NUV(84),
  AV_CODEC_ID_KMVC(85),
  AV_CODEC_ID_FLASHSV(86),
  AV_CODEC_ID_CAVS(87),
  AV_CODEC_ID_JPEG2000(88),
  AV_CODEC_ID_VMNC(89),
  AV_CODEC_ID_VP5(90),
  AV_CODEC_ID_VP6(91),
  AV_CODEC_ID_VP6F(92),
  AV_CODEC_ID_TARGA(93),
  AV_CODEC_ID_DSICINVIDEO(94),
  AV_CODEC_ID_TIERTEXSEQVIDEO(95),
  AV_CODEC_ID_TIFF(96),
  AV_CODEC_ID_GIF(97),
  AV_CODEC_ID_DXA(98),
  AV_CODEC_ID_DNXHD(99),
  AV_CODEC_ID_THP(100),
  AV_CODEC_ID_SGI(101),
  AV_CODEC_ID_C93(102),
  AV_CODEC_ID_BETHSOFTVID(103),
  AV_CODEC_ID_PTX(104),
  AV_CODEC_ID_TXD(105),
  AV_CODEC_ID_VP6A(106),
  AV_CODEC_ID_AMV(107),
  AV_CODEC_ID_VB(108),
  AV_CODEC_ID_PCX(109),
  AV_CODEC_ID_SUNRAST(110),
  AV_CODEC_ID_INDEO4(111),
  AV_CODEC_ID_INDEO5(112),
  AV_CODEC_ID_MIMIC(113),
  AV_CODEC_ID_RL2(114),
  AV_CODEC_ID_ESCAPE124(115),
  AV_CODEC_ID_DIRAC(116),
  AV_CODEC_ID_BFI(117),
  AV_CODEC_ID_CMV(118),
  AV_CODEC_ID_MOTIONPIXELS(119),
  AV_CODEC_ID_TGV(120),
  AV_CODEC_ID_TGQ(121),
  AV_CODEC_ID_TQI(122),
  AV_CODEC_ID_AURA(123),
  AV_CODEC_ID_AURA2(124),
  AV_CODEC_ID_V210X(125),
  AV_CODEC_ID_TMV(126),
  AV_CODEC_ID_V210(127),
  AV_CODEC_ID_DPX(128),
  AV_CODEC_ID_MAD(129),
  AV_CODEC_ID_FRWU(130),
  AV_CODEC_ID_FLASHSV2(131),
  AV_CODEC_ID_CDGRAPHICS(132),
  AV_CODEC_ID_R210(133),
  AV_CODEC_ID_ANM(134),
  AV_CODEC_ID_BINKVIDEO(135),
  AV_CODEC_ID_IFF_ILBM(136),
  AV_CODEC_ID_KGV1(137),
  AV_CODEC_ID_YOP(138),
  AV_CODEC_ID_VP8(139),
  AV_CODEC_ID_PICTOR(140),
  AV_CODEC_ID_ANSI(141),
  AV_CODEC_ID_A64_MULTI(142),
  AV_CODEC_ID_A64_MULTI5(143),
  AV_CODEC_ID_R10K(144),
  AV_CODEC_ID_MXPEG(145),
  AV_CODEC_ID_LAGARITH(146),
  AV_CODEC_ID_PRORES(147),
  AV_CODEC_ID_JV(148),
  AV_CODEC_ID_DFA(149),
  AV_CODEC_ID_WMV3IMAGE(150),
  AV_CODEC_ID_VC1IMAGE(151),
  AV_CODEC_ID_UTVIDEO(152),
  AV_CODEC_ID_BMV_VIDEO(153),
  AV_CODEC_ID_VBLE(154),
  AV_CODEC_ID_DXTORY(155),
  AV_CODEC_ID_V410(156),
  AV_CODEC_ID_XWD(157),
  AV_CODEC_ID_CDXL(158),
  AV_CODEC_ID_XBM(159),
  AV_CODEC_ID_ZEROCODEC(160),
  AV_CODEC_ID_MSS1(161),
  AV_CODEC_ID_MSA1(162),
  AV_CODEC_ID_TSCC2(163),
  AV_CODEC_ID_MTS2(164),
  AV_CODEC_ID_CLLC(165),
  AV_CODEC_ID_MSS2(166),
  AV_CODEC_ID_VP9(167),
  AV_CODEC_ID_AIC(168),
  AV_CODEC_ID_ESCAPE130(169),
  AV_CODEC_ID_G2M(170),
  AV_CODEC_ID_WEBP(171),
  AV_CODEC_ID_HNM4_VIDEO(172),
  AV_CODEC_ID_HEVC(173),
  AV_CODEC_ID_FIC(174),
  AV_CODEC_ID_ALIAS_PIX(175),
  AV_CODEC_ID_BRENDER_PIX(176),
  AV_CODEC_ID_PAF_VIDEO(177),
  AV_CODEC_ID_EXR(178),
  AV_CODEC_ID_VP7(179),
  AV_CODEC_ID_SANM(180),
  AV_CODEC_ID_SGIRLE(181),
  AV_CODEC_ID_MVC1(182),
  AV_CODEC_ID_MVC2(183),
  AV_CODEC_ID_HQX(184),
  AV_CODEC_ID_TDSC(185),
  AV_CODEC_ID_HQ_HQA(186),
  AV_CODEC_ID_HAP(187),
  AV_CODEC_ID_DDS(188),
  AV_CODEC_ID_DXV(189),
  AV_CODEC_ID_SCREENPRESSO(190),
  AV_CODEC_ID_RSCC(191),
  AV_CODEC_ID_AVS2(192),
  AV_CODEC_ID_PGX(193),
  AV_CODEC_ID_AVS3(194),
  AV_CODEC_ID_MSP2(195),
  AV_CODEC_ID_VVC(196),
  AV_CODEC_ID_Y41P(197),
  AV_CODEC_ID_AVRP(198),
  AV_CODEC_ID_012V(199),
  AV_CODEC_ID_AVUI(200),
  AV_CODEC_ID_TARGA_Y216(201),
  AV_CODEC_ID_V308(202),
  AV_CODEC_ID_V408(203),
  AV_CODEC_ID_YUV4(204),
  AV_CODEC_ID_AVRN(205),
  AV_CODEC_ID_CPIA(206),
  AV_CODEC_ID_XFACE(207),
  AV_CODEC_ID_SNOW(208),
  AV_CODEC_ID_SMVJPEG(209),
  AV_CODEC_ID_APNG(210),
  AV_CODEC_ID_DAALA(211),
  AV_CODEC_ID_CFHD(212),
  AV_CODEC_ID_TRUEMOTION2RT(213),
  AV_CODEC_ID_M101(214),
  AV_CODEC_ID_MAGICYUV(215),
  AV_CODEC_ID_SHEERVIDEO(216),
  AV_CODEC_ID_YLC(217),
  AV_CODEC_ID_PSD(218),
  AV_CODEC_ID_PIXLET(219),
  AV_CODEC_ID_SPEEDHQ(220),
  AV_CODEC_ID_FMVC(221),
  AV_CODEC_ID_SCPR(222),
  AV_CODEC_ID_CLEARVIDEO(223),
  AV_CODEC_ID_XPM(224),
  AV_CODEC_ID_AV1(225),
  AV_CODEC_ID_BITPACKED(226),
  AV_CODEC_ID_MSCC(227),
  AV_CODEC_ID_SRGC(228),
  AV_CODEC_ID_SVG(229),
  AV_CODEC_ID_GDV(230),
  AV_CODEC_ID_FITS(231),
  AV_CODEC_ID_IMM4(232),
  AV_CODEC_ID_PROSUMER(233),
  AV_CODEC_ID_MWSC(234),
  AV_CODEC_ID_WCMV(235),
  AV_CODEC_ID_RASC(236),
  AV_CODEC_ID_HYMT(237),
  AV_CODEC_ID_ARBC(238),
  AV_CODEC_ID_AGM(239),
  AV_CODEC_ID_LSCR(240),
  AV_CODEC_ID_VP4(241),
  AV_CODEC_ID_IMM5(242),
  AV_CODEC_ID_MVDV(243),
  AV_CODEC_ID_MVHA(244),
  AV_CODEC_ID_CDTOONS(245),
  AV_CODEC_ID_MV30(246),
  AV_CODEC_ID_NOTCHLC(247),
  AV_CODEC_ID_PFM(248),
  AV_CODEC_ID_MOBICLIP(249),
  AV_CODEC_ID_PHOTOCD(250),
  AV_CODEC_ID_IPU(251),
  AV_CODEC_ID_ARGO(252),
  AV_CODEC_ID_CRI(253),
  AV_CODEC_ID_SIMBIOSIS_IMX(254),
  AV_CODEC_ID_SGA_VIDEO(255),
  AV_CODEC_ID_GEM(256),
  AV_CODEC_ID_VBN(257),
  AV_CODEC_ID_JPEGXL(258),
  AV_CODEC_ID_QOI(259),
  AV_CODEC_ID_PHM(260),
  AV_CODEC_ID_RADIANCE_HDR(261),
  AV_CODEC_ID_WBMP(262),
  AV_CODEC_ID_MEDIA100(263),
  AV_CODEC_ID_VQC(264),
  AV_CODEC_ID_PDV(265),
  AV_CODEC_ID_EVC(266),
  AV_CODEC_ID_RTV1(267),
  AV_CODEC_ID_VMIX(268),
  AV_CODEC_ID_LEAD(269),

  /// < A dummy id pointing at the start of audio codecs
  AV_CODEC_ID_FIRST_AUDIO(65536),
  AV_CODEC_ID_PCM_S16BE(65537),
  AV_CODEC_ID_PCM_U16LE(65538),
  AV_CODEC_ID_PCM_U16BE(65539),
  AV_CODEC_ID_PCM_S8(65540),
  AV_CODEC_ID_PCM_U8(65541),
  AV_CODEC_ID_PCM_MULAW(65542),
  AV_CODEC_ID_PCM_ALAW(65543),
  AV_CODEC_ID_PCM_S32LE(65544),
  AV_CODEC_ID_PCM_S32BE(65545),
  AV_CODEC_ID_PCM_U32LE(65546),
  AV_CODEC_ID_PCM_U32BE(65547),
  AV_CODEC_ID_PCM_S24LE(65548),
  AV_CODEC_ID_PCM_S24BE(65549),
  AV_CODEC_ID_PCM_U24LE(65550),
  AV_CODEC_ID_PCM_U24BE(65551),
  AV_CODEC_ID_PCM_S24DAUD(65552),
  AV_CODEC_ID_PCM_ZORK(65553),
  AV_CODEC_ID_PCM_S16LE_PLANAR(65554),
  AV_CODEC_ID_PCM_DVD(65555),
  AV_CODEC_ID_PCM_F32BE(65556),
  AV_CODEC_ID_PCM_F32LE(65557),
  AV_CODEC_ID_PCM_F64BE(65558),
  AV_CODEC_ID_PCM_F64LE(65559),
  AV_CODEC_ID_PCM_BLURAY(65560),
  AV_CODEC_ID_PCM_LXF(65561),
  AV_CODEC_ID_S302M(65562),
  AV_CODEC_ID_PCM_S8_PLANAR(65563),
  AV_CODEC_ID_PCM_S24LE_PLANAR(65564),
  AV_CODEC_ID_PCM_S32LE_PLANAR(65565),
  AV_CODEC_ID_PCM_S16BE_PLANAR(65566),
  AV_CODEC_ID_PCM_S64LE(65567),
  AV_CODEC_ID_PCM_S64BE(65568),
  AV_CODEC_ID_PCM_F16LE(65569),
  AV_CODEC_ID_PCM_F24LE(65570),
  AV_CODEC_ID_PCM_VIDC(65571),
  AV_CODEC_ID_PCM_SGA(65572),
  AV_CODEC_ID_ADPCM_IMA_QT(69632),
  AV_CODEC_ID_ADPCM_IMA_WAV(69633),
  AV_CODEC_ID_ADPCM_IMA_DK3(69634),
  AV_CODEC_ID_ADPCM_IMA_DK4(69635),
  AV_CODEC_ID_ADPCM_IMA_WS(69636),
  AV_CODEC_ID_ADPCM_IMA_SMJPEG(69637),
  AV_CODEC_ID_ADPCM_MS(69638),
  AV_CODEC_ID_ADPCM_4XM(69639),
  AV_CODEC_ID_ADPCM_XA(69640),
  AV_CODEC_ID_ADPCM_ADX(69641),
  AV_CODEC_ID_ADPCM_EA(69642),
  AV_CODEC_ID_ADPCM_G726(69643),
  AV_CODEC_ID_ADPCM_CT(69644),
  AV_CODEC_ID_ADPCM_SWF(69645),
  AV_CODEC_ID_ADPCM_YAMAHA(69646),
  AV_CODEC_ID_ADPCM_SBPRO_4(69647),
  AV_CODEC_ID_ADPCM_SBPRO_3(69648),
  AV_CODEC_ID_ADPCM_SBPRO_2(69649),
  AV_CODEC_ID_ADPCM_THP(69650),
  AV_CODEC_ID_ADPCM_IMA_AMV(69651),
  AV_CODEC_ID_ADPCM_EA_R1(69652),
  AV_CODEC_ID_ADPCM_EA_R3(69653),
  AV_CODEC_ID_ADPCM_EA_R2(69654),
  AV_CODEC_ID_ADPCM_IMA_EA_SEAD(69655),
  AV_CODEC_ID_ADPCM_IMA_EA_EACS(69656),
  AV_CODEC_ID_ADPCM_EA_XAS(69657),
  AV_CODEC_ID_ADPCM_EA_MAXIS_XA(69658),
  AV_CODEC_ID_ADPCM_IMA_ISS(69659),
  AV_CODEC_ID_ADPCM_G722(69660),
  AV_CODEC_ID_ADPCM_IMA_APC(69661),
  AV_CODEC_ID_ADPCM_VIMA(69662),
  AV_CODEC_ID_ADPCM_AFC(69663),
  AV_CODEC_ID_ADPCM_IMA_OKI(69664),
  AV_CODEC_ID_ADPCM_DTK(69665),
  AV_CODEC_ID_ADPCM_IMA_RAD(69666),
  AV_CODEC_ID_ADPCM_G726LE(69667),
  AV_CODEC_ID_ADPCM_THP_LE(69668),
  AV_CODEC_ID_ADPCM_PSX(69669),
  AV_CODEC_ID_ADPCM_AICA(69670),
  AV_CODEC_ID_ADPCM_IMA_DAT4(69671),
  AV_CODEC_ID_ADPCM_MTAF(69672),
  AV_CODEC_ID_ADPCM_AGM(69673),
  AV_CODEC_ID_ADPCM_ARGO(69674),
  AV_CODEC_ID_ADPCM_IMA_SSI(69675),
  AV_CODEC_ID_ADPCM_ZORK(69676),
  AV_CODEC_ID_ADPCM_IMA_APM(69677),
  AV_CODEC_ID_ADPCM_IMA_ALP(69678),
  AV_CODEC_ID_ADPCM_IMA_MTF(69679),
  AV_CODEC_ID_ADPCM_IMA_CUNNING(69680),
  AV_CODEC_ID_ADPCM_IMA_MOFLEX(69681),
  AV_CODEC_ID_ADPCM_IMA_ACORN(69682),
  AV_CODEC_ID_ADPCM_XMD(69683),
  AV_CODEC_ID_AMR_NB(73728),
  AV_CODEC_ID_AMR_WB(73729),
  AV_CODEC_ID_RA_144(77824),
  AV_CODEC_ID_RA_288(77825),
  AV_CODEC_ID_ROQ_DPCM(81920),
  AV_CODEC_ID_INTERPLAY_DPCM(81921),
  AV_CODEC_ID_XAN_DPCM(81922),
  AV_CODEC_ID_SOL_DPCM(81923),
  AV_CODEC_ID_SDX2_DPCM(81924),
  AV_CODEC_ID_GREMLIN_DPCM(81925),
  AV_CODEC_ID_DERF_DPCM(81926),
  AV_CODEC_ID_WADY_DPCM(81927),
  AV_CODEC_ID_CBD2_DPCM(81928),
  AV_CODEC_ID_MP2(86016),

  /// < preferred ID for decoding MPEG audio layer 1, 2 or 3
  AV_CODEC_ID_MP3(86017),
  AV_CODEC_ID_AAC(86018),
  AV_CODEC_ID_AC3(86019),
  AV_CODEC_ID_DTS(86020),
  AV_CODEC_ID_VORBIS(86021),
  AV_CODEC_ID_DVAUDIO(86022),
  AV_CODEC_ID_WMAV1(86023),
  AV_CODEC_ID_WMAV2(86024),
  AV_CODEC_ID_MACE3(86025),
  AV_CODEC_ID_MACE6(86026),
  AV_CODEC_ID_VMDAUDIO(86027),
  AV_CODEC_ID_FLAC(86028),
  AV_CODEC_ID_MP3ADU(86029),
  AV_CODEC_ID_MP3ON4(86030),
  AV_CODEC_ID_SHORTEN(86031),
  AV_CODEC_ID_ALAC(86032),
  AV_CODEC_ID_WESTWOOD_SND1(86033),

  /// < as in Berlin toast format
  AV_CODEC_ID_GSM(86034),
  AV_CODEC_ID_QDM2(86035),
  AV_CODEC_ID_COOK(86036),
  AV_CODEC_ID_TRUESPEECH(86037),
  AV_CODEC_ID_TTA(86038),
  AV_CODEC_ID_SMACKAUDIO(86039),
  AV_CODEC_ID_QCELP(86040),
  AV_CODEC_ID_WAVPACK(86041),
  AV_CODEC_ID_DSICINAUDIO(86042),
  AV_CODEC_ID_IMC(86043),
  AV_CODEC_ID_MUSEPACK7(86044),
  AV_CODEC_ID_MLP(86045),
  AV_CODEC_ID_GSM_MS(86046),
  AV_CODEC_ID_ATRAC3(86047),
  AV_CODEC_ID_APE(86048),
  AV_CODEC_ID_NELLYMOSER(86049),
  AV_CODEC_ID_MUSEPACK8(86050),
  AV_CODEC_ID_SPEEX(86051),
  AV_CODEC_ID_WMAVOICE(86052),
  AV_CODEC_ID_WMAPRO(86053),
  AV_CODEC_ID_WMALOSSLESS(86054),
  AV_CODEC_ID_ATRAC3P(86055),
  AV_CODEC_ID_EAC3(86056),
  AV_CODEC_ID_SIPR(86057),
  AV_CODEC_ID_MP1(86058),
  AV_CODEC_ID_TWINVQ(86059),
  AV_CODEC_ID_TRUEHD(86060),
  AV_CODEC_ID_MP4ALS(86061),
  AV_CODEC_ID_ATRAC1(86062),
  AV_CODEC_ID_BINKAUDIO_RDFT(86063),
  AV_CODEC_ID_BINKAUDIO_DCT(86064),
  AV_CODEC_ID_AAC_LATM(86065),
  AV_CODEC_ID_QDMC(86066),
  AV_CODEC_ID_CELT(86067),
  AV_CODEC_ID_G723_1(86068),
  AV_CODEC_ID_G729(86069),
  AV_CODEC_ID_8SVX_EXP(86070),
  AV_CODEC_ID_8SVX_FIB(86071),
  AV_CODEC_ID_BMV_AUDIO(86072),
  AV_CODEC_ID_RALF(86073),
  AV_CODEC_ID_IAC(86074),
  AV_CODEC_ID_ILBC(86075),
  AV_CODEC_ID_OPUS(86076),
  AV_CODEC_ID_COMFORT_NOISE(86077),
  AV_CODEC_ID_TAK(86078),
  AV_CODEC_ID_METASOUND(86079),
  AV_CODEC_ID_PAF_AUDIO(86080),
  AV_CODEC_ID_ON2AVC(86081),
  AV_CODEC_ID_DSS_SP(86082),
  AV_CODEC_ID_CODEC2(86083),
  AV_CODEC_ID_FFWAVESYNTH(86084),
  AV_CODEC_ID_SONIC(86085),
  AV_CODEC_ID_SONIC_LS(86086),
  AV_CODEC_ID_EVRC(86087),
  AV_CODEC_ID_SMV(86088),
  AV_CODEC_ID_DSD_LSBF(86089),
  AV_CODEC_ID_DSD_MSBF(86090),
  AV_CODEC_ID_DSD_LSBF_PLANAR(86091),
  AV_CODEC_ID_DSD_MSBF_PLANAR(86092),
  AV_CODEC_ID_4GV(86093),
  AV_CODEC_ID_INTERPLAY_ACM(86094),
  AV_CODEC_ID_XMA1(86095),
  AV_CODEC_ID_XMA2(86096),
  AV_CODEC_ID_DST(86097),
  AV_CODEC_ID_ATRAC3AL(86098),
  AV_CODEC_ID_ATRAC3PAL(86099),
  AV_CODEC_ID_DOLBY_E(86100),
  AV_CODEC_ID_APTX(86101),
  AV_CODEC_ID_APTX_HD(86102),
  AV_CODEC_ID_SBC(86103),
  AV_CODEC_ID_ATRAC9(86104),
  AV_CODEC_ID_HCOM(86105),
  AV_CODEC_ID_ACELP_KELVIN(86106),
  AV_CODEC_ID_MPEGH_3D_AUDIO(86107),
  AV_CODEC_ID_SIREN(86108),
  AV_CODEC_ID_HCA(86109),
  AV_CODEC_ID_FASTAUDIO(86110),
  AV_CODEC_ID_MSNSIREN(86111),
  AV_CODEC_ID_DFPWM(86112),
  AV_CODEC_ID_BONK(86113),
  AV_CODEC_ID_MISC4(86114),
  AV_CODEC_ID_APAC(86115),
  AV_CODEC_ID_FTR(86116),
  AV_CODEC_ID_WAVARC(86117),
  AV_CODEC_ID_RKA(86118),
  AV_CODEC_ID_AC4(86119),
  AV_CODEC_ID_OSQ(86120),
  AV_CODEC_ID_QOA(86121),
  AV_CODEC_ID_LC3(86122),

  /// < A dummy ID pointing at the start of subtitle codecs.
  AV_CODEC_ID_FIRST_SUBTITLE(94208),
  AV_CODEC_ID_DVB_SUBTITLE(94209),

  /// < raw UTF-8 text
  AV_CODEC_ID_TEXT(94210),
  AV_CODEC_ID_XSUB(94211),
  AV_CODEC_ID_SSA(94212),
  AV_CODEC_ID_MOV_TEXT(94213),
  AV_CODEC_ID_HDMV_PGS_SUBTITLE(94214),
  AV_CODEC_ID_DVB_TELETEXT(94215),
  AV_CODEC_ID_SRT(94216),
  AV_CODEC_ID_MICRODVD(94217),
  AV_CODEC_ID_EIA_608(94218),
  AV_CODEC_ID_JACOSUB(94219),
  AV_CODEC_ID_SAMI(94220),
  AV_CODEC_ID_REALTEXT(94221),
  AV_CODEC_ID_STL(94222),
  AV_CODEC_ID_SUBVIEWER1(94223),
  AV_CODEC_ID_SUBVIEWER(94224),
  AV_CODEC_ID_SUBRIP(94225),
  AV_CODEC_ID_WEBVTT(94226),
  AV_CODEC_ID_MPL2(94227),
  AV_CODEC_ID_VPLAYER(94228),
  AV_CODEC_ID_PJS(94229),
  AV_CODEC_ID_ASS(94230),
  AV_CODEC_ID_HDMV_TEXT_SUBTITLE(94231),
  AV_CODEC_ID_TTML(94232),
  AV_CODEC_ID_ARIB_CAPTION(94233),

  /// < A dummy ID pointing at the start of various fake codecs.
  AV_CODEC_ID_FIRST_UNKNOWN(98304),

  /// < Contain timestamp estimated through PCR of program stream.
  AV_CODEC_ID_SCTE_35(98305),
  AV_CODEC_ID_EPG(98306),
  AV_CODEC_ID_BINTEXT(98307),
  AV_CODEC_ID_XBIN(98308),
  AV_CODEC_ID_IDF(98309),
  AV_CODEC_ID_OTF(98310),
  AV_CODEC_ID_SMPTE_KLV(98311),
  AV_CODEC_ID_DVD_NAV(98312),
  AV_CODEC_ID_TIMED_ID3(98313),
  AV_CODEC_ID_BIN_DATA(98314),
  AV_CODEC_ID_SMPTE_2038(98315),
  AV_CODEC_ID_LCEVC(98316),

  /// < codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
  AV_CODEC_ID_PROBE(102400),

  /// < _FAKE_ codec to indicate a raw MPEG-2 TS
  /// stream (only used by libavformat)
  AV_CODEC_ID_MPEG2TS(131072),

  /// < _FAKE_ codec to indicate a MPEG-4 Systems
  /// stream (only used by libavformat)
  AV_CODEC_ID_MPEG4SYSTEMS(131073),

  /// < Dummy codec for streams containing only metadata information.
  AV_CODEC_ID_FFMETADATA(135168),

  /// < Passthrough codec, AVFrames wrapped in AVPacket
  AV_CODEC_ID_WRAPPED_AVFRAME(135169),

  /// Dummy null video codec, useful mainly for development and debugging.
  /// Null encoder/decoder discard all input and never return any output.
  AV_CODEC_ID_VNULL(135170),

  /// Dummy null audio codec, useful mainly for development and debugging.
  /// Null encoder/decoder discard all input and never return any output.
  AV_CODEC_ID_ANULL(135171);

  static const AV_CODEC_ID_PCM_S16LE = AV_CODEC_ID_FIRST_AUDIO;
  static const AV_CODEC_ID_DVD_SUBTITLE = AV_CODEC_ID_FIRST_SUBTITLE;
  static const AV_CODEC_ID_TTF = AV_CODEC_ID_FIRST_UNKNOWN;

  final int value;
  const AVCodecID(this.value);

  static AVCodecID fromValue(int value) => switch (value) {
        0 => AV_CODEC_ID_NONE,
        1 => AV_CODEC_ID_MPEG1VIDEO,
        2 => AV_CODEC_ID_MPEG2VIDEO,
        3 => AV_CODEC_ID_H261,
        4 => AV_CODEC_ID_H263,
        5 => AV_CODEC_ID_RV10,
        6 => AV_CODEC_ID_RV20,
        7 => AV_CODEC_ID_MJPEG,
        8 => AV_CODEC_ID_MJPEGB,
        9 => AV_CODEC_ID_LJPEG,
        10 => AV_CODEC_ID_SP5X,
        11 => AV_CODEC_ID_JPEGLS,
        12 => AV_CODEC_ID_MPEG4,
        13 => AV_CODEC_ID_RAWVIDEO,
        14 => AV_CODEC_ID_MSMPEG4V1,
        15 => AV_CODEC_ID_MSMPEG4V2,
        16 => AV_CODEC_ID_MSMPEG4V3,
        17 => AV_CODEC_ID_WMV1,
        18 => AV_CODEC_ID_WMV2,
        19 => AV_CODEC_ID_H263P,
        20 => AV_CODEC_ID_H263I,
        21 => AV_CODEC_ID_FLV1,
        22 => AV_CODEC_ID_SVQ1,
        23 => AV_CODEC_ID_SVQ3,
        24 => AV_CODEC_ID_DVVIDEO,
        25 => AV_CODEC_ID_HUFFYUV,
        26 => AV_CODEC_ID_CYUV,
        27 => AV_CODEC_ID_H264,
        28 => AV_CODEC_ID_INDEO3,
        29 => AV_CODEC_ID_VP3,
        30 => AV_CODEC_ID_THEORA,
        31 => AV_CODEC_ID_ASV1,
        32 => AV_CODEC_ID_ASV2,
        33 => AV_CODEC_ID_FFV1,
        34 => AV_CODEC_ID_4XM,
        35 => AV_CODEC_ID_VCR1,
        36 => AV_CODEC_ID_CLJR,
        37 => AV_CODEC_ID_MDEC,
        38 => AV_CODEC_ID_ROQ,
        39 => AV_CODEC_ID_INTERPLAY_VIDEO,
        40 => AV_CODEC_ID_XAN_WC3,
        41 => AV_CODEC_ID_XAN_WC4,
        42 => AV_CODEC_ID_RPZA,
        43 => AV_CODEC_ID_CINEPAK,
        44 => AV_CODEC_ID_WS_VQA,
        45 => AV_CODEC_ID_MSRLE,
        46 => AV_CODEC_ID_MSVIDEO1,
        47 => AV_CODEC_ID_IDCIN,
        48 => AV_CODEC_ID_8BPS,
        49 => AV_CODEC_ID_SMC,
        50 => AV_CODEC_ID_FLIC,
        51 => AV_CODEC_ID_TRUEMOTION1,
        52 => AV_CODEC_ID_VMDVIDEO,
        53 => AV_CODEC_ID_MSZH,
        54 => AV_CODEC_ID_ZLIB,
        55 => AV_CODEC_ID_QTRLE,
        56 => AV_CODEC_ID_TSCC,
        57 => AV_CODEC_ID_ULTI,
        58 => AV_CODEC_ID_QDRAW,
        59 => AV_CODEC_ID_VIXL,
        60 => AV_CODEC_ID_QPEG,
        61 => AV_CODEC_ID_PNG,
        62 => AV_CODEC_ID_PPM,
        63 => AV_CODEC_ID_PBM,
        64 => AV_CODEC_ID_PGM,
        65 => AV_CODEC_ID_PGMYUV,
        66 => AV_CODEC_ID_PAM,
        67 => AV_CODEC_ID_FFVHUFF,
        68 => AV_CODEC_ID_RV30,
        69 => AV_CODEC_ID_RV40,
        70 => AV_CODEC_ID_VC1,
        71 => AV_CODEC_ID_WMV3,
        72 => AV_CODEC_ID_LOCO,
        73 => AV_CODEC_ID_WNV1,
        74 => AV_CODEC_ID_AASC,
        75 => AV_CODEC_ID_INDEO2,
        76 => AV_CODEC_ID_FRAPS,
        77 => AV_CODEC_ID_TRUEMOTION2,
        78 => AV_CODEC_ID_BMP,
        79 => AV_CODEC_ID_CSCD,
        80 => AV_CODEC_ID_MMVIDEO,
        81 => AV_CODEC_ID_ZMBV,
        82 => AV_CODEC_ID_AVS,
        83 => AV_CODEC_ID_SMACKVIDEO,
        84 => AV_CODEC_ID_NUV,
        85 => AV_CODEC_ID_KMVC,
        86 => AV_CODEC_ID_FLASHSV,
        87 => AV_CODEC_ID_CAVS,
        88 => AV_CODEC_ID_JPEG2000,
        89 => AV_CODEC_ID_VMNC,
        90 => AV_CODEC_ID_VP5,
        91 => AV_CODEC_ID_VP6,
        92 => AV_CODEC_ID_VP6F,
        93 => AV_CODEC_ID_TARGA,
        94 => AV_CODEC_ID_DSICINVIDEO,
        95 => AV_CODEC_ID_TIERTEXSEQVIDEO,
        96 => AV_CODEC_ID_TIFF,
        97 => AV_CODEC_ID_GIF,
        98 => AV_CODEC_ID_DXA,
        99 => AV_CODEC_ID_DNXHD,
        100 => AV_CODEC_ID_THP,
        101 => AV_CODEC_ID_SGI,
        102 => AV_CODEC_ID_C93,
        103 => AV_CODEC_ID_BETHSOFTVID,
        104 => AV_CODEC_ID_PTX,
        105 => AV_CODEC_ID_TXD,
        106 => AV_CODEC_ID_VP6A,
        107 => AV_CODEC_ID_AMV,
        108 => AV_CODEC_ID_VB,
        109 => AV_CODEC_ID_PCX,
        110 => AV_CODEC_ID_SUNRAST,
        111 => AV_CODEC_ID_INDEO4,
        112 => AV_CODEC_ID_INDEO5,
        113 => AV_CODEC_ID_MIMIC,
        114 => AV_CODEC_ID_RL2,
        115 => AV_CODEC_ID_ESCAPE124,
        116 => AV_CODEC_ID_DIRAC,
        117 => AV_CODEC_ID_BFI,
        118 => AV_CODEC_ID_CMV,
        119 => AV_CODEC_ID_MOTIONPIXELS,
        120 => AV_CODEC_ID_TGV,
        121 => AV_CODEC_ID_TGQ,
        122 => AV_CODEC_ID_TQI,
        123 => AV_CODEC_ID_AURA,
        124 => AV_CODEC_ID_AURA2,
        125 => AV_CODEC_ID_V210X,
        126 => AV_CODEC_ID_TMV,
        127 => AV_CODEC_ID_V210,
        128 => AV_CODEC_ID_DPX,
        129 => AV_CODEC_ID_MAD,
        130 => AV_CODEC_ID_FRWU,
        131 => AV_CODEC_ID_FLASHSV2,
        132 => AV_CODEC_ID_CDGRAPHICS,
        133 => AV_CODEC_ID_R210,
        134 => AV_CODEC_ID_ANM,
        135 => AV_CODEC_ID_BINKVIDEO,
        136 => AV_CODEC_ID_IFF_ILBM,
        137 => AV_CODEC_ID_KGV1,
        138 => AV_CODEC_ID_YOP,
        139 => AV_CODEC_ID_VP8,
        140 => AV_CODEC_ID_PICTOR,
        141 => AV_CODEC_ID_ANSI,
        142 => AV_CODEC_ID_A64_MULTI,
        143 => AV_CODEC_ID_A64_MULTI5,
        144 => AV_CODEC_ID_R10K,
        145 => AV_CODEC_ID_MXPEG,
        146 => AV_CODEC_ID_LAGARITH,
        147 => AV_CODEC_ID_PRORES,
        148 => AV_CODEC_ID_JV,
        149 => AV_CODEC_ID_DFA,
        150 => AV_CODEC_ID_WMV3IMAGE,
        151 => AV_CODEC_ID_VC1IMAGE,
        152 => AV_CODEC_ID_UTVIDEO,
        153 => AV_CODEC_ID_BMV_VIDEO,
        154 => AV_CODEC_ID_VBLE,
        155 => AV_CODEC_ID_DXTORY,
        156 => AV_CODEC_ID_V410,
        157 => AV_CODEC_ID_XWD,
        158 => AV_CODEC_ID_CDXL,
        159 => AV_CODEC_ID_XBM,
        160 => AV_CODEC_ID_ZEROCODEC,
        161 => AV_CODEC_ID_MSS1,
        162 => AV_CODEC_ID_MSA1,
        163 => AV_CODEC_ID_TSCC2,
        164 => AV_CODEC_ID_MTS2,
        165 => AV_CODEC_ID_CLLC,
        166 => AV_CODEC_ID_MSS2,
        167 => AV_CODEC_ID_VP9,
        168 => AV_CODEC_ID_AIC,
        169 => AV_CODEC_ID_ESCAPE130,
        170 => AV_CODEC_ID_G2M,
        171 => AV_CODEC_ID_WEBP,
        172 => AV_CODEC_ID_HNM4_VIDEO,
        173 => AV_CODEC_ID_HEVC,
        174 => AV_CODEC_ID_FIC,
        175 => AV_CODEC_ID_ALIAS_PIX,
        176 => AV_CODEC_ID_BRENDER_PIX,
        177 => AV_CODEC_ID_PAF_VIDEO,
        178 => AV_CODEC_ID_EXR,
        179 => AV_CODEC_ID_VP7,
        180 => AV_CODEC_ID_SANM,
        181 => AV_CODEC_ID_SGIRLE,
        182 => AV_CODEC_ID_MVC1,
        183 => AV_CODEC_ID_MVC2,
        184 => AV_CODEC_ID_HQX,
        185 => AV_CODEC_ID_TDSC,
        186 => AV_CODEC_ID_HQ_HQA,
        187 => AV_CODEC_ID_HAP,
        188 => AV_CODEC_ID_DDS,
        189 => AV_CODEC_ID_DXV,
        190 => AV_CODEC_ID_SCREENPRESSO,
        191 => AV_CODEC_ID_RSCC,
        192 => AV_CODEC_ID_AVS2,
        193 => AV_CODEC_ID_PGX,
        194 => AV_CODEC_ID_AVS3,
        195 => AV_CODEC_ID_MSP2,
        196 => AV_CODEC_ID_VVC,
        197 => AV_CODEC_ID_Y41P,
        198 => AV_CODEC_ID_AVRP,
        199 => AV_CODEC_ID_012V,
        200 => AV_CODEC_ID_AVUI,
        201 => AV_CODEC_ID_TARGA_Y216,
        202 => AV_CODEC_ID_V308,
        203 => AV_CODEC_ID_V408,
        204 => AV_CODEC_ID_YUV4,
        205 => AV_CODEC_ID_AVRN,
        206 => AV_CODEC_ID_CPIA,
        207 => AV_CODEC_ID_XFACE,
        208 => AV_CODEC_ID_SNOW,
        209 => AV_CODEC_ID_SMVJPEG,
        210 => AV_CODEC_ID_APNG,
        211 => AV_CODEC_ID_DAALA,
        212 => AV_CODEC_ID_CFHD,
        213 => AV_CODEC_ID_TRUEMOTION2RT,
        214 => AV_CODEC_ID_M101,
        215 => AV_CODEC_ID_MAGICYUV,
        216 => AV_CODEC_ID_SHEERVIDEO,
        217 => AV_CODEC_ID_YLC,
        218 => AV_CODEC_ID_PSD,
        219 => AV_CODEC_ID_PIXLET,
        220 => AV_CODEC_ID_SPEEDHQ,
        221 => AV_CODEC_ID_FMVC,
        222 => AV_CODEC_ID_SCPR,
        223 => AV_CODEC_ID_CLEARVIDEO,
        224 => AV_CODEC_ID_XPM,
        225 => AV_CODEC_ID_AV1,
        226 => AV_CODEC_ID_BITPACKED,
        227 => AV_CODEC_ID_MSCC,
        228 => AV_CODEC_ID_SRGC,
        229 => AV_CODEC_ID_SVG,
        230 => AV_CODEC_ID_GDV,
        231 => AV_CODEC_ID_FITS,
        232 => AV_CODEC_ID_IMM4,
        233 => AV_CODEC_ID_PROSUMER,
        234 => AV_CODEC_ID_MWSC,
        235 => AV_CODEC_ID_WCMV,
        236 => AV_CODEC_ID_RASC,
        237 => AV_CODEC_ID_HYMT,
        238 => AV_CODEC_ID_ARBC,
        239 => AV_CODEC_ID_AGM,
        240 => AV_CODEC_ID_LSCR,
        241 => AV_CODEC_ID_VP4,
        242 => AV_CODEC_ID_IMM5,
        243 => AV_CODEC_ID_MVDV,
        244 => AV_CODEC_ID_MVHA,
        245 => AV_CODEC_ID_CDTOONS,
        246 => AV_CODEC_ID_MV30,
        247 => AV_CODEC_ID_NOTCHLC,
        248 => AV_CODEC_ID_PFM,
        249 => AV_CODEC_ID_MOBICLIP,
        250 => AV_CODEC_ID_PHOTOCD,
        251 => AV_CODEC_ID_IPU,
        252 => AV_CODEC_ID_ARGO,
        253 => AV_CODEC_ID_CRI,
        254 => AV_CODEC_ID_SIMBIOSIS_IMX,
        255 => AV_CODEC_ID_SGA_VIDEO,
        256 => AV_CODEC_ID_GEM,
        257 => AV_CODEC_ID_VBN,
        258 => AV_CODEC_ID_JPEGXL,
        259 => AV_CODEC_ID_QOI,
        260 => AV_CODEC_ID_PHM,
        261 => AV_CODEC_ID_RADIANCE_HDR,
        262 => AV_CODEC_ID_WBMP,
        263 => AV_CODEC_ID_MEDIA100,
        264 => AV_CODEC_ID_VQC,
        265 => AV_CODEC_ID_PDV,
        266 => AV_CODEC_ID_EVC,
        267 => AV_CODEC_ID_RTV1,
        268 => AV_CODEC_ID_VMIX,
        269 => AV_CODEC_ID_LEAD,
        65536 => AV_CODEC_ID_FIRST_AUDIO,
        65537 => AV_CODEC_ID_PCM_S16BE,
        65538 => AV_CODEC_ID_PCM_U16LE,
        65539 => AV_CODEC_ID_PCM_U16BE,
        65540 => AV_CODEC_ID_PCM_S8,
        65541 => AV_CODEC_ID_PCM_U8,
        65542 => AV_CODEC_ID_PCM_MULAW,
        65543 => AV_CODEC_ID_PCM_ALAW,
        65544 => AV_CODEC_ID_PCM_S32LE,
        65545 => AV_CODEC_ID_PCM_S32BE,
        65546 => AV_CODEC_ID_PCM_U32LE,
        65547 => AV_CODEC_ID_PCM_U32BE,
        65548 => AV_CODEC_ID_PCM_S24LE,
        65549 => AV_CODEC_ID_PCM_S24BE,
        65550 => AV_CODEC_ID_PCM_U24LE,
        65551 => AV_CODEC_ID_PCM_U24BE,
        65552 => AV_CODEC_ID_PCM_S24DAUD,
        65553 => AV_CODEC_ID_PCM_ZORK,
        65554 => AV_CODEC_ID_PCM_S16LE_PLANAR,
        65555 => AV_CODEC_ID_PCM_DVD,
        65556 => AV_CODEC_ID_PCM_F32BE,
        65557 => AV_CODEC_ID_PCM_F32LE,
        65558 => AV_CODEC_ID_PCM_F64BE,
        65559 => AV_CODEC_ID_PCM_F64LE,
        65560 => AV_CODEC_ID_PCM_BLURAY,
        65561 => AV_CODEC_ID_PCM_LXF,
        65562 => AV_CODEC_ID_S302M,
        65563 => AV_CODEC_ID_PCM_S8_PLANAR,
        65564 => AV_CODEC_ID_PCM_S24LE_PLANAR,
        65565 => AV_CODEC_ID_PCM_S32LE_PLANAR,
        65566 => AV_CODEC_ID_PCM_S16BE_PLANAR,
        65567 => AV_CODEC_ID_PCM_S64LE,
        65568 => AV_CODEC_ID_PCM_S64BE,
        65569 => AV_CODEC_ID_PCM_F16LE,
        65570 => AV_CODEC_ID_PCM_F24LE,
        65571 => AV_CODEC_ID_PCM_VIDC,
        65572 => AV_CODEC_ID_PCM_SGA,
        69632 => AV_CODEC_ID_ADPCM_IMA_QT,
        69633 => AV_CODEC_ID_ADPCM_IMA_WAV,
        69634 => AV_CODEC_ID_ADPCM_IMA_DK3,
        69635 => AV_CODEC_ID_ADPCM_IMA_DK4,
        69636 => AV_CODEC_ID_ADPCM_IMA_WS,
        69637 => AV_CODEC_ID_ADPCM_IMA_SMJPEG,
        69638 => AV_CODEC_ID_ADPCM_MS,
        69639 => AV_CODEC_ID_ADPCM_4XM,
        69640 => AV_CODEC_ID_ADPCM_XA,
        69641 => AV_CODEC_ID_ADPCM_ADX,
        69642 => AV_CODEC_ID_ADPCM_EA,
        69643 => AV_CODEC_ID_ADPCM_G726,
        69644 => AV_CODEC_ID_ADPCM_CT,
        69645 => AV_CODEC_ID_ADPCM_SWF,
        69646 => AV_CODEC_ID_ADPCM_YAMAHA,
        69647 => AV_CODEC_ID_ADPCM_SBPRO_4,
        69648 => AV_CODEC_ID_ADPCM_SBPRO_3,
        69649 => AV_CODEC_ID_ADPCM_SBPRO_2,
        69650 => AV_CODEC_ID_ADPCM_THP,
        69651 => AV_CODEC_ID_ADPCM_IMA_AMV,
        69652 => AV_CODEC_ID_ADPCM_EA_R1,
        69653 => AV_CODEC_ID_ADPCM_EA_R3,
        69654 => AV_CODEC_ID_ADPCM_EA_R2,
        69655 => AV_CODEC_ID_ADPCM_IMA_EA_SEAD,
        69656 => AV_CODEC_ID_ADPCM_IMA_EA_EACS,
        69657 => AV_CODEC_ID_ADPCM_EA_XAS,
        69658 => AV_CODEC_ID_ADPCM_EA_MAXIS_XA,
        69659 => AV_CODEC_ID_ADPCM_IMA_ISS,
        69660 => AV_CODEC_ID_ADPCM_G722,
        69661 => AV_CODEC_ID_ADPCM_IMA_APC,
        69662 => AV_CODEC_ID_ADPCM_VIMA,
        69663 => AV_CODEC_ID_ADPCM_AFC,
        69664 => AV_CODEC_ID_ADPCM_IMA_OKI,
        69665 => AV_CODEC_ID_ADPCM_DTK,
        69666 => AV_CODEC_ID_ADPCM_IMA_RAD,
        69667 => AV_CODEC_ID_ADPCM_G726LE,
        69668 => AV_CODEC_ID_ADPCM_THP_LE,
        69669 => AV_CODEC_ID_ADPCM_PSX,
        69670 => AV_CODEC_ID_ADPCM_AICA,
        69671 => AV_CODEC_ID_ADPCM_IMA_DAT4,
        69672 => AV_CODEC_ID_ADPCM_MTAF,
        69673 => AV_CODEC_ID_ADPCM_AGM,
        69674 => AV_CODEC_ID_ADPCM_ARGO,
        69675 => AV_CODEC_ID_ADPCM_IMA_SSI,
        69676 => AV_CODEC_ID_ADPCM_ZORK,
        69677 => AV_CODEC_ID_ADPCM_IMA_APM,
        69678 => AV_CODEC_ID_ADPCM_IMA_ALP,
        69679 => AV_CODEC_ID_ADPCM_IMA_MTF,
        69680 => AV_CODEC_ID_ADPCM_IMA_CUNNING,
        69681 => AV_CODEC_ID_ADPCM_IMA_MOFLEX,
        69682 => AV_CODEC_ID_ADPCM_IMA_ACORN,
        69683 => AV_CODEC_ID_ADPCM_XMD,
        73728 => AV_CODEC_ID_AMR_NB,
        73729 => AV_CODEC_ID_AMR_WB,
        77824 => AV_CODEC_ID_RA_144,
        77825 => AV_CODEC_ID_RA_288,
        81920 => AV_CODEC_ID_ROQ_DPCM,
        81921 => AV_CODEC_ID_INTERPLAY_DPCM,
        81922 => AV_CODEC_ID_XAN_DPCM,
        81923 => AV_CODEC_ID_SOL_DPCM,
        81924 => AV_CODEC_ID_SDX2_DPCM,
        81925 => AV_CODEC_ID_GREMLIN_DPCM,
        81926 => AV_CODEC_ID_DERF_DPCM,
        81927 => AV_CODEC_ID_WADY_DPCM,
        81928 => AV_CODEC_ID_CBD2_DPCM,
        86016 => AV_CODEC_ID_MP2,
        86017 => AV_CODEC_ID_MP3,
        86018 => AV_CODEC_ID_AAC,
        86019 => AV_CODEC_ID_AC3,
        86020 => AV_CODEC_ID_DTS,
        86021 => AV_CODEC_ID_VORBIS,
        86022 => AV_CODEC_ID_DVAUDIO,
        86023 => AV_CODEC_ID_WMAV1,
        86024 => AV_CODEC_ID_WMAV2,
        86025 => AV_CODEC_ID_MACE3,
        86026 => AV_CODEC_ID_MACE6,
        86027 => AV_CODEC_ID_VMDAUDIO,
        86028 => AV_CODEC_ID_FLAC,
        86029 => AV_CODEC_ID_MP3ADU,
        86030 => AV_CODEC_ID_MP3ON4,
        86031 => AV_CODEC_ID_SHORTEN,
        86032 => AV_CODEC_ID_ALAC,
        86033 => AV_CODEC_ID_WESTWOOD_SND1,
        86034 => AV_CODEC_ID_GSM,
        86035 => AV_CODEC_ID_QDM2,
        86036 => AV_CODEC_ID_COOK,
        86037 => AV_CODEC_ID_TRUESPEECH,
        86038 => AV_CODEC_ID_TTA,
        86039 => AV_CODEC_ID_SMACKAUDIO,
        86040 => AV_CODEC_ID_QCELP,
        86041 => AV_CODEC_ID_WAVPACK,
        86042 => AV_CODEC_ID_DSICINAUDIO,
        86043 => AV_CODEC_ID_IMC,
        86044 => AV_CODEC_ID_MUSEPACK7,
        86045 => AV_CODEC_ID_MLP,
        86046 => AV_CODEC_ID_GSM_MS,
        86047 => AV_CODEC_ID_ATRAC3,
        86048 => AV_CODEC_ID_APE,
        86049 => AV_CODEC_ID_NELLYMOSER,
        86050 => AV_CODEC_ID_MUSEPACK8,
        86051 => AV_CODEC_ID_SPEEX,
        86052 => AV_CODEC_ID_WMAVOICE,
        86053 => AV_CODEC_ID_WMAPRO,
        86054 => AV_CODEC_ID_WMALOSSLESS,
        86055 => AV_CODEC_ID_ATRAC3P,
        86056 => AV_CODEC_ID_EAC3,
        86057 => AV_CODEC_ID_SIPR,
        86058 => AV_CODEC_ID_MP1,
        86059 => AV_CODEC_ID_TWINVQ,
        86060 => AV_CODEC_ID_TRUEHD,
        86061 => AV_CODEC_ID_MP4ALS,
        86062 => AV_CODEC_ID_ATRAC1,
        86063 => AV_CODEC_ID_BINKAUDIO_RDFT,
        86064 => AV_CODEC_ID_BINKAUDIO_DCT,
        86065 => AV_CODEC_ID_AAC_LATM,
        86066 => AV_CODEC_ID_QDMC,
        86067 => AV_CODEC_ID_CELT,
        86068 => AV_CODEC_ID_G723_1,
        86069 => AV_CODEC_ID_G729,
        86070 => AV_CODEC_ID_8SVX_EXP,
        86071 => AV_CODEC_ID_8SVX_FIB,
        86072 => AV_CODEC_ID_BMV_AUDIO,
        86073 => AV_CODEC_ID_RALF,
        86074 => AV_CODEC_ID_IAC,
        86075 => AV_CODEC_ID_ILBC,
        86076 => AV_CODEC_ID_OPUS,
        86077 => AV_CODEC_ID_COMFORT_NOISE,
        86078 => AV_CODEC_ID_TAK,
        86079 => AV_CODEC_ID_METASOUND,
        86080 => AV_CODEC_ID_PAF_AUDIO,
        86081 => AV_CODEC_ID_ON2AVC,
        86082 => AV_CODEC_ID_DSS_SP,
        86083 => AV_CODEC_ID_CODEC2,
        86084 => AV_CODEC_ID_FFWAVESYNTH,
        86085 => AV_CODEC_ID_SONIC,
        86086 => AV_CODEC_ID_SONIC_LS,
        86087 => AV_CODEC_ID_EVRC,
        86088 => AV_CODEC_ID_SMV,
        86089 => AV_CODEC_ID_DSD_LSBF,
        86090 => AV_CODEC_ID_DSD_MSBF,
        86091 => AV_CODEC_ID_DSD_LSBF_PLANAR,
        86092 => AV_CODEC_ID_DSD_MSBF_PLANAR,
        86093 => AV_CODEC_ID_4GV,
        86094 => AV_CODEC_ID_INTERPLAY_ACM,
        86095 => AV_CODEC_ID_XMA1,
        86096 => AV_CODEC_ID_XMA2,
        86097 => AV_CODEC_ID_DST,
        86098 => AV_CODEC_ID_ATRAC3AL,
        86099 => AV_CODEC_ID_ATRAC3PAL,
        86100 => AV_CODEC_ID_DOLBY_E,
        86101 => AV_CODEC_ID_APTX,
        86102 => AV_CODEC_ID_APTX_HD,
        86103 => AV_CODEC_ID_SBC,
        86104 => AV_CODEC_ID_ATRAC9,
        86105 => AV_CODEC_ID_HCOM,
        86106 => AV_CODEC_ID_ACELP_KELVIN,
        86107 => AV_CODEC_ID_MPEGH_3D_AUDIO,
        86108 => AV_CODEC_ID_SIREN,
        86109 => AV_CODEC_ID_HCA,
        86110 => AV_CODEC_ID_FASTAUDIO,
        86111 => AV_CODEC_ID_MSNSIREN,
        86112 => AV_CODEC_ID_DFPWM,
        86113 => AV_CODEC_ID_BONK,
        86114 => AV_CODEC_ID_MISC4,
        86115 => AV_CODEC_ID_APAC,
        86116 => AV_CODEC_ID_FTR,
        86117 => AV_CODEC_ID_WAVARC,
        86118 => AV_CODEC_ID_RKA,
        86119 => AV_CODEC_ID_AC4,
        86120 => AV_CODEC_ID_OSQ,
        86121 => AV_CODEC_ID_QOA,
        86122 => AV_CODEC_ID_LC3,
        94208 => AV_CODEC_ID_FIRST_SUBTITLE,
        94209 => AV_CODEC_ID_DVB_SUBTITLE,
        94210 => AV_CODEC_ID_TEXT,
        94211 => AV_CODEC_ID_XSUB,
        94212 => AV_CODEC_ID_SSA,
        94213 => AV_CODEC_ID_MOV_TEXT,
        94214 => AV_CODEC_ID_HDMV_PGS_SUBTITLE,
        94215 => AV_CODEC_ID_DVB_TELETEXT,
        94216 => AV_CODEC_ID_SRT,
        94217 => AV_CODEC_ID_MICRODVD,
        94218 => AV_CODEC_ID_EIA_608,
        94219 => AV_CODEC_ID_JACOSUB,
        94220 => AV_CODEC_ID_SAMI,
        94221 => AV_CODEC_ID_REALTEXT,
        94222 => AV_CODEC_ID_STL,
        94223 => AV_CODEC_ID_SUBVIEWER1,
        94224 => AV_CODEC_ID_SUBVIEWER,
        94225 => AV_CODEC_ID_SUBRIP,
        94226 => AV_CODEC_ID_WEBVTT,
        94227 => AV_CODEC_ID_MPL2,
        94228 => AV_CODEC_ID_VPLAYER,
        94229 => AV_CODEC_ID_PJS,
        94230 => AV_CODEC_ID_ASS,
        94231 => AV_CODEC_ID_HDMV_TEXT_SUBTITLE,
        94232 => AV_CODEC_ID_TTML,
        94233 => AV_CODEC_ID_ARIB_CAPTION,
        98304 => AV_CODEC_ID_FIRST_UNKNOWN,
        98305 => AV_CODEC_ID_SCTE_35,
        98306 => AV_CODEC_ID_EPG,
        98307 => AV_CODEC_ID_BINTEXT,
        98308 => AV_CODEC_ID_XBIN,
        98309 => AV_CODEC_ID_IDF,
        98310 => AV_CODEC_ID_OTF,
        98311 => AV_CODEC_ID_SMPTE_KLV,
        98312 => AV_CODEC_ID_DVD_NAV,
        98313 => AV_CODEC_ID_TIMED_ID3,
        98314 => AV_CODEC_ID_BIN_DATA,
        98315 => AV_CODEC_ID_SMPTE_2038,
        98316 => AV_CODEC_ID_LCEVC,
        102400 => AV_CODEC_ID_PROBE,
        131072 => AV_CODEC_ID_MPEG2TS,
        131073 => AV_CODEC_ID_MPEG4SYSTEMS,
        135168 => AV_CODEC_ID_FFMETADATA,
        135169 => AV_CODEC_ID_WRAPPED_AVFRAME,
        135170 => AV_CODEC_ID_VNULL,
        135171 => AV_CODEC_ID_ANULL,
        _ => throw ArgumentError("Unknown value for AVCodecID: $value"),
      };

  @override
  String toString() {
    if (this == AV_CODEC_ID_FIRST_AUDIO)
      return "AVCodecID.AV_CODEC_ID_FIRST_AUDIO, AVCodecID.AV_CODEC_ID_PCM_S16LE";
    if (this == AV_CODEC_ID_FIRST_SUBTITLE)
      return "AVCodecID.AV_CODEC_ID_FIRST_SUBTITLE, AVCodecID.AV_CODEC_ID_DVD_SUBTITLE";
    if (this == AV_CODEC_ID_FIRST_UNKNOWN)
      return "AVCodecID.AV_CODEC_ID_FIRST_UNKNOWN, AVCodecID.AV_CODEC_ID_TTF";
    return super.toString();
  }
}

/// AVProfile.
final class AVProfile extends ffi.Struct {
  @ffi.Int()
  external int profile;

  /// < short name for the profile
  external ffi.Pointer<ffi.Char> name;
}

/// AVCodec.
final class AVCodec extends ffi.Struct {
  /// Name of the codec implementation.
  /// The name is globally unique among encoders and among decoders (but an
  /// encoder and a decoder can share the same name).
  /// This is the primary way to find a codec from the user perspective.
  external ffi.Pointer<ffi.Char> name;

  /// Descriptive name for the codec, meant to be more human readable than name.
  /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
  external ffi.Pointer<ffi.Char> long_name;

  @ffi.Int()
  external int typeAsInt;

  AVMediaType get type => AVMediaType.fromValue(typeAsInt);

  @ffi.UnsignedInt()
  external int idAsInt;

  AVCodecID get id => AVCodecID.fromValue(idAsInt);

  /// Codec capabilities.
  /// see AV_CODEC_CAP_*
  @ffi.Int()
  external int capabilities;

  /// < maximum value for lowres supported by the decoder
  @ffi.Uint8()
  external int max_lowres;

  /// < @deprecated use avcodec_get_supported_config()
  external ffi.Pointer<AVRational> supported_framerates;

  /// < @deprecated use avcodec_get_supported_config()
  external ffi.Pointer<ffi.Int> pix_fmts;

  /// < @deprecated use avcodec_get_supported_config()
  external ffi.Pointer<ffi.Int> supported_samplerates;

  /// < @deprecated use avcodec_get_supported_config()
  external ffi.Pointer<ffi.Int> sample_fmts;

  /// < AVClass for the private context
  external ffi.Pointer<AVClass> priv_class;

  /// < array of recognized profiles, or NULL if unknown, array is terminated by {AV_PROFILE_UNKNOWN}
  external ffi.Pointer<AVProfile> profiles;

  /// Group name of the codec implementation.
  /// This is a short symbolic name of the wrapper backing this codec. A
  /// wrapper uses some kind of external implementation for the codec, such
  /// as an external library, or a codec implementation provided by the OS or
  /// the hardware.
  /// If this field is NULL, this is a builtin, libavcodec native codec.
  /// If non-NULL, this will be the suffix in AVCodec.name in most cases
  /// (usually AVCodec.name will be of the form "<codec_name>_<wrapper_name>").
  external ffi.Pointer<ffi.Char> wrapper_name;

  /// Array of supported channel layouts, terminated with a zeroed layout.
  /// @deprecated use avcodec_get_supported_config()
  external ffi.Pointer<AVChannelLayout> ch_layouts;
}

final class AVCodecHWConfig extends ffi.Struct {
  /// For decoders, a hardware pixel format which that decoder may be
  /// able to decode to if suitable hardware is available.
  ///
  /// For encoders, a pixel format which the encoder may be able to
  /// accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel
  /// formats supported by the codec.
  @ffi.Int()
  external int pix_fmtAsInt;

  AVPixelFormat get pix_fmt => AVPixelFormat.fromValue(pix_fmtAsInt);

  /// Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible
  /// setup methods which can be used with this configuration.
  @ffi.Int()
  external int methods;

  /// The device type associated with the configuration.
  ///
  /// Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and
  /// AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused.
  @ffi.UnsignedInt()
  external int device_typeAsInt;

  AVHWDeviceType get device_type => AVHWDeviceType.fromValue(device_typeAsInt);
}

enum AVFieldOrder {
  AV_FIELD_UNKNOWN(0),
  AV_FIELD_PROGRESSIVE(1),

  /// < Top coded_first, top displayed first
  AV_FIELD_TT(2),

  /// < Bottom coded first, bottom displayed first
  AV_FIELD_BB(3),

  /// < Top coded first, bottom displayed first
  AV_FIELD_TB(4),

  /// < Bottom coded first, top displayed first
  AV_FIELD_BT(5);

  final int value;
  const AVFieldOrder(this.value);

  static AVFieldOrder fromValue(int value) => switch (value) {
        0 => AV_FIELD_UNKNOWN,
        1 => AV_FIELD_PROGRESSIVE,
        2 => AV_FIELD_TT,
        3 => AV_FIELD_BB,
        4 => AV_FIELD_TB,
        5 => AV_FIELD_BT,
        _ => throw ArgumentError("Unknown value for AVFieldOrder: $value"),
      };
}

/// @ingroup lavc_decoding
enum AVDiscard {
  /// < discard nothing
  AVDISCARD_NONE(-16),

  /// < discard useless packets like 0 size packets in avi
  AVDISCARD_DEFAULT(0),

  /// < discard all non reference
  AVDISCARD_NONREF(8),

  /// < discard all bidirectional frames
  AVDISCARD_BIDIR(16),

  /// < discard all non intra frames
  AVDISCARD_NONINTRA(24),

  /// < discard all frames except keyframes
  AVDISCARD_NONKEY(32),

  /// < discard all
  AVDISCARD_ALL(48);

  final int value;
  const AVDiscard(this.value);

  static AVDiscard fromValue(int value) => switch (value) {
        -16 => AVDISCARD_NONE,
        0 => AVDISCARD_DEFAULT,
        8 => AVDISCARD_NONREF,
        16 => AVDISCARD_BIDIR,
        24 => AVDISCARD_NONINTRA,
        32 => AVDISCARD_NONKEY,
        48 => AVDISCARD_ALL,
        _ => throw ArgumentError("Unknown value for AVDiscard: $value"),
      };
}

enum AVAudioServiceType {
  AV_AUDIO_SERVICE_TYPE_MAIN(0),
  AV_AUDIO_SERVICE_TYPE_EFFECTS(1),
  AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED(2),
  AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED(3),
  AV_AUDIO_SERVICE_TYPE_DIALOGUE(4),
  AV_AUDIO_SERVICE_TYPE_COMMENTARY(5),
  AV_AUDIO_SERVICE_TYPE_EMERGENCY(6),
  AV_AUDIO_SERVICE_TYPE_VOICE_OVER(7),
  AV_AUDIO_SERVICE_TYPE_KARAOKE(8),

  /// < Not part of ABI
  AV_AUDIO_SERVICE_TYPE_NB(9);

  final int value;
  const AVAudioServiceType(this.value);

  static AVAudioServiceType fromValue(int value) => switch (value) {
        0 => AV_AUDIO_SERVICE_TYPE_MAIN,
        1 => AV_AUDIO_SERVICE_TYPE_EFFECTS,
        2 => AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED,
        3 => AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED,
        4 => AV_AUDIO_SERVICE_TYPE_DIALOGUE,
        5 => AV_AUDIO_SERVICE_TYPE_COMMENTARY,
        6 => AV_AUDIO_SERVICE_TYPE_EMERGENCY,
        7 => AV_AUDIO_SERVICE_TYPE_VOICE_OVER,
        8 => AV_AUDIO_SERVICE_TYPE_KARAOKE,
        9 => AV_AUDIO_SERVICE_TYPE_NB,
        _ =>
          throw ArgumentError("Unknown value for AVAudioServiceType: $value"),
      };
}

/// Pan Scan area.
/// This specifies the area which should be displayed.
/// Note there may be multiple such areas for one frame.
final class AVPanScan extends ffi.Struct {
  /// id
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  @ffi.Int()
  external int id;

  /// width and height in 1/16 pel
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// position of the top left corner in 1/16 pel for up to 3 fields/frames
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  @ffi.Array.multi([3, 2])
  external ffi.Array<ffi.Array<ffi.Int16>> position;
}

/// This structure describes the bitrate properties of an encoded bitstream. It
/// roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
/// parameters for H.264/HEVC.
final class AVCPBProperties extends ffi.Struct {
  /// Maximum bitrate of the stream, in bits per second.
  /// Zero if unknown or unspecified.
  @ffi.Int64()
  external int max_bitrate;

  /// Minimum bitrate of the stream, in bits per second.
  /// Zero if unknown or unspecified.
  @ffi.Int64()
  external int min_bitrate;

  /// Average bitrate of the stream, in bits per second.
  /// Zero if unknown or unspecified.
  @ffi.Int64()
  external int avg_bitrate;

  /// The size of the buffer to which the ratecontrol is applied, in bits.
  /// Zero if unknown or unspecified.
  @ffi.Int64()
  external int buffer_size;

  /// The delay between the time the packet this structure is associated with
  /// is received and the time when it should be decoded, in periods of a 27MHz
  /// clock.
  ///
  /// UINT64_MAX when unknown or unspecified.
  @ffi.Uint64()
  external int vbv_delay;
}

/// This structure supplies correlation between a packet timestamp and a wall clock
/// production time. The definition follows the Producer Reference Time ('prft')
/// as defined in ISO/IEC 14496-12
final class AVProducerReferenceTime extends ffi.Struct {
  /// A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime()).
  @ffi.Int64()
  external int wallclock;

  @ffi.Int()
  external int flags;
}

/// @defgroup lavc_packet_side_data AVPacketSideData
///
/// Types and functions for working with AVPacketSideData.
/// @{
enum AVPacketSideDataType {
  /// An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
  /// bytes worth of palette. This side data signals that a new palette is
  /// present.
  AV_PKT_DATA_PALETTE(0),

  /// The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
  /// that the extradata buffer was changed and the receiving side should
  /// act upon it appropriately. The new extradata is embedded in the side
  /// data buffer and should be immediately used for processing the current
  /// frame or packet.
  AV_PKT_DATA_NEW_EXTRADATA(1),

  /// An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
  /// @code
  /// u32le param_flags
  /// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
  /// s32le sample_rate
  /// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
  /// s32le width
  /// s32le height
  /// @endcode
  AV_PKT_DATA_PARAM_CHANGE(2),

  /// An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
  /// structures with info about macroblocks relevant to splitting the
  /// packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
  /// That is, it does not necessarily contain info about all macroblocks,
  /// as long as the distance between macroblocks in the info is smaller
  /// than the target payload size.
  /// Each MB info structure is 12 bytes, and is laid out as follows:
  /// @code
  /// u32le bit offset from the start of the packet
  /// u8    current quantizer at the start of the macroblock
  /// u8    GOB number
  /// u16le macroblock address within the GOB
  /// u8    horizontal MV predictor
  /// u8    vertical MV predictor
  /// u8    horizontal MV predictor for block number 3
  /// u8    vertical MV predictor for block number 3
  /// @endcode
  AV_PKT_DATA_H263_MB_INFO(3),

  /// This side data should be associated with an audio stream and contains
  /// ReplayGain information in form of the AVReplayGain struct.
  AV_PKT_DATA_REPLAYGAIN(4),

  /// This side data contains a 3x3 transformation matrix describing an affine
  /// transformation that needs to be applied to the decoded video frames for
  /// correct presentation.
  ///
  /// See libavutil/display.h for a detailed description of the data.
  AV_PKT_DATA_DISPLAYMATRIX(5),

  /// This side data should be associated with a video stream and contains
  /// Stereoscopic 3D information in form of the AVStereo3D struct.
  AV_PKT_DATA_STEREO3D(6),

  /// This side data should be associated with an audio stream and corresponds
  /// to enum AVAudioServiceType.
  AV_PKT_DATA_AUDIO_SERVICE_TYPE(7),

  /// This side data contains quality related information from the encoder.
  /// @code
  /// u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).
  /// u8    picture type
  /// u8    error count
  /// u16   reserved
  /// u64le[error count] sum of squared differences between encoder in and output
  /// @endcode
  AV_PKT_DATA_QUALITY_STATS(8),

  /// This side data contains an integer value representing the stream index
  /// of a "fallback" track.  A fallback track indicates an alternate
  /// track to use when the current track can not be decoded for some reason.
  /// e.g. no decoder available for codec.
  AV_PKT_DATA_FALLBACK_TRACK(9),

  /// This side data corresponds to the AVCPBProperties struct.
  AV_PKT_DATA_CPB_PROPERTIES(10),

  /// Recommmends skipping the specified number of samples
  /// @code
  /// u32le number of samples to skip from start of this packet
  /// u32le number of samples to skip from end of this packet
  /// u8    reason for start skip
  /// u8    reason for end   skip (0=padding silence, 1=convergence)
  /// @endcode
  AV_PKT_DATA_SKIP_SAMPLES(11),

  /// An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
  /// the packet may contain "dual mono" audio specific to Japanese DTV
  /// and if it is true, recommends only the selected channel to be used.
  /// @code
  /// u8    selected channels (0=main/left, 1=sub/right, 2=both)
  /// @endcode
  AV_PKT_DATA_JP_DUALMONO(12),

  /// A list of zero terminated key/value strings. There is no end marker for
  /// the list, so it is required to rely on the side data size to stop.
  AV_PKT_DATA_STRINGS_METADATA(13),

  /// Subtitle event position
  /// @code
  /// u32le x1
  /// u32le y1
  /// u32le x2
  /// u32le y2
  /// @endcode
  AV_PKT_DATA_SUBTITLE_POSITION(14),

  /// Data found in BlockAdditional element of matroska container. There is
  /// no end marker for the data, so it is required to rely on the side data
  /// size to recognize the end. 8 byte id (as found in BlockAddId) followed
  /// by data.
  AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL(15),

  /// The optional first identifier line of a WebVTT cue.
  AV_PKT_DATA_WEBVTT_IDENTIFIER(16),

  /// The optional settings (rendering instructions) that immediately
  /// follow the timestamp specifier of a WebVTT cue.
  AV_PKT_DATA_WEBVTT_SETTINGS(17),

  /// A list of zero terminated key/value strings. There is no end marker for
  /// the list, so it is required to rely on the side data size to stop. This
  /// side data includes updated metadata which appeared in the stream.
  AV_PKT_DATA_METADATA_UPDATE(18),

  /// MPEGTS stream ID as uint8_t, this is required to pass the stream ID
  /// information from the demuxer to the corresponding muxer.
  AV_PKT_DATA_MPEGTS_STREAM_ID(19),

  /// Mastering display metadata (based on SMPTE-2086:2014). This metadata
  /// should be associated with a video stream and contains data in the form
  /// of the AVMasteringDisplayMetadata struct.
  AV_PKT_DATA_MASTERING_DISPLAY_METADATA(20),

  /// This side data should be associated with a video stream and corresponds
  /// to the AVSphericalMapping structure.
  AV_PKT_DATA_SPHERICAL(21),

  /// Content light level (based on CTA-861.3). This metadata should be
  /// associated with a video stream and contains data in the form of the
  /// AVContentLightMetadata struct.
  AV_PKT_DATA_CONTENT_LIGHT_LEVEL(22),

  /// ATSC A53 Part 4 Closed Captions. This metadata should be associated with
  /// a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.
  /// The number of bytes of CC data is AVPacketSideData.size.
  AV_PKT_DATA_A53_CC(23),

  /// This side data is encryption initialization data.
  /// The format is not part of ABI, use av_encryption_init_info_* methods to
  /// access.
  AV_PKT_DATA_ENCRYPTION_INIT_INFO(24),

  /// This side data contains encryption info for how to decrypt the packet.
  /// The format is not part of ABI, use av_encryption_info_* methods to access.
  AV_PKT_DATA_ENCRYPTION_INFO(25),

  /// Active Format Description data consisting of a single byte as specified
  /// in ETSI TS 101 154 using AVActiveFormatDescription enum.
  AV_PKT_DATA_AFD(26),

  /// Producer Reference Time data corresponding to the AVProducerReferenceTime struct,
  /// usually exported by some encoders (on demand through the prft flag set in the
  /// AVCodecContext export_side_data field).
  AV_PKT_DATA_PRFT(27),

  /// ICC profile data consisting of an opaque octet buffer following the
  /// format described by ISO 15076-1.
  AV_PKT_DATA_ICC_PROFILE(28),

  /// DOVI configuration
  /// ref:
  /// dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2
  /// dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3
  /// Tags are stored in struct AVDOVIDecoderConfigurationRecord.
  AV_PKT_DATA_DOVI_CONF(29),

  /// Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t
  /// where the first uint32_t describes how many (1-3) of the other timecodes are used.
  /// The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()
  /// function in libavutil/timecode.h.
  AV_PKT_DATA_S12M_TIMECODE(30),

  /// HDR10+ dynamic metadata associated with a video frame. The metadata is in
  /// the form of the AVDynamicHDRPlus struct and contains
  /// information for color volume transform - application 4 of
  /// SMPTE 2094-40:2016 standard.
  AV_PKT_DATA_DYNAMIC_HDR10_PLUS(31),

  /// IAMF Mix Gain Parameter Data associated with the audio frame. This metadata
  /// is in the form of the AVIAMFParamDefinition struct and contains information
  /// defined in sections 3.6.1 and 3.8.1 of the Immersive Audio Model and
  /// Formats standard.
  AV_PKT_DATA_IAMF_MIX_GAIN_PARAM(32),

  /// IAMF Demixing Info Parameter Data associated with the audio frame. This
  /// metadata is in the form of the AVIAMFParamDefinition struct and contains
  /// information defined in sections 3.6.1 and 3.8.2 of the Immersive Audio Model
  /// and Formats standard.
  AV_PKT_DATA_IAMF_DEMIXING_INFO_PARAM(33),

  /// IAMF Recon Gain Info Parameter Data associated with the audio frame. This
  /// metadata is in the form of the AVIAMFParamDefinition struct and contains
  /// information defined in sections 3.6.1 and 3.8.3 of the Immersive Audio Model
  /// and Formats standard.
  AV_PKT_DATA_IAMF_RECON_GAIN_INFO_PARAM(34),

  /// Ambient viewing environment metadata, as defined by H.274. This metadata
  /// should be associated with a video stream and contains data in the form
  /// of the AVAmbientViewingEnvironment struct.
  AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT(35),

  /// The number of pixels to discard from the top/bottom/left/right border of the
  /// decoded frame to obtain the sub-rectangle intended for presentation.
  ///
  /// @code
  /// u32le crop_top
  /// u32le crop_bottom
  /// u32le crop_left
  /// u32le crop_right
  /// @endcode
  AV_PKT_DATA_FRAME_CROPPING(36),

  /// Raw LCEVC payload data, as a uint8_t array, with NAL emulation
  /// bytes intact.
  AV_PKT_DATA_LCEVC(37),

  /// The number of side data types.
  /// This is not part of the public API/ABI in the sense that it may
  /// change when new side data types are added.
  /// This must stay the last enum value.
  /// If its value becomes huge, some code using it
  /// needs to be updated as it assumes it to be smaller than other limits.
  AV_PKT_DATA_NB(38);

  final int value;
  const AVPacketSideDataType(this.value);

  static AVPacketSideDataType fromValue(int value) => switch (value) {
        0 => AV_PKT_DATA_PALETTE,
        1 => AV_PKT_DATA_NEW_EXTRADATA,
        2 => AV_PKT_DATA_PARAM_CHANGE,
        3 => AV_PKT_DATA_H263_MB_INFO,
        4 => AV_PKT_DATA_REPLAYGAIN,
        5 => AV_PKT_DATA_DISPLAYMATRIX,
        6 => AV_PKT_DATA_STEREO3D,
        7 => AV_PKT_DATA_AUDIO_SERVICE_TYPE,
        8 => AV_PKT_DATA_QUALITY_STATS,
        9 => AV_PKT_DATA_FALLBACK_TRACK,
        10 => AV_PKT_DATA_CPB_PROPERTIES,
        11 => AV_PKT_DATA_SKIP_SAMPLES,
        12 => AV_PKT_DATA_JP_DUALMONO,
        13 => AV_PKT_DATA_STRINGS_METADATA,
        14 => AV_PKT_DATA_SUBTITLE_POSITION,
        15 => AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
        16 => AV_PKT_DATA_WEBVTT_IDENTIFIER,
        17 => AV_PKT_DATA_WEBVTT_SETTINGS,
        18 => AV_PKT_DATA_METADATA_UPDATE,
        19 => AV_PKT_DATA_MPEGTS_STREAM_ID,
        20 => AV_PKT_DATA_MASTERING_DISPLAY_METADATA,
        21 => AV_PKT_DATA_SPHERICAL,
        22 => AV_PKT_DATA_CONTENT_LIGHT_LEVEL,
        23 => AV_PKT_DATA_A53_CC,
        24 => AV_PKT_DATA_ENCRYPTION_INIT_INFO,
        25 => AV_PKT_DATA_ENCRYPTION_INFO,
        26 => AV_PKT_DATA_AFD,
        27 => AV_PKT_DATA_PRFT,
        28 => AV_PKT_DATA_ICC_PROFILE,
        29 => AV_PKT_DATA_DOVI_CONF,
        30 => AV_PKT_DATA_S12M_TIMECODE,
        31 => AV_PKT_DATA_DYNAMIC_HDR10_PLUS,
        32 => AV_PKT_DATA_IAMF_MIX_GAIN_PARAM,
        33 => AV_PKT_DATA_IAMF_DEMIXING_INFO_PARAM,
        34 => AV_PKT_DATA_IAMF_RECON_GAIN_INFO_PARAM,
        35 => AV_PKT_DATA_AMBIENT_VIEWING_ENVIRONMENT,
        36 => AV_PKT_DATA_FRAME_CROPPING,
        37 => AV_PKT_DATA_LCEVC,
        38 => AV_PKT_DATA_NB,
        _ =>
          throw ArgumentError("Unknown value for AVPacketSideDataType: $value"),
      };
}

/// This structure stores auxiliary information for decoding, presenting, or
/// otherwise processing the coded stream. It is typically exported by demuxers
/// and encoders and can be fed to decoders and muxers either in a per packet
/// basis, or as global side data (applying to the entire coded stream).
///
/// Global side data is handled as follows:
/// - During demuxing, it may be exported through
/// @ref AVStream.codecpar.side_data "AVStream's codec parameters", which can
/// then be passed as input to decoders through the
/// @ref AVCodecContext.coded_side_data "decoder context's side data", for
/// initialization.
/// - For muxing, it can be fed through @ref AVStream.codecpar.side_data
/// "AVStream's codec parameters", typically  the output of encoders through
/// the @ref AVCodecContext.coded_side_data "encoder context's side data", for
/// initialization.
///
/// Packet specific side data is handled as follows:
/// - During demuxing, it may be exported through @ref AVPacket.side_data
/// "AVPacket's side data", which can then be passed as input to decoders.
/// - For muxing, it can be fed through @ref AVPacket.side_data "AVPacket's
/// side data", typically the output of encoders.
///
/// Different modules may accept or export different types of side data
/// depending on media type and codec. Refer to @ref AVPacketSideDataType for a
/// list of defined types and where they may be found or used.
final class AVPacketSideData extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Size()
  external int size;

  @ffi.UnsignedInt()
  external int typeAsInt;

  AVPacketSideDataType get type => AVPacketSideDataType.fromValue(typeAsInt);
}

/// This structure stores compressed data. It is typically exported by demuxers
/// and then passed as input to decoders, or received as output from encoders and
/// then passed to muxers.
///
/// For video, it should typically contain one compressed frame. For audio it may
/// contain several compressed frames. Encoders are allowed to output empty
/// packets, with no compressed data, containing only side data
/// (e.g. to update some stream parameters at the end of encoding).
///
/// The semantics of data ownership depends on the buf field.
/// If it is set, the packet data is dynamically allocated and is
/// valid indefinitely until a call to av_packet_unref() reduces the
/// reference count to 0.
///
/// If the buf field is not set av_packet_ref() would make a copy instead
/// of increasing the reference count.
///
/// The side data is always allocated with av_malloc(), copied by
/// av_packet_ref() and freed by av_packet_unref().
///
/// sizeof(AVPacket) being a part of the public ABI is deprecated. once
/// av_init_packet() is removed, new packets will only be able to be allocated
/// with av_packet_alloc(), and new fields may be added to the end of the struct
/// with a minor bump.
///
/// @see av_packet_alloc
/// @see av_packet_ref
/// @see av_packet_unref
final class AVPacket extends ffi.Struct {
  /// A reference to the reference-counted buffer where the packet data is
  /// stored.
  /// May be NULL, then the packet data is not reference-counted.
  external ffi.Pointer<AVBufferRef> buf;

  /// Presentation timestamp in AVStream->time_base units; the time at which
  /// the decompressed packet will be presented to the user.
  /// Can be AV_NOPTS_VALUE if it is not stored in the file.
  /// pts MUST be larger or equal to dts as presentation cannot happen before
  /// decompression, unless one wants to view hex dumps. Some formats misuse
  /// the terms dts and pts/cts to mean something different. Such timestamps
  /// must be converted to true pts/dts before they are stored in AVPacket.
  @ffi.Int64()
  external int pts;

  /// Decompression timestamp in AVStream->time_base units; the time at which
  /// the packet is decompressed.
  /// Can be AV_NOPTS_VALUE if it is not stored in the file.
  @ffi.Int64()
  external int dts;

  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Int()
  external int size;

  @ffi.Int()
  external int stream_index;

  /// A combination of AV_PKT_FLAG values
  @ffi.Int()
  external int flags;

  /// Additional packet data that can be provided by the container.
  /// Packet can contain several types of side information.
  external ffi.Pointer<AVPacketSideData> side_data;

  @ffi.Int()
  external int side_data_elems;

  /// Duration of this packet in AVStream->time_base units, 0 if unknown.
  /// Equals next_pts - this_pts in presentation order.
  @ffi.Int64()
  external int duration;

  /// < byte position in stream, -1 if unknown
  @ffi.Int64()
  external int pos;

  /// for some private data of the user
  external ffi.Pointer<ffi.Void> opaque;

  /// AVBufferRef for free use by the API user. FFmpeg will never check the
  /// contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
  /// the packet is unreferenced. av_packet_copy_props() calls create a new
  /// reference with av_buffer_ref() for the target packet's opaque_ref field.
  ///
  /// This is unrelated to the opaque field, although it serves a similar
  /// purpose.
  external ffi.Pointer<AVBufferRef> opaque_ref;

  /// Time base of the packet's timestamps.
  /// In the future, this field may be set on packets output by encoders or
  /// demuxers, but its value will be by default ignored on input to decoders
  /// or muxers.
  external AVRational time_base;
}

final class AVPacketList extends ffi.Struct {
  external AVPacket pkt;

  external ffi.Pointer<AVPacketList> next;
}

enum AVSideDataParamChangeFlags {
  AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE(4),
  AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS(8);

  final int value;
  const AVSideDataParamChangeFlags(this.value);

  static AVSideDataParamChangeFlags fromValue(int value) => switch (value) {
        4 => AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE,
        8 => AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS,
        _ => throw ArgumentError(
            "Unknown value for AVSideDataParamChangeFlags: $value"),
      };
}

/// This struct describes the properties of a single codec described by an
/// AVCodecID.
/// @see avcodec_descriptor_get()
final class AVCodecDescriptor extends ffi.Struct {
  @ffi.UnsignedInt()
  external int idAsInt;

  AVCodecID get id => AVCodecID.fromValue(idAsInt);

  @ffi.Int()
  external int typeAsInt;

  AVMediaType get type => AVMediaType.fromValue(typeAsInt);

  /// Name of the codec described by this descriptor. It is non-empty and
  /// unique for each codec descriptor. It should contain alphanumeric
  /// characters and '_' only.
  external ffi.Pointer<ffi.Char> name;

  /// A more descriptive name for this codec. May be NULL.
  external ffi.Pointer<ffi.Char> long_name;

  /// Codec properties, a combination of AV_CODEC_PROP_* flags.
  @ffi.Int()
  external int props;

  /// MIME type(s) associated with the codec.
  /// May be NULL; if not, a NULL-terminated array of MIME types.
  /// The first item is always non-NULL and is the preferred MIME type.
  external ffi.Pointer<ffi.Pointer<ffi.Char>> mime_types;

  /// If non-NULL, an array of profiles recognized for this codec.
  /// Terminated with AV_PROFILE_UNKNOWN.
  external ffi.Pointer<AVProfile> profiles;
}

/// This struct describes the properties of an encoded stream.
///
/// sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
/// be allocated with avcodec_parameters_alloc() and freed with
/// avcodec_parameters_free().
final class AVCodecParameters extends ffi.Struct {
  /// General type of the encoded data.
  @ffi.Int()
  external int codec_typeAsInt;

  AVMediaType get codec_type => AVMediaType.fromValue(codec_typeAsInt);

  /// Specific type of the encoded data (the codec used).
  @ffi.UnsignedInt()
  external int codec_idAsInt;

  AVCodecID get codec_id => AVCodecID.fromValue(codec_idAsInt);

  /// Additional information about the codec (corresponds to the AVI FOURCC).
  @ffi.Uint32()
  external int codec_tag;

  /// Extra binary data needed for initializing the decoder, codec-dependent.
  ///
  /// Must be allocated with av_malloc() and will be freed by
  /// avcodec_parameters_free(). The allocated size of extradata must be at
  /// least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
  /// bytes zeroed.
  external ffi.Pointer<ffi.Uint8> extradata;

  /// Size of the extradata content in bytes.
  @ffi.Int()
  external int extradata_size;

  /// Additional data associated with the entire stream.
  ///
  /// Should be allocated with av_packet_side_data_new() or
  /// av_packet_side_data_add(), and will be freed by avcodec_parameters_free().
  external ffi.Pointer<AVPacketSideData> coded_side_data;

  /// Amount of entries in @ref coded_side_data.
  @ffi.Int()
  external int nb_coded_side_data;

  /// - video: the pixel format, the value corresponds to enum AVPixelFormat.
  /// - audio: the sample format, the value corresponds to enum AVSampleFormat.
  @ffi.Int()
  external int format;

  /// The average bitrate of the encoded data (in bits per second).
  @ffi.Int64()
  external int bit_rate;

  /// The number of bits per sample in the codedwords.
  ///
  /// This is basically the bitrate per sample. It is mandatory for a bunch of
  /// formats to actually decode them. It's the number of bits for one sample in
  /// the actual coded bitstream.
  ///
  /// This could be for example 4 for ADPCM
  /// For PCM formats this matches bits_per_raw_sample
  /// Can be 0
  @ffi.Int()
  external int bits_per_coded_sample;

  /// This is the number of valid bits in each output sample. If the
  /// sample format has more bits, the least significant bits are additional
  /// padding bits, which are always 0. Use right shifts to reduce the sample
  /// to its actual size. For example, audio formats with 24 bit samples will
  /// have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
  /// To get the original sample use "(int32_t)sample >> 8"."
  ///
  /// For ADPCM this might be 12 or 16 or similar
  /// Can be 0
  @ffi.Int()
  external int bits_per_raw_sample;

  /// Codec-specific bitstream restrictions that the stream conforms to.
  @ffi.Int()
  external int profile;

  @ffi.Int()
  external int level;

  /// Video only. The dimensions of the video frame in pixels.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// Video only. The aspect ratio (width / height) which a single pixel
  /// should have when displayed.
  ///
  /// When the aspect ratio is unknown / undefined, the numerator should be
  /// set to 0 (the denominator may have any value).
  external AVRational sample_aspect_ratio;

  /// Video only. Number of frames per second, for streams with constant frame
  /// durations. Should be set to { 0, 1 } when some frames have differing
  /// durations or if the value is not known.
  ///
  /// @note This field correponds to values that are stored in codec-level
  /// headers and is typically overridden by container/transport-layer
  /// timestamps, when available. It should thus be used only as a last resort,
  /// when no higher-level timing information is available.
  external AVRational framerate;

  /// Video only. The order of the fields in interlaced video.
  @ffi.UnsignedInt()
  external int field_orderAsInt;

  AVFieldOrder get field_order => AVFieldOrder.fromValue(field_orderAsInt);

  /// Video only. Additional colorspace characteristics.
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  AVColorPrimaries get color_primaries =>
      AVColorPrimaries.fromValue(color_primariesAsInt);

  @ffi.UnsignedInt()
  external int color_trcAsInt;

  AVColorTransferCharacteristic get color_trc =>
      AVColorTransferCharacteristic.fromValue(color_trcAsInt);

  @ffi.UnsignedInt()
  external int color_spaceAsInt;

  AVColorSpace get color_space => AVColorSpace.fromValue(color_spaceAsInt);

  @ffi.UnsignedInt()
  external int chroma_locationAsInt;

  AVChromaLocation get chroma_location =>
      AVChromaLocation.fromValue(chroma_locationAsInt);

  /// Video only. Number of delayed frames.
  @ffi.Int()
  external int video_delay;

  /// Audio only. The channel layout and number of channels.
  external AVChannelLayout ch_layout;

  /// Audio only. The number of audio samples per second.
  @ffi.Int()
  external int sample_rate;

  /// Audio only. The number of bytes per coded audio frame, required by some
  /// formats.
  ///
  /// Corresponds to nBlockAlign in WAVEFORMATEX.
  @ffi.Int()
  external int block_align;

  /// Audio only. Audio frame size, if known. Required by some formats to be static.
  @ffi.Int()
  external int frame_size;

  /// Audio only. The amount of padding (in samples) inserted by the encoder at
  /// the beginning of the audio. I.e. this number of leading decoded samples
  /// must be discarded by the caller to get the original audio without leading
  /// padding.
  @ffi.Int()
  external int initial_padding;

  /// Audio only. The amount of padding (in samples) appended by the encoder to
  /// the end of the audio. I.e. this number of decoded samples must be
  /// discarded by the caller from the end of the stream to get the original
  /// audio without any trailing padding.
  @ffi.Int()
  external int trailing_padding;

  /// Audio only. Number of samples to skip after a discontinuity.
  @ffi.Int()
  external int seek_preroll;
}

/// @ingroup lavc_encoding
final class RcOverride extends ffi.Struct {
  @ffi.Int()
  external int start_frame;

  @ffi.Int()
  external int end_frame;

  @ffi.Int()
  external int qscale;

  @ffi.Float()
  external double quality_factor;
}

/// main external API structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
/// applications.
/// The name string for AVOptions options matches the associated command line
/// parameter name and can be found in libavcodec/options_table.h
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
/// sizeof(AVCodecContext) must not be used outside libav*.
final class AVCodecContext extends ffi.Struct {
  /// information on struct for av_log
  /// - set by avcodec_alloc_context3
  external ffi.Pointer<AVClass> av_class;

  @ffi.Int()
  external int log_level_offset;

  @ffi.Int()
  external int codec_typeAsInt;

  AVMediaType get codec_type => AVMediaType.fromValue(codec_typeAsInt);

  external ffi.Pointer<AVCodec> codec;

  @ffi.UnsignedInt()
  external int codec_idAsInt;

  AVCodecID get codec_id => AVCodecID.fromValue(codec_idAsInt);

  /// fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
  /// This is used to work around some encoder bugs.
  /// A demuxer should set this to what is stored in the field used to identify the codec.
  /// If there are multiple such fields in a container then the demuxer should choose the one
  /// which maximizes the information about the used codec.
  /// If the codec tag field in a container is larger than 32 bits then the demuxer should
  /// remap the longer ID to 32 bits with a table or other structure. Alternatively a new
  /// extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
  /// first.
  /// - encoding: Set by user, if not then the default based on codec_id will be used.
  /// - decoding: Set by user, will be converted to uppercase by libavcodec during init.
  @ffi.UnsignedInt()
  external int codec_tag;

  external ffi.Pointer<ffi.Void> priv_data;

  /// Private context used for internal data.
  ///
  /// Unlike priv_data, this is not codec-specific. It is used in general
  /// libavcodec functions.
  external ffi.Pointer<AVCodecInternal> internal;

  /// Private data of the user, can be used to carry app specific stuff.
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  external ffi.Pointer<ffi.Void> opaque;

  /// the average bitrate
  /// - encoding: Set by user; unused for constant quantizer encoding.
  /// - decoding: Set by user, may be overwritten by libavcodec
  /// if this info is available in the stream
  @ffi.Int64()
  external int bit_rate;

  /// AV_CODEC_FLAG_*.
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  @ffi.Int()
  external int flags;

  /// AV_CODEC_FLAG2_*
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  @ffi.Int()
  external int flags2;

  /// some codecs need / can use extradata like Huffman tables.
  /// MJPEG: Huffman tables
  /// rv10: additional flags
  /// MPEG-4: global headers (they can be in the bitstream or here)
  /// The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger
  /// than extradata_size to avoid problems if it is read with the bitstream reader.
  /// The bytewise contents of extradata must not depend on the architecture or CPU endianness.
  /// Must be allocated with the av_malloc() family of functions.
  /// - encoding: Set/allocated/freed by libavcodec.
  /// - decoding: Set/allocated/freed by user.
  external ffi.Pointer<ffi.Uint8> extradata;

  @ffi.Int()
  external int extradata_size;

  /// This is the fundamental unit of time (in seconds) in terms
  /// of which frame timestamps are represented. For fixed-fps content,
  /// timebase should be 1/framerate and timestamp increments should be
  /// identically 1.
  /// This often, but not always is the inverse of the frame rate or field rate
  /// for video. 1/time_base is not the average frame rate if the frame rate is not
  /// constant.
  ///
  /// Like containers, elementary streams also can store timestamps, 1/time_base
  /// is the unit in which these timestamps are specified.
  /// As example of such codec time base see ISO/IEC 14496-2:2001(E)
  /// vop_time_increment_resolution and fixed_vop_rate
  /// (fixed_vop_rate == 0 implies that it is different from the framerate)
  ///
  /// - encoding: MUST be set by user.
  /// - decoding: unused.
  external AVRational time_base;

  /// Timebase in which pkt_dts/pts and AVPacket.dts/pts are expressed.
  /// - encoding: unused.
  /// - decoding: set by user.
  external AVRational pkt_timebase;

  /// - decoding: For codecs that store a framerate value in the compressed
  /// bitstream, the decoder may export it here. { 0, 1} when
  /// unknown.
  /// - encoding: May be used to signal the framerate of CFR content to an
  /// encoder.
  external AVRational framerate;

  /// For some codecs, the time base is closer to the field rate than the frame rate.
  /// Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
  /// if no telecine is used ...
  ///
  /// Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
  ///
  /// @deprecated
  /// - decoding: Use AVCodecDescriptor.props & AV_CODEC_PROP_FIELDS
  /// - encoding: Set AVCodecContext.framerate instead
  @ffi.Int()
  external int ticks_per_frame;

  /// Codec delay.
  ///
  /// Encoding: Number of frames delay there will be from the encoder input to
  /// the decoder output. (we assume the decoder matches the spec)
  /// Decoding: Number of frames delay in addition to what a standard decoder
  /// as specified in the spec would produce.
  ///
  /// Video:
  /// Number of frames the decoded output will be delayed relative to the
  /// encoded input.
  ///
  /// Audio:
  /// For encoding, this field is unused (see initial_padding).
  ///
  /// For decoding, this is the number of samples the decoder needs to
  /// output before the decoder's output is valid. When seeking, you should
  /// start decoding this many samples prior to your desired seek point.
  ///
  /// - encoding: Set by libavcodec.
  /// - decoding: Set by libavcodec.
  @ffi.Int()
  external int delay;

  /// picture width / height.
  ///
  /// @note Those fields may not match the values of the last
  /// AVFrame output by avcodec_receive_frame() due frame
  /// reordering.
  ///
  /// - encoding: MUST be set by user.
  /// - decoding: May be set by the user before opening the decoder if known e.g.
  /// from the container. Some decoders will require the dimensions
  /// to be set by the caller. During decoding, the decoder may
  /// overwrite those values as required while parsing the data.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// Bitstream width / height, may be different from width/height e.g. when
  /// the decoded frame is cropped before being output or lowres is enabled.
  ///
  /// @note Those field may not match the value of the last
  /// AVFrame output by avcodec_receive_frame() due frame
  /// reordering.
  ///
  /// - encoding: unused
  /// - decoding: May be set by the user before opening the decoder if known
  /// e.g. from the container. During decoding, the decoder may
  /// overwrite those values as required while parsing the data.
  @ffi.Int()
  external int coded_width;

  @ffi.Int()
  external int coded_height;

  /// sample aspect ratio (0 if unknown)
  /// That is the width of a pixel divided by the height of the pixel.
  /// Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  external AVRational sample_aspect_ratio;

  /// Pixel format, see AV_PIX_FMT_xxx.
  /// May be set by the demuxer if known from headers.
  /// May be overridden by the decoder if it knows better.
  ///
  /// @note This field may not match the value of the last
  /// AVFrame output by avcodec_receive_frame() due frame
  /// reordering.
  ///
  /// - encoding: Set by user.
  /// - decoding: Set by user if known, overridden by libavcodec while
  /// parsing the data.
  @ffi.Int()
  external int pix_fmtAsInt;

  AVPixelFormat get pix_fmt => AVPixelFormat.fromValue(pix_fmtAsInt);

  /// Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
  /// - encoding: unused.
  /// - decoding: Set by libavcodec before calling get_format()
  @ffi.Int()
  external int sw_pix_fmtAsInt;

  AVPixelFormat get sw_pix_fmt => AVPixelFormat.fromValue(sw_pix_fmtAsInt);

  /// Chromaticity coordinates of the source primaries.
  /// - encoding: Set by user
  /// - decoding: Set by libavcodec
  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  AVColorPrimaries get color_primaries =>
      AVColorPrimaries.fromValue(color_primariesAsInt);

  /// Color Transfer Characteristic.
  /// - encoding: Set by user
  /// - decoding: Set by libavcodec
  @ffi.UnsignedInt()
  external int color_trcAsInt;

  AVColorTransferCharacteristic get color_trc =>
      AVColorTransferCharacteristic.fromValue(color_trcAsInt);

  /// YUV colorspace type.
  /// - encoding: Set by user
  /// - decoding: Set by libavcodec
  @ffi.UnsignedInt()
  external int colorspaceAsInt;

  AVColorSpace get colorspace => AVColorSpace.fromValue(colorspaceAsInt);

  /// MPEG vs JPEG YUV range.
  /// - encoding: Set by user to override the default output color range value,
  /// If not specified, libavcodec sets the color range depending on the
  /// output format.
  /// - decoding: Set by libavcodec, can be set by the user to propagate the
  /// color range to components reading from the decoder context.
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  /// This defines the location of chroma samples.
  /// - encoding: Set by user
  /// - decoding: Set by libavcodec
  @ffi.UnsignedInt()
  external int chroma_sample_locationAsInt;

  AVChromaLocation get chroma_sample_location =>
      AVChromaLocation.fromValue(chroma_sample_locationAsInt);

  /// Field order
  /// - encoding: set by libavcodec
  /// - decoding: Set by user.
  @ffi.UnsignedInt()
  external int field_orderAsInt;

  AVFieldOrder get field_order => AVFieldOrder.fromValue(field_orderAsInt);

  /// number of reference frames
  /// - encoding: Set by user.
  /// - decoding: Set by lavc.
  @ffi.Int()
  external int refs;

  /// Size of the frame reordering buffer in the decoder.
  /// For MPEG-2 it is 1 IPB or 0 low delay IP.
  /// - encoding: Set by libavcodec.
  /// - decoding: Set by libavcodec.
  @ffi.Int()
  external int has_b_frames;

  /// slice flags
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int slice_flags;

  /// If non NULL, 'draw_horiz_band' is called by the libavcodec
  /// decoder to draw a horizontal band. It improves cache usage. Not
  /// all codecs can do that. You must check the codec capabilities
  /// beforehand.
  /// When multithreading is used, it may be called from multiple threads
  /// at the same time; threads might draw different parts of the same AVFrame,
  /// or multiple AVFrames, and there is no guarantee that slices will be drawn
  /// in order.
  /// The function is also used by hardware acceleration APIs.
  /// It is called at least once during frame decoding to pass
  /// the data needed for hardware render.
  /// In that mode instead of pixel data, AVFrame points to
  /// a structure specific to the acceleration API. The application
  /// reads the structure and can change some fields to indicate progress
  /// or mark state.
  /// - encoding: unused
  /// - decoding: Set by user.
  /// @param height the height of the slice
  /// @param y the y position of the slice
  /// @param type 1->top field, 2->bottom field, 3->frame
  /// @param offset offset into the AVFrame.data from which the slice should be read
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<AVCodecContext> s,
              ffi.Pointer<AVFrame> src,
              ffi.Pointer<ffi.Int> offset,
              ffi.Int y,
              ffi.Int type,
              ffi.Int height)>> draw_horiz_band;

  /// Callback to negotiate the pixel format. Decoding only, may be set by the
  /// caller before avcodec_open2().
  ///
  /// Called by some decoders to select the pixel format that will be used for
  /// the output frames. This is mainly used to set up hardware acceleration,
  /// then the provided format list contains the corresponding hwaccel pixel
  /// formats alongside the "software" one. The software pixel format may also
  /// be retrieved from \ref sw_pix_fmt.
  ///
  /// This callback will be called when the coded frame properties (such as
  /// resolution, pixel format, etc.) change and more than one output format is
  /// supported for those new properties. If a hardware pixel format is chosen
  /// and initialization for it fails, the callback may be called again
  /// immediately.
  ///
  /// This callback may be called from different threads if the decoder is
  /// multi-threaded, but not from more than one thread simultaneously.
  ///
  /// @param fmt list of formats which may be used in the current
  /// configuration, terminated by AV_PIX_FMT_NONE.
  /// @warning Behavior is undefined if the callback returns a value other
  /// than one of the formats in fmt or AV_PIX_FMT_NONE.
  /// @return the chosen format or AV_PIX_FMT_NONE
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVCodecContext> s, ffi.Pointer<ffi.Int> fmt)>>
      get_format;

  /// maximum number of B-frames between non-B-frames
  /// Note: The output will be delayed by max_b_frames+1 relative to the input.
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int max_b_frames;

  /// qscale factor between IP and B-frames
  /// If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
  /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double b_quant_factor;

  /// qscale offset between IP and B-frames
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double b_quant_offset;

  /// qscale factor between P- and I-frames
  /// If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
  /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double i_quant_factor;

  /// qscale offset between P and I-frames
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double i_quant_offset;

  /// luminance masking (0-> disabled)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double lumi_masking;

  /// temporary complexity masking (0-> disabled)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double temporal_cplx_masking;

  /// spatial complexity masking (0-> disabled)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double spatial_cplx_masking;

  /// p block masking (0-> disabled)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double p_masking;

  /// darkness masking (0-> disabled)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Float()
  external double dark_masking;

  /// noise vs. sse weight for the nsse comparison function
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int nsse_weight;

  /// motion estimation comparison function
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int me_cmp;

  /// subpixel motion estimation comparison function
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int me_sub_cmp;

  /// macroblock comparison function (not supported yet)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int mb_cmp;

  /// interlaced DCT comparison function
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int ildct_cmp;

  /// ME diamond size & shape
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int dia_size;

  /// amount of previous MV predictors (2a+1 x 2a+1 square)
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int last_predictor_count;

  /// motion estimation prepass comparison function
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int me_pre_cmp;

  /// ME prepass diamond size & shape
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int pre_dia_size;

  /// subpel ME quality
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int me_subpel_quality;

  /// maximum motion estimation search range in subpel units
  /// If 0 then no limit.
  ///
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int me_range;

  /// macroblock decision mode
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int mb_decision;

  /// custom intra quantization matrix
  /// Must be allocated with the av_malloc() family of functions, and will be freed in
  /// avcodec_free_context().
  /// - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.
  /// - decoding: Set/allocated/freed by libavcodec.
  external ffi.Pointer<ffi.Uint16> intra_matrix;

  /// custom inter quantization matrix
  /// Must be allocated with the av_malloc() family of functions, and will be freed in
  /// avcodec_free_context().
  /// - encoding: Set/allocated by user, freed by libavcodec. Can be NULL.
  /// - decoding: Set/allocated/freed by libavcodec.
  external ffi.Pointer<ffi.Uint16> inter_matrix;

  /// custom intra quantization matrix
  /// - encoding: Set by user, can be NULL.
  /// - decoding: unused.
  external ffi.Pointer<ffi.Uint16> chroma_intra_matrix;

  /// precision of the intra DC coefficient - 8
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec
  @ffi.Int()
  external int intra_dc_precision;

  /// minimum MB Lagrange multiplier
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int mb_lmin;

  /// maximum MB Lagrange multiplier
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int mb_lmax;

  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int bidir_refine;

  /// minimum GOP size
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int keyint_min;

  /// the number of pictures in a group of pictures, or 0 for intra_only
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int gop_size;

  /// Note: Value depends upon the compare function used for fullpel ME.
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int mv0_threshold;

  /// Number of slices.
  /// Indicates number of picture subdivisions. Used for parallelized
  /// decoding.
  /// - encoding: Set by user
  /// - decoding: unused
  @ffi.Int()
  external int slices;

  /// < samples per second
  @ffi.Int()
  external int sample_rate;

  /// < sample format
  @ffi.Int()
  external int sample_fmtAsInt;

  AVSampleFormat get sample_fmt => AVSampleFormat.fromValue(sample_fmtAsInt);

  /// Audio channel layout.
  /// - encoding: must be set by the caller, to one of AVCodec.ch_layouts.
  /// - decoding: may be set by the caller if known e.g. from the container.
  /// The decoder can then override during decoding as needed.
  external AVChannelLayout ch_layout;

  /// Number of samples per channel in an audio frame.
  ///
  /// - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
  /// except the last must contain exactly frame_size samples per channel.
  /// May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
  /// frame size is not restricted.
  /// - decoding: may be set by some decoders to indicate constant frame size
  @ffi.Int()
  external int frame_size;

  /// number of bytes per packet if constant and known or 0
  /// Used by some WAV based audio codecs.
  @ffi.Int()
  external int block_align;

  /// Audio cutoff bandwidth (0 means "automatic")
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int cutoff;

  /// Type of service that the audio stream conveys.
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  @ffi.UnsignedInt()
  external int audio_service_typeAsInt;

  AVAudioServiceType get audio_service_type =>
      AVAudioServiceType.fromValue(audio_service_typeAsInt);

  /// desired sample format
  /// - encoding: Not used.
  /// - decoding: Set by user.
  /// Decoder will decode to this format if it can.
  @ffi.Int()
  external int request_sample_fmtAsInt;

  AVSampleFormat get request_sample_fmt =>
      AVSampleFormat.fromValue(request_sample_fmtAsInt);

  /// Audio only. The number of "priming" samples (padding) inserted by the
  /// encoder at the beginning of the audio. I.e. this number of leading
  /// decoded samples must be discarded by the caller to get the original audio
  /// without leading padding.
  ///
  /// - decoding: unused
  /// - encoding: Set by libavcodec. The timestamps on the output packets are
  /// adjusted by the encoder so that they always refer to the
  /// first sample of the data actually contained in the packet,
  /// including any added padding.  E.g. if the timebase is
  /// 1/samplerate and the timestamp of the first input sample is
  /// 0, the timestamp of the first output packet will be
  /// -initial_padding.
  @ffi.Int()
  external int initial_padding;

  /// Audio only. The amount of padding (in samples) appended by the encoder to
  /// the end of the audio. I.e. this number of decoded samples must be
  /// discarded by the caller from the end of the stream to get the original
  /// audio without any trailing padding.
  ///
  /// - decoding: unused
  /// - encoding: unused
  @ffi.Int()
  external int trailing_padding;

  /// Number of samples to skip after a discontinuity
  /// - decoding: unused
  /// - encoding: set by libavcodec
  @ffi.Int()
  external int seek_preroll;

  /// This callback is called at the beginning of each frame to get data
  /// buffer(s) for it. There may be one contiguous buffer for all the data or
  /// there may be a buffer per each data plane or anything in between. What
  /// this means is, you may set however many entries in buf[] you feel necessary.
  /// Each buffer must be reference-counted using the AVBuffer API (see description
  /// of buf[] below).
  ///
  /// The following fields will be set in the frame before this callback is
  /// called:
  /// - format
  /// - width, height (video only)
  /// - sample_rate, channel_layout, nb_samples (audio only)
  /// Their values may differ from the corresponding values in
  /// AVCodecContext. This callback must use the frame values, not the codec
  /// context values, to calculate the required buffer size.
  ///
  /// This callback must fill the following fields in the frame:
  /// - data[]
  /// - linesize[]
  /// - extended_data:
  /// * if the data is planar audio with more than 8 channels, then this
  /// callback must allocate and fill extended_data to contain all pointers
  /// to all data planes. data[] must hold as many pointers as it can.
  /// extended_data must be allocated with av_malloc() and will be freed in
  /// av_frame_unref().
  /// * otherwise extended_data must point to data
  /// - buf[] must contain one or more pointers to AVBufferRef structures. Each of
  /// the frame's data and extended_data pointers must be contained in these. That
  /// is, one AVBufferRef for each allocated chunk of memory, not necessarily one
  /// AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
  /// and av_buffer_ref().
  /// - extended_buf and nb_extended_buf must be allocated with av_malloc() by
  /// this callback and filled with the extra buffers if there are more
  /// buffers than buf[] can hold. extended_buf will be freed in
  /// av_frame_unref().
  /// Decoders will generally initialize the whole buffer before it is output
  /// but it can in rare error conditions happen that uninitialized data is passed
  /// through. \important The buffers returned by get_buffer* should thus not contain sensitive
  /// data.
  ///
  /// If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
  /// avcodec_default_get_buffer2() instead of providing buffers allocated by
  /// some other means.
  ///
  /// Each data plane must be aligned to the maximum required by the target
  /// CPU.
  ///
  /// @see avcodec_default_get_buffer2()
  ///
  /// Video:
  ///
  /// If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
  /// (read and/or written to if it is writable) later by libavcodec.
  ///
  /// avcodec_align_dimensions2() should be used to find the required width and
  /// height, as they normally need to be rounded up to the next multiple of 16.
  ///
  /// Some decoders do not support linesizes changing between frames.
  ///
  /// If frame multithreading is used, this callback may be called from a
  /// different thread, but not from more than one at once. Does not need to be
  /// reentrant.
  ///
  /// @see avcodec_align_dimensions2()
  ///
  /// Audio:
  ///
  /// Decoders request a buffer of a particular size by setting
  /// AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
  /// however, utilize only part of the buffer by setting AVFrame.nb_samples
  /// to a smaller value in the output frame.
  ///
  /// As a convenience, av_samples_get_buffer_size() and
  /// av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
  /// functions to find the required data size and to fill data pointers and
  /// linesize. In AVFrame.linesize, only linesize[0] may be set for audio
  /// since all planes must be the same size.
  ///
  /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
  ///
  /// - encoding: unused
  /// - decoding: Set by libavcodec, user can override.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext> s,
              ffi.Pointer<AVFrame> frame, ffi.Int flags)>> get_buffer2;

  /// number of bits the bitstream is allowed to diverge from the reference.
  /// the reference can be CBR (for CBR pass1) or VBR (for pass2)
  /// - encoding: Set by user; unused for constant quantizer encoding.
  /// - decoding: unused
  @ffi.Int()
  external int bit_rate_tolerance;

  /// Global quality for codecs which cannot change it per frame.
  /// This should be proportional to MPEG-1/2/4 qscale.
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int global_quality;

  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int compression_level;

  /// < amount of qscale change between easy & hard scenes (0.0-1.0)
  @ffi.Float()
  external double qcompress;

  /// < amount of qscale smoothing over time (0.0-1.0)
  @ffi.Float()
  external double qblur;

  /// minimum quantizer
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int qmin;

  /// maximum quantizer
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int qmax;

  /// maximum quantizer difference between frames
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int max_qdiff;

  /// decoder bitstream buffer size
  /// - encoding: Set by user.
  /// - decoding: May be set by libavcodec.
  @ffi.Int()
  external int rc_buffer_size;

  /// ratecontrol override, see RcOverride
  /// - encoding: Allocated/set/freed by user.
  /// - decoding: unused
  @ffi.Int()
  external int rc_override_count;

  external ffi.Pointer<RcOverride> rc_override;

  /// maximum bitrate
  /// - encoding: Set by user.
  /// - decoding: Set by user, may be overwritten by libavcodec.
  @ffi.Int64()
  external int rc_max_rate;

  /// minimum bitrate
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int64()
  external int rc_min_rate;

  /// Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
  /// - encoding: Set by user.
  /// - decoding: unused.
  @ffi.Float()
  external double rc_max_available_vbv_use;

  /// Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
  /// - encoding: Set by user.
  /// - decoding: unused.
  @ffi.Float()
  external double rc_min_vbv_overflow_use;

  /// Number of bits which should be loaded into the rc buffer before decoding starts.
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int rc_initial_buffer_occupancy;

  /// trellis RD quantization
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int trellis;

  /// pass1 encoding statistics output buffer
  /// - encoding: Set by libavcodec.
  /// - decoding: unused
  external ffi.Pointer<ffi.Char> stats_out;

  /// pass2 encoding statistics input buffer
  /// Concatenated stuff from stats_out of pass1 should be placed here.
  /// - encoding: Allocated/set/freed by user.
  /// - decoding: unused
  external ffi.Pointer<ffi.Char> stats_in;

  /// Work around bugs in encoders which sometimes cannot be detected automatically.
  /// - encoding: Set by user
  /// - decoding: Set by user
  @ffi.Int()
  external int workaround_bugs;

  /// strictly follow the standard (MPEG-4, ...).
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  /// Setting this to STRICT or higher means the encoder and decoder will
  /// generally do stupid things, whereas setting it to unofficial or lower
  /// will mean the encoder might produce output that is not supported by all
  /// spec-compliant decoders. Decoders don't differentiate between normal,
  /// unofficial and experimental (that is, they always try to decode things
  /// when they can) unless they are explicitly asked to behave stupidly
  /// (=strictly conform to the specs)
  /// This may only be set to one of the FF_COMPLIANCE_* values in defs.h.
  @ffi.Int()
  external int strict_std_compliance;

  /// error concealment flags
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int error_concealment;

  /// debug
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  @ffi.Int()
  external int debug;

  /// Error recognition; may misdetect some more or less valid parts as errors.
  /// This is a bitfield of the AV_EF_* values defined in defs.h.
  ///
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  @ffi.Int()
  external int err_recognition;

  /// Hardware accelerator in use
  /// - encoding: unused.
  /// - decoding: Set by libavcodec
  external ffi.Pointer<AVHWAccel> hwaccel;

  /// Legacy hardware accelerator context.
  ///
  /// For some hardware acceleration methods, the caller may use this field to
  /// signal hwaccel-specific data to the codec. The struct pointed to by this
  /// pointer is hwaccel-dependent and defined in the respective header. Please
  /// refer to the FFmpeg HW accelerator documentation to know how to fill
  /// this.
  ///
  /// In most cases this field is optional - the necessary information may also
  /// be provided to libavcodec through @ref hw_frames_ctx or @ref
  /// hw_device_ctx (see avcodec_get_hw_config()). However, in some cases it
  /// may be the only method of signalling some (optional) information.
  ///
  /// The struct and its contents are owned by the caller.
  ///
  /// - encoding: May be set by the caller before avcodec_open2(). Must remain
  /// valid until avcodec_free_context().
  /// - decoding: May be set by the caller in the get_format() callback.
  /// Must remain valid until the next get_format() call,
  /// or avcodec_free_context() (whichever comes first).
  external ffi.Pointer<ffi.Void> hwaccel_context;

  /// A reference to the AVHWFramesContext describing the input (for encoding)
  /// or output (decoding) frames. The reference is set by the caller and
  /// afterwards owned (and freed) by libavcodec - it should never be read by
  /// the caller after being set.
  ///
  /// - decoding: This field should be set by the caller from the get_format()
  /// callback. The previous reference (if any) will always be
  /// unreffed by libavcodec before the get_format() call.
  ///
  /// If the default get_buffer2() is used with a hwaccel pixel
  /// format, then this AVHWFramesContext will be used for
  /// allocating the frame buffers.
  ///
  /// - encoding: For hardware encoders configured to use a hwaccel pixel
  /// format, this field should be set by the caller to a reference
  /// to the AVHWFramesContext describing input frames.
  /// AVHWFramesContext.format must be equal to
  /// AVCodecContext.pix_fmt.
  ///
  /// This field should be set before avcodec_open2() is called.
  external ffi.Pointer<AVBufferRef> hw_frames_ctx;

  /// A reference to the AVHWDeviceContext describing the device which will
  /// be used by a hardware encoder/decoder.  The reference is set by the
  /// caller and afterwards owned (and freed) by libavcodec.
  ///
  /// This should be used if either the codec device does not require
  /// hardware frames or any that are used are to be allocated internally by
  /// libavcodec.  If the user wishes to supply any of the frames used as
  /// encoder input or decoder output then hw_frames_ctx should be used
  /// instead.  When hw_frames_ctx is set in get_format() for a decoder, this
  /// field will be ignored while decoding the associated stream segment, but
  /// may again be used on a following one after another get_format() call.
  ///
  /// For both encoders and decoders this field should be set before
  /// avcodec_open2() is called and must not be written to thereafter.
  ///
  /// Note that some decoders may require this field to be set initially in
  /// order to support hw_frames_ctx at all - in that case, all frames
  /// contexts used must be created on the same device.
  external ffi.Pointer<AVBufferRef> hw_device_ctx;

  /// Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
  /// decoding (if active).
  /// - encoding: unused
  /// - decoding: Set by user (either before avcodec_open2(), or in the
  /// AVCodecContext.get_format callback)
  @ffi.Int()
  external int hwaccel_flags;

  /// Video decoding only.  Sets the number of extra hardware frames which
  /// the decoder will allocate for use by the caller.  This must be set
  /// before avcodec_open2() is called.
  ///
  /// Some hardware decoders require all frames that they will use for
  /// output to be defined in advance before decoding starts.  For such
  /// decoders, the hardware frame pool must therefore be of a fixed size.
  /// The extra frames set here are on top of any number that the decoder
  /// needs internally in order to operate normally (for example, frames
  /// used as reference pictures).
  @ffi.Int()
  external int extra_hw_frames;

  /// error
  /// - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
  /// - decoding: unused
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint64> error;

  /// DCT algorithm, see FF_DCT_* below
  /// - encoding: Set by user.
  /// - decoding: unused
  @ffi.Int()
  external int dct_algo;

  /// IDCT algorithm, see FF_IDCT_* below.
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  @ffi.Int()
  external int idct_algo;

  /// bits per sample/pixel from the demuxer (needed for huffyuv).
  /// - encoding: Set by libavcodec.
  /// - decoding: Set by user.
  @ffi.Int()
  external int bits_per_coded_sample;

  /// Bits per sample/pixel of internal libavcodec pixel/sample format.
  /// - encoding: set by user.
  /// - decoding: set by libavcodec.
  @ffi.Int()
  external int bits_per_raw_sample;

  /// thread count
  /// is used to decide how many independent tasks should be passed to execute()
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  @ffi.Int()
  external int thread_count;

  /// Which multithreading methods to use.
  /// Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
  /// so clients which cannot provide future frames should not use it.
  ///
  /// - encoding: Set by user, otherwise the default is used.
  /// - decoding: Set by user, otherwise the default is used.
  @ffi.Int()
  external int thread_type;

  /// Which multithreading methods are in use by the codec.
  /// - encoding: Set by libavcodec.
  /// - decoding: Set by libavcodec.
  @ffi.Int()
  external int active_thread_type;

  /// The codec may call this to execute several independent things.
  /// It will return only after finishing all tasks.
  /// The user may replace this with some multithreaded implementation,
  /// the default implementation will execute the parts serially.
  /// @param count the number of things to execute
  /// - encoding: Set by libavcodec, user can override.
  /// - decoding: Set by libavcodec, user can override.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext> c,
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Int Function(ffi.Pointer<AVCodecContext> c2,
                              ffi.Pointer<ffi.Void> arg)>>
                  func,
              ffi.Pointer<ffi.Void> arg2,
              ffi.Pointer<ffi.Int> ret,
              ffi.Int count,
              ffi.Int size)>> execute;

  /// The codec may call this to execute several independent things.
  /// It will return only after finishing all tasks.
  /// The user may replace this with some multithreaded implementation,
  /// the default implementation will execute the parts serially.
  /// @param c context passed also to func
  /// @param count the number of things to execute
  /// @param arg2 argument passed unchanged to func
  /// @param ret return values of executed functions, must have space for "count" values. May be NULL.
  /// @param func function that will be called count times, with jobnr from 0 to count-1.
  /// threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
  /// two instances of func executing at the same time will have the same threadnr.
  /// @return always 0 currently, but code should handle a future improvement where when any call to func
  /// returns < 0 no further calls to func may be done and < 0 is returned.
  /// - encoding: Set by libavcodec, user can override.
  /// - decoding: Set by libavcodec, user can override.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecContext> c,
              ffi.Pointer<
                      ffi.NativeFunction<
                          ffi.Int Function(
                              ffi.Pointer<AVCodecContext> c2,
                              ffi.Pointer<ffi.Void> arg,
                              ffi.Int jobnr,
                              ffi.Int threadnr)>>
                  func,
              ffi.Pointer<ffi.Void> arg2,
              ffi.Pointer<ffi.Int> ret,
              ffi.Int count)>> execute2;

  /// profile
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  /// See the AV_PROFILE_* defines in defs.h.
  @ffi.Int()
  external int profile;

  /// Encoding level descriptor.
  /// - encoding: Set by user, corresponds to a specific level defined by the
  /// codec, usually corresponding to the profile level, if not specified it
  /// is set to FF_LEVEL_UNKNOWN.
  /// - decoding: Set by libavcodec.
  /// See AV_LEVEL_* in defs.h.
  @ffi.Int()
  external int level;

  /// Properties of the stream that gets decoded
  /// - encoding: unused
  /// - decoding: set by libavcodec
  @ffi.UnsignedInt()
  external int properties;

  /// Skip loop filtering for selected frames.
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int skip_loop_filterAsInt;

  AVDiscard get skip_loop_filter => AVDiscard.fromValue(skip_loop_filterAsInt);

  /// Skip IDCT/dequantization for selected frames.
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int skip_idctAsInt;

  AVDiscard get skip_idct => AVDiscard.fromValue(skip_idctAsInt);

  /// Skip decoding for selected frames.
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int skip_frameAsInt;

  AVDiscard get skip_frame => AVDiscard.fromValue(skip_frameAsInt);

  /// Skip processing alpha if supported by codec.
  /// Note that if the format uses pre-multiplied alpha (common with VP6,
  /// and recommended due to better video quality/compression)
  /// the image will look as if alpha-blended onto a black background.
  /// However for formats that do not use pre-multiplied alpha
  /// there might be serious artefacts (though e.g. libswscale currently
  /// assumes pre-multiplied alpha anyway).
  ///
  /// - decoding: set by user
  /// - encoding: unused
  @ffi.Int()
  external int skip_alpha;

  /// Number of macroblock rows at the top which are skipped.
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int skip_top;

  /// Number of macroblock rows at the bottom which are skipped.
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int skip_bottom;

  /// low resolution decoding, 1-> 1/2 size, 2->1/4 size
  /// - encoding: unused
  /// - decoding: Set by user.
  @ffi.Int()
  external int lowres;

  /// AVCodecDescriptor
  /// - encoding: unused.
  /// - decoding: set by libavcodec.
  external ffi.Pointer<AVCodecDescriptor> codec_descriptor;

  /// Character encoding of the input subtitles file.
  /// - decoding: set by user
  /// - encoding: unused
  external ffi.Pointer<ffi.Char> sub_charenc;

  /// Subtitles character encoding mode. Formats or codecs might be adjusting
  /// this setting (if they are doing the conversion themselves for instance).
  /// - decoding: set by libavcodec
  /// - encoding: unused
  @ffi.Int()
  external int sub_charenc_mode;

  /// Header containing style information for text subtitles.
  /// For SUBTITLE_ASS subtitle type, it should contain the whole ASS
  /// [Script Info] and [V4+ Styles] section, plus the [Events] line and
  /// the Format line following. It shouldn't include any Dialogue line.
  /// - encoding: Set/allocated/freed by user (before avcodec_open2())
  /// - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
  @ffi.Int()
  external int subtitle_header_size;

  external ffi.Pointer<ffi.Uint8> subtitle_header;

  /// dump format separator.
  /// can be ", " or "\n      " or anything else
  /// - encoding: Set by user.
  /// - decoding: Set by user.
  external ffi.Pointer<ffi.Uint8> dump_separator;

  /// ',' separated list of allowed decoders.
  /// If NULL then all are allowed
  /// - encoding: unused
  /// - decoding: set by user
  external ffi.Pointer<ffi.Char> codec_whitelist;

  /// Additional data associated with the entire coded stream.
  ///
  /// - decoding: may be set by user before calling avcodec_open2().
  /// - encoding: may be set by libavcodec after avcodec_open2().
  external ffi.Pointer<AVPacketSideData> coded_side_data;

  @ffi.Int()
  external int nb_coded_side_data;

  /// Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of
  /// metadata exported in frame, packet, or coded stream side data by
  /// decoders and encoders.
  ///
  /// - decoding: set by user
  /// - encoding: set by user
  @ffi.Int()
  external int export_side_data;

  /// The number of pixels per image to maximally accept.
  ///
  /// - decoding: set by user
  /// - encoding: set by user
  @ffi.Int64()
  external int max_pixels;

  /// Video decoding only. Certain video codecs support cropping, meaning that
  /// only a sub-rectangle of the decoded frame is intended for display.  This
  /// option controls how cropping is handled by libavcodec.
  ///
  /// When set to 1 (the default), libavcodec will apply cropping internally.
  /// I.e. it will modify the output frame width/height fields and offset the
  /// data pointers (only by as much as possible while preserving alignment, or
  /// by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that
  /// the frames output by the decoder refer only to the cropped area. The
  /// crop_* fields of the output frames will be zero.
  ///
  /// When set to 0, the width/height fields of the output frames will be set
  /// to the coded dimensions and the crop_* fields will describe the cropping
  /// rectangle. Applying the cropping is left to the caller.
  ///
  /// @warning When hardware acceleration with opaque output frames is used,
  /// libavcodec is unable to apply cropping from the top/left border.
  ///
  /// @note when this option is set to zero, the width/height fields of the
  /// AVCodecContext and output AVFrames have different meanings. The codec
  /// context fields store display dimensions (with the coded dimensions in
  /// coded_width/height), while the frame fields store the coded dimensions
  /// (with the display dimensions being determined by the crop_* fields).
  @ffi.Int()
  external int apply_cropping;

  /// The percentage of damaged samples to discard a frame.
  ///
  /// - decoding: set by user
  /// - encoding: unused
  @ffi.Int()
  external int discard_damaged_percentage;

  /// The number of samples per frame to maximally accept.
  ///
  /// - decoding: set by user
  /// - encoding: set by user
  @ffi.Int64()
  external int max_samples;

  /// This callback is called at the beginning of each packet to get a data
  /// buffer for it.
  ///
  /// The following field will be set in the packet before this callback is
  /// called:
  /// - size
  /// This callback must use the above value to calculate the required buffer size,
  /// which must padded by at least AV_INPUT_BUFFER_PADDING_SIZE bytes.
  ///
  /// In some specific cases, the encoder may not use the entire buffer allocated by this
  /// callback. This will be reflected in the size value in the packet once returned by
  /// avcodec_receive_packet().
  ///
  /// This callback must fill the following fields in the packet:
  /// - data: alignment requirements for AVPacket apply, if any. Some architectures and
  /// encoders may benefit from having aligned data.
  /// - buf: must contain a pointer to an AVBufferRef structure. The packet's
  /// data pointer must be contained in it. See: av_buffer_create(), av_buffer_alloc(),
  /// and av_buffer_ref().
  ///
  /// If AV_CODEC_CAP_DR1 is not set then get_encode_buffer() must call
  /// avcodec_default_get_encode_buffer() instead of providing a buffer allocated by
  /// some other means.
  ///
  /// The flags field may contain a combination of AV_GET_ENCODE_BUFFER_FLAG_ flags.
  /// They may be used for example to hint what use the buffer may get after being
  /// created.
  /// Implementations of this callback may ignore flags they don't understand.
  /// If AV_GET_ENCODE_BUFFER_FLAG_REF is set in flags then the packet may be reused
  /// (read and/or written to if it is writable) later by libavcodec.
  ///
  /// This callback must be thread-safe, as when frame threading is used, it may
  /// be called from multiple threads simultaneously.
  ///
  /// @see avcodec_default_get_encode_buffer()
  ///
  /// - encoding: Set by libavcodec, user can override.
  /// - decoding: unused
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext> s,
              ffi.Pointer<AVPacket> pkt, ffi.Int flags)>> get_encode_buffer;

  /// Frame counter, set by libavcodec.
  ///
  /// - decoding: total number of frames returned from the decoder so far.
  /// - encoding: total number of frames passed to the encoder so far.
  ///
  /// @note the counter is not incremented if encoding/decoding resulted in
  /// an error.
  @ffi.Int64()
  external int frame_num;

  /// Decoding only. May be set by the caller before avcodec_open2() to an
  /// av_malloc()'ed array (or via AVOptions). Owned and freed by the decoder
  /// afterwards.
  ///
  /// Side data attached to decoded frames may come from several sources:
  /// 1. coded_side_data, which the decoder will for certain types translate
  /// from packet-type to frame-type and attach to frames;
  /// 2. side data attached to an AVPacket sent for decoding (same
  /// considerations as above);
  /// 3. extracted from the coded bytestream.
  /// The first two cases are supplied by the caller and typically come from a
  /// container.
  ///
  /// This array configures decoder behaviour in cases when side data of the
  /// same type is present both in the coded bytestream and in the
  /// user-supplied side data (items 1. and 2. above). In all cases, at most
  /// one instance of each side data type will be attached to output frames. By
  /// default it will be the bytestream side data. Adding an
  /// AVPacketSideDataType value to this array will flip the preference for
  /// this type, thus making the decoder prefer user-supplied side data over
  /// bytestream. In case side data of the same type is present both in
  /// coded_data and attacked to a packet, the packet instance always has
  /// priority.
  ///
  /// The array may also contain a single -1, in which case the preference is
  /// switched for all side data types.
  external ffi.Pointer<ffi.Int> side_data_prefer_packet;

  /// Number of entries in side_data_prefer_packet.
  @ffi.UnsignedInt()
  external int nb_side_data_prefer_packet;

  /// Array containing static side data, such as HDR10 CLL / MDCV structures.
  /// Side data entries should be allocated by usage of helpers defined in
  /// libavutil/frame.h.
  ///
  /// - encoding: may be set by user before calling avcodec_open2() for
  /// encoder configuration. Afterwards owned and freed by the
  /// encoder.
  /// - decoding: may be set by libavcodec in avcodec_open2().
  external ffi.Pointer<ffi.Pointer<AVFrameSideData>> decoded_side_data;

  @ffi.Int()
  external int nb_decoded_side_data;
}

final class AVCodecInternal extends ffi.Opaque {}

/// @defgroup lavc_hwaccel AVHWAccel
///
/// @note  Nothing in this structure should be accessed by the user.  At some
/// point in future it will not be externally visible at all.
///
/// @{
final class AVHWAccel extends ffi.Struct {
  /// Name of the hardware accelerated codec.
  /// The name is globally unique among encoders and among decoders (but an
  /// encoder and a decoder can share the same name).
  external ffi.Pointer<ffi.Char> name;

  /// Type of codec implemented by the hardware accelerator.
  ///
  /// See AVMEDIA_TYPE_xxx
  @ffi.Int()
  external int typeAsInt;

  AVMediaType get type => AVMediaType.fromValue(typeAsInt);

  /// Codec implemented by the hardware accelerator.
  ///
  /// See AV_CODEC_ID_xxx
  @ffi.UnsignedInt()
  external int idAsInt;

  AVCodecID get id => AVCodecID.fromValue(idAsInt);

  /// Supported pixel format.
  ///
  /// Only hardware accelerated formats are supported here.
  @ffi.Int()
  external int pix_fmtAsInt;

  AVPixelFormat get pix_fmt => AVPixelFormat.fromValue(pix_fmtAsInt);

  /// Hardware accelerated codec capabilities.
  /// see AV_HWACCEL_CODEC_CAP_*
  @ffi.Int()
  external int capabilities;
}

/// @}
enum AVSubtitleType {
  SUBTITLE_NONE(0),

  /// < A bitmap, pict will be set
  SUBTITLE_BITMAP(1),

  /// Plain text, the text field must be set by the decoder and is
  /// authoritative. ass and pict fields may contain approximations.
  SUBTITLE_TEXT(2),

  /// Formatted text, the ass field must be set by the decoder and is
  /// authoritative. pict and text fields may contain approximations.
  SUBTITLE_ASS(3);

  final int value;
  const AVSubtitleType(this.value);

  static AVSubtitleType fromValue(int value) => switch (value) {
        0 => SUBTITLE_NONE,
        1 => SUBTITLE_BITMAP,
        2 => SUBTITLE_TEXT,
        3 => SUBTITLE_ASS,
        _ => throw ArgumentError("Unknown value for AVSubtitleType: $value"),
      };
}

final class AVSubtitleRect extends ffi.Struct {
  /// < top left corner  of pict, undefined when pict is not set
  @ffi.Int()
  external int x;

  /// < top left corner  of pict, undefined when pict is not set
  @ffi.Int()
  external int y;

  /// < width            of pict, undefined when pict is not set
  @ffi.Int()
  external int w;

  /// < height           of pict, undefined when pict is not set
  @ffi.Int()
  external int h;

  /// < number of colors in pict, undefined when pict is not set
  @ffi.Int()
  external int nb_colors;

  /// data+linesize for the bitmap of this subtitle.
  /// Can be set for text/ass as well once they are rendered.
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Pointer<ffi.Uint8>> data;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int> linesize;

  @ffi.Int()
  external int flags;

  @ffi.UnsignedInt()
  external int typeAsInt;

  AVSubtitleType get type => AVSubtitleType.fromValue(typeAsInt);

  /// < 0 terminated plain UTF-8 text
  external ffi.Pointer<ffi.Char> text;

  /// 0 terminated ASS/SSA compatible event line.
  /// The presentation of this is unaffected by the other values in this
  /// struct.
  external ffi.Pointer<ffi.Char> ass;
}

final class AVSubtitle extends ffi.Struct {
  @ffi.Uint16()
  external int format;

  @ffi.Uint32()
  external int start_display_time;

  @ffi.Uint32()
  external int end_display_time;

  @ffi.UnsignedInt()
  external int num_rects;

  external ffi.Pointer<ffi.Pointer<AVSubtitleRect>> rects;

  /// < Same as packet pts, in AV_TIME_BASE
  @ffi.Int64()
  external int pts;
}

enum AVCodecConfig {
  /// < AVPixelFormat, terminated by AV_PIX_FMT_NONE
  AV_CODEC_CONFIG_PIX_FORMAT(0),

  /// < AVRational, terminated by {0, 0}
  AV_CODEC_CONFIG_FRAME_RATE(1),

  /// < int, terminated by 0
  AV_CODEC_CONFIG_SAMPLE_RATE(2),

  /// < AVSampleFormat, terminated by AV_SAMPLE_FMT_NONE
  AV_CODEC_CONFIG_SAMPLE_FORMAT(3),

  /// < AVChannelLayout, terminated by {0}
  AV_CODEC_CONFIG_CHANNEL_LAYOUT(4),

  /// < AVColorRange, terminated by AVCOL_RANGE_UNSPECIFIED
  AV_CODEC_CONFIG_COLOR_RANGE(5),

  /// < AVColorSpace, terminated by AVCOL_SPC_UNSPECIFIED
  AV_CODEC_CONFIG_COLOR_SPACE(6);

  final int value;
  const AVCodecConfig(this.value);

  static AVCodecConfig fromValue(int value) => switch (value) {
        0 => AV_CODEC_CONFIG_PIX_FORMAT,
        1 => AV_CODEC_CONFIG_FRAME_RATE,
        2 => AV_CODEC_CONFIG_SAMPLE_RATE,
        3 => AV_CODEC_CONFIG_SAMPLE_FORMAT,
        4 => AV_CODEC_CONFIG_CHANNEL_LAYOUT,
        5 => AV_CODEC_CONFIG_COLOR_RANGE,
        6 => AV_CODEC_CONFIG_COLOR_SPACE,
        _ => throw ArgumentError("Unknown value for AVCodecConfig: $value"),
      };
}

/// @defgroup lavc_parsing Frame parsing
/// @{
enum AVPictureStructure {
  /// < unknown
  AV_PICTURE_STRUCTURE_UNKNOWN(0),

  /// < coded as top field
  AV_PICTURE_STRUCTURE_TOP_FIELD(1),

  /// < coded as bottom field
  AV_PICTURE_STRUCTURE_BOTTOM_FIELD(2),

  /// < coded as frame
  AV_PICTURE_STRUCTURE_FRAME(3);

  final int value;
  const AVPictureStructure(this.value);

  static AVPictureStructure fromValue(int value) => switch (value) {
        0 => AV_PICTURE_STRUCTURE_UNKNOWN,
        1 => AV_PICTURE_STRUCTURE_TOP_FIELD,
        2 => AV_PICTURE_STRUCTURE_BOTTOM_FIELD,
        3 => AV_PICTURE_STRUCTURE_FRAME,
        _ =>
          throw ArgumentError("Unknown value for AVPictureStructure: $value"),
      };
}

final class AVCodecParserContext extends ffi.Struct {
  external ffi.Pointer<ffi.Void> priv_data;

  external ffi.Pointer<AVCodecParser> parser;

  @ffi.Int64()
  external int frame_offset;

  @ffi.Int64()
  external int cur_offset;

  @ffi.Int64()
  external int next_frame_offset;

  @ffi.Int()
  external int pict_type;

  /// This field is used for proper frame duration computation in lavf.
  /// It signals, how much longer the frame duration of the current frame
  /// is compared to normal frame duration.
  ///
  /// frame_duration = (1 + repeat_pict) * time_base
  ///
  /// It is used by codecs like H.264 to display telecined material.
  @ffi.Int()
  external int repeat_pict;

  @ffi.Int64()
  external int pts;

  @ffi.Int64()
  external int dts;

  @ffi.Int64()
  external int last_pts;

  @ffi.Int64()
  external int last_dts;

  @ffi.Int()
  external int fetch_timestamp;

  @ffi.Int()
  external int cur_frame_start_index;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int64> cur_frame_offset;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int64> cur_frame_pts;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int64> cur_frame_dts;

  @ffi.Int()
  external int flags;

  /// < byte offset from starting packet start
  @ffi.Int64()
  external int offset;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int64> cur_frame_end;

  /// Set by parser to 1 for key frames and 0 for non-key frames.
  /// It is initialized to -1, so if the parser doesn't set this flag,
  /// old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
  /// will be used.
  @ffi.Int()
  external int key_frame;

  /// Synchronization point for start of timestamp generation.
  ///
  /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
  /// (default).
  ///
  /// For example, this corresponds to presence of H.264 buffering period
  /// SEI message.
  @ffi.Int()
  external int dts_sync_point;

  /// Offset of the current timestamp against last timestamp sync point in
  /// units of AVCodecContext.time_base.
  ///
  /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
  /// contain a valid timestamp offset.
  ///
  /// Note that the timestamp of sync point has usually a nonzero
  /// dts_ref_dts_delta, which refers to the previous sync point. Offset of
  /// the next frame after timestamp sync point will be usually 1.
  ///
  /// For example, this corresponds to H.264 cpb_removal_delay.
  @ffi.Int()
  external int dts_ref_dts_delta;

  /// Presentation delay of current frame in units of AVCodecContext.time_base.
  ///
  /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
  /// contain valid non-negative timestamp delta (presentation time of a frame
  /// must not lie in the past).
  ///
  /// This delay represents the difference between decoding and presentation
  /// time of the frame.
  ///
  /// For example, this corresponds to H.264 dpb_output_delay.
  @ffi.Int()
  external int pts_dts_delta;

  /// Position of the packet in file.
  ///
  /// Analogous to cur_frame_pts/dts
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int64> cur_frame_pos;

  /// Byte position of currently parsed frame in stream.
  @ffi.Int64()
  external int pos;

  /// Previous frame byte position.
  @ffi.Int64()
  external int last_pos;

  /// Duration of the current frame.
  /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
  /// For all other types, this is in units of AVCodecContext.time_base.
  @ffi.Int()
  external int duration;

  @ffi.UnsignedInt()
  external int field_orderAsInt;

  AVFieldOrder get field_order => AVFieldOrder.fromValue(field_orderAsInt);

  /// Indicate whether a picture is coded as a frame, top field or bottom field.
  ///
  /// For example, H.264 field_pic_flag equal to 0 corresponds to
  /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
  /// equal to 1 and bottom_field_flag equal to 0 corresponds to
  /// AV_PICTURE_STRUCTURE_TOP_FIELD.
  @ffi.UnsignedInt()
  external int picture_structureAsInt;

  AVPictureStructure get picture_structure =>
      AVPictureStructure.fromValue(picture_structureAsInt);

  /// Picture number incremented in presentation or output order.
  /// This field may be reinitialized at the first picture of a new sequence.
  ///
  /// For example, this corresponds to H.264 PicOrderCnt.
  @ffi.Int()
  external int output_picture_number;

  /// Dimensions of the decoded video intended for presentation.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// Dimensions of the coded video.
  @ffi.Int()
  external int coded_width;

  @ffi.Int()
  external int coded_height;

  /// The format of the coded data, corresponds to enum AVPixelFormat for video
  /// and for enum AVSampleFormat for audio.
  ///
  /// Note that a decoder can have considerable freedom in how exactly it
  /// decodes the data, so the format reported here might be different from the
  /// one returned by a decoder.
  @ffi.Int()
  external int format;
}

final class AVCodecParser extends ffi.Struct {
  @ffi.Array.multi([7])
  external ffi.Array<ffi.Int> codec_ids;

  @ffi.Int()
  external int priv_data_size;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecParserContext> s)>> parser_init;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVCodecParserContext> s,
              ffi.Pointer<AVCodecContext> avctx,
              ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
              ffi.Pointer<ffi.Int> poutbuf_size,
              ffi.Pointer<ffi.Uint8> buf,
              ffi.Int buf_size)>> parser_parse;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<AVCodecParserContext> s)>> parser_close;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<AVCodecContext> avctx,
              ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>> split;
}

/// This structure holds a reference to a android/view/Surface object that will
/// be used as output by the decoder.
final class AVMediaCodecContext extends ffi.Struct {
  /// android/view/Surface object reference.
  external ffi.Pointer<ffi.Void> surface;
}

final class MediaCodecBuffer extends ffi.Opaque {}

/// Opaque structure representing a MediaCodec buffer to render.
typedef AVMediaCodecBuffer = MediaCodecBuffer;

final class FFTComplex extends ffi.Struct {
  @FFTSample()
  external double re;

  @FFTSample()
  external double im;
}

/// @defgroup lavc_fft FFT functions
/// @ingroup lavc_misc
///
/// @{
typedef FFTSample = ffi.Float;
typedef DartFFTSample = double;

final class FFTContext extends ffi.Opaque {}

enum RDFTransformType {
  DFT_R2C(0),
  IDFT_C2R(1),
  IDFT_R2C(2),
  DFT_C2R(3);

  final int value;
  const RDFTransformType(this.value);

  static RDFTransformType fromValue(int value) => switch (value) {
        0 => DFT_R2C,
        1 => IDFT_C2R,
        2 => IDFT_R2C,
        3 => DFT_C2R,
        _ => throw ArgumentError("Unknown value for RDFTransformType: $value"),
      };
}

final class RDFTContext extends ffi.Opaque {}

final class DCTContext extends ffi.Opaque {}

enum DCTTransformType {
  DCT_II(0),
  DCT_III(1),
  DCT_I(2),
  DST_I(3);

  final int value;
  const DCTTransformType(this.value);

  static DCTTransformType fromValue(int value) => switch (value) {
        0 => DCT_II,
        1 => DCT_III,
        2 => DCT_I,
        3 => DST_I,
        _ => throw ArgumentError("Unknown value for DCTTransformType: $value"),
      };
}

/// The bitstream filter state.
///
/// This struct must be allocated with av_bsf_alloc() and freed with
/// av_bsf_free().
///
/// The fields in the struct will only be changed (by the caller or by the
/// filter) as described in their documentation, and are to be considered
/// immutable otherwise.
final class AVBSFContext extends ffi.Struct {
  /// A class for logging and AVOptions
  external ffi.Pointer<AVClass> av_class;

  /// The bitstream filter this context is an instance of.
  external ffi.Pointer<AVBitStreamFilter> filter;

  /// Opaque filter-specific private data. If filter->priv_class is non-NULL,
  /// this is an AVOptions-enabled struct.
  external ffi.Pointer<ffi.Void> priv_data;

  /// Parameters of the input stream. This field is allocated in
  /// av_bsf_alloc(), it needs to be filled by the caller before
  /// av_bsf_init().
  external ffi.Pointer<AVCodecParameters> par_in;

  /// Parameters of the output stream. This field is allocated in
  /// av_bsf_alloc(), it is set by the filter in av_bsf_init().
  external ffi.Pointer<AVCodecParameters> par_out;

  /// The timebase used for the timestamps of the input packets. Set by the
  /// caller before av_bsf_init().
  external AVRational time_base_in;

  /// The timebase used for the timestamps of the output packets. Set by the
  /// filter in av_bsf_init().
  external AVRational time_base_out;
}

final class AVBitStreamFilter extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  /// A list of codec ids supported by the filter, terminated by
  /// AV_CODEC_ID_NONE.
  /// May be NULL, in that case the bitstream filter works with any codec id.
  external ffi.Pointer<ffi.UnsignedInt> codec_ids;

  /// A class for the private data, used to declare bitstream filter private
  /// AVOptions. This field is NULL for bitstream filters that do not declare
  /// any options.
  ///
  /// If this field is non-NULL, the first member of the filter private data
  /// must be a pointer to AVClass, which will be set by libavcodec generic
  /// code to this class.
  external ffi.Pointer<AVClass> priv_class;
}

final class AVBSFList extends ffi.Opaque {}

/// Parse code values:
///
/// Dirac Specification ->
/// 9.6.1  Table 9.1
///
/// VC-2 Specification  ->
/// 10.4.1 Table 10.1
enum DiracParseCodes {
  DIRAC_PCODE_SEQ_HEADER(0),
  DIRAC_PCODE_END_SEQ(16),
  DIRAC_PCODE_AUX(32),
  DIRAC_PCODE_PAD(48),
  DIRAC_PCODE_PICTURE_CODED(8),
  DIRAC_PCODE_PICTURE_RAW(72),
  DIRAC_PCODE_PICTURE_LOW_DEL(200),
  DIRAC_PCODE_PICTURE_HQ(232),
  DIRAC_PCODE_INTER_NOREF_CO1(10),
  DIRAC_PCODE_INTER_NOREF_CO2(9),
  DIRAC_PCODE_INTER_REF_CO1(13),
  DIRAC_PCODE_INTER_REF_CO2(14),
  DIRAC_PCODE_INTRA_REF_CO(12),
  DIRAC_PCODE_INTRA_REF_RAW(76),
  DIRAC_PCODE_INTRA_REF_PICT(204),
  DIRAC_PCODE_MAGIC(1111638852);

  final int value;
  const DiracParseCodes(this.value);

  static DiracParseCodes fromValue(int value) => switch (value) {
        0 => DIRAC_PCODE_SEQ_HEADER,
        16 => DIRAC_PCODE_END_SEQ,
        32 => DIRAC_PCODE_AUX,
        48 => DIRAC_PCODE_PAD,
        8 => DIRAC_PCODE_PICTURE_CODED,
        72 => DIRAC_PCODE_PICTURE_RAW,
        200 => DIRAC_PCODE_PICTURE_LOW_DEL,
        232 => DIRAC_PCODE_PICTURE_HQ,
        10 => DIRAC_PCODE_INTER_NOREF_CO1,
        9 => DIRAC_PCODE_INTER_NOREF_CO2,
        13 => DIRAC_PCODE_INTER_REF_CO1,
        14 => DIRAC_PCODE_INTER_REF_CO2,
        12 => DIRAC_PCODE_INTRA_REF_CO,
        76 => DIRAC_PCODE_INTRA_REF_RAW,
        204 => DIRAC_PCODE_INTRA_REF_PICT,
        1111638852 => DIRAC_PCODE_MAGIC,
        _ => throw ArgumentError("Unknown value for DiracParseCodes: $value"),
      };
}

final class DiracVersionInfo extends ffi.Struct {
  @ffi.Int()
  external int major;

  @ffi.Int()
  external int minor;
}

final class AVDiracSeqHeader extends ffi.Struct {
  @ffi.UnsignedInt()
  external int width;

  @ffi.UnsignedInt()
  external int height;

  /// < 0: 444  1: 422  2: 420
  @ffi.Uint8()
  external int chroma_format;

  @ffi.Uint8()
  external int interlaced;

  @ffi.Uint8()
  external int top_field_first;

  /// < index into dirac_frame_rate[]
  @ffi.Uint8()
  external int frame_rate_index;

  /// < index into dirac_aspect_ratio[]
  @ffi.Uint8()
  external int aspect_ratio_index;

  @ffi.Uint16()
  external int clean_width;

  @ffi.Uint16()
  external int clean_height;

  @ffi.Uint16()
  external int clean_left_offset;

  @ffi.Uint16()
  external int clean_right_offset;

  /// < index into dirac_pixel_range_presets[]
  @ffi.Uint8()
  external int pixel_range_index;

  /// < index into dirac_color_spec_presets[]
  @ffi.Uint8()
  external int color_spec_index;

  @ffi.Int()
  external int profile;

  @ffi.Int()
  external int level;

  external AVRational framerate;

  external AVRational sample_aspect_ratio;

  @ffi.Int()
  external int pix_fmtAsInt;

  AVPixelFormat get pix_fmt => AVPixelFormat.fromValue(pix_fmtAsInt);

  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  AVColorPrimaries get color_primaries =>
      AVColorPrimaries.fromValue(color_primariesAsInt);

  @ffi.UnsignedInt()
  external int color_trcAsInt;

  AVColorTransferCharacteristic get color_trc =>
      AVColorTransferCharacteristic.fromValue(color_trcAsInt);

  @ffi.UnsignedInt()
  external int colorspaceAsInt;

  AVColorSpace get colorspace => AVColorSpace.fromValue(colorspaceAsInt);

  external DiracVersionInfo version;

  @ffi.Int()
  external int bit_depth;
}

/// AVDCT context.
/// @note function pointers can be NULL if the specific features have been
/// disabled at build time.
final class AVDCT extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int16> block)>> idct;

  /// IDCT input permutation.
  /// Several optimized IDCTs need a permutated input (relative to the
  /// normal order of the reference IDCT).
  /// This permutation must be performed before the idct_put/add.
  /// Note, normally this can be merged with the zigzag/alternate scan<br>
  /// An example to avoid confusion:
  /// - (->decode coeffs -> zigzag reorder -> dequant -> reference IDCT -> ...)
  /// - (x -> reference DCT -> reference IDCT -> x)
  /// - (x -> reference DCT -> simple_mmx_perm = idct_permutation
  /// -> simple_idct_mmx -> x)
  /// - (-> decode coeffs -> zigzag reorder -> simple_mmx_perm -> dequant
  /// -> simple_idct_mmx -> ...)
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Uint8> idct_permutation;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int16> block)>> fdct;

  /// DCT algorithm.
  /// must use AVOptions to set this field.
  @ffi.Int()
  external int dct_algo;

  /// IDCT algorithm.
  /// must use AVOptions to set this field.
  @ffi.Int()
  external int idct_algo;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Int16> block,
              ffi.Pointer<ffi.Uint8> pixels, ptrdiff_t line_size)>> get_pixels;

  @ffi.Int()
  external int bits_per_sample;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Int16> block,
              ffi.Pointer<ffi.Uint8> pixels,
              ptrdiff_t line_size)>> get_pixels_unaligned;
}

typedef ptrdiff_t = __darwin_ptrdiff_t;
typedef __darwin_ptrdiff_t = ffi.Long;
typedef Dart__darwin_ptrdiff_t = int;

final class AVVorbisParseContext extends ffi.Opaque {}

final class AVDVProfile extends ffi.Struct {
  @ffi.Int()
  external int dsf;

  @ffi.Int()
  external int video_stype;

  @ffi.Int()
  external int frame_size;

  @ffi.Int()
  external int difseg_size;

  @ffi.Int()
  external int n_difchan;

  external AVRational time_base;

  @ffi.Int()
  external int ltc_divisor;

  @ffi.Int()
  external int height;

  @ffi.Int()
  external int width;

  @ffi.Array.multi([2])
  external ffi.Array<AVRational> sar;

  @ffi.Int()
  external int pix_fmtAsInt;

  AVPixelFormat get pix_fmt => AVPixelFormat.fromValue(pix_fmtAsInt);

  @ffi.Int()
  external int bpm;

  external ffi.Pointer<ffi.Uint8> block_sizes;

  @ffi.Int()
  external int audio_stride;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Int> audio_min_samples;

  @ffi.Array.multi([5])
  external ffi.Array<ffi.Int> audio_samples_dist;

  external ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_shuffle;
}

/// Callback for checking whether to abort blocking functions.
/// AVERROR_EXIT is returned in this case by the interrupted
/// function. During blocking operations, callback is called with
/// opaque as parameter. If the callback returns 1, the
/// blocking operation will be aborted.
///
/// No members can be added to this struct without a major bump, if
/// new elements have been added after this struct in AVFormatContext
/// or AVIOContext.
final class AVIOInterruptCB extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>
      callback;

  external ffi.Pointer<ffi.Void> opaque;
}

/// Directory entry types.
enum AVIODirEntryType {
  AVIO_ENTRY_UNKNOWN(0),
  AVIO_ENTRY_BLOCK_DEVICE(1),
  AVIO_ENTRY_CHARACTER_DEVICE(2),
  AVIO_ENTRY_DIRECTORY(3),
  AVIO_ENTRY_NAMED_PIPE(4),
  AVIO_ENTRY_SYMBOLIC_LINK(5),
  AVIO_ENTRY_SOCKET(6),
  AVIO_ENTRY_FILE(7),
  AVIO_ENTRY_SERVER(8),
  AVIO_ENTRY_SHARE(9),
  AVIO_ENTRY_WORKGROUP(10);

  final int value;
  const AVIODirEntryType(this.value);

  static AVIODirEntryType fromValue(int value) => switch (value) {
        0 => AVIO_ENTRY_UNKNOWN,
        1 => AVIO_ENTRY_BLOCK_DEVICE,
        2 => AVIO_ENTRY_CHARACTER_DEVICE,
        3 => AVIO_ENTRY_DIRECTORY,
        4 => AVIO_ENTRY_NAMED_PIPE,
        5 => AVIO_ENTRY_SYMBOLIC_LINK,
        6 => AVIO_ENTRY_SOCKET,
        7 => AVIO_ENTRY_FILE,
        8 => AVIO_ENTRY_SERVER,
        9 => AVIO_ENTRY_SHARE,
        10 => AVIO_ENTRY_WORKGROUP,
        _ => throw ArgumentError("Unknown value for AVIODirEntryType: $value"),
      };
}

/// Describes single entry of the directory.
///
/// Only name and type fields are guaranteed be set.
/// Rest of fields are protocol or/and platform dependent and might be unknown.
final class AVIODirEntry extends ffi.Struct {
  /// < Filename
  external ffi.Pointer<ffi.Char> name;

  /// < Type of the entry
  @ffi.Int()
  external int type;

  /// < Set to 1 when name is encoded with UTF-8, 0 otherwise.
  /// Name can be encoded with UTF-8 even though 0 is set.
  @ffi.Int()
  external int utf8;

  /// < File size in bytes, -1 if unknown.
  @ffi.Int64()
  external int size;

  /// < Time of last modification in microseconds since unix
  /// epoch, -1 if unknown.
  @ffi.Int64()
  external int modification_timestamp;

  /// < Time of last access in microseconds since unix epoch,
  /// -1 if unknown.
  @ffi.Int64()
  external int access_timestamp;

  /// < Time of last status change in microseconds since unix
  /// epoch, -1 if unknown.
  @ffi.Int64()
  external int status_change_timestamp;

  /// < User ID of owner, -1 if unknown.
  @ffi.Int64()
  external int user_id;

  /// < Group ID of owner, -1 if unknown.
  @ffi.Int64()
  external int group_id;

  /// < Unix file mode, -1 if unknown.
  @ffi.Int64()
  external int filemode;
}

final class AVIODirContext extends ffi.Opaque {}

/// Different data types that can be returned via the AVIO
/// write_data_type callback.
enum AVIODataMarkerType {
  /// Header data; this needs to be present for the stream to be decodeable.
  AVIO_DATA_MARKER_HEADER(0),

  /// A point in the output bytestream where a decoder can start decoding
  /// (i.e. a keyframe). A demuxer/decoder given the data flagged with
  /// AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,
  /// should give decodeable results.
  AVIO_DATA_MARKER_SYNC_POINT(1),

  /// A point in the output bytestream where a demuxer can start parsing
  /// (for non self synchronizing bytestream formats). That is, any
  /// non-keyframe packet start point.
  AVIO_DATA_MARKER_BOUNDARY_POINT(2),

  /// This is any, unlabelled data. It can either be a muxer not marking
  /// any positions at all, it can be an actual boundary/sync point
  /// that the muxer chooses not to mark, or a later part of a packet/fragment
  /// that is cut into multiple write callbacks due to limited IO buffer size.
  AVIO_DATA_MARKER_UNKNOWN(3),

  /// Trailer data, which doesn't contain actual content, but only for
  /// finalizing the output file.
  AVIO_DATA_MARKER_TRAILER(4),

  /// A point in the output bytestream where the underlying AVIOContext might
  /// flush the buffer depending on latency or buffering requirements. Typically
  /// means the end of a packet.
  AVIO_DATA_MARKER_FLUSH_POINT(5);

  final int value;
  const AVIODataMarkerType(this.value);

  static AVIODataMarkerType fromValue(int value) => switch (value) {
        0 => AVIO_DATA_MARKER_HEADER,
        1 => AVIO_DATA_MARKER_SYNC_POINT,
        2 => AVIO_DATA_MARKER_BOUNDARY_POINT,
        3 => AVIO_DATA_MARKER_UNKNOWN,
        4 => AVIO_DATA_MARKER_TRAILER,
        5 => AVIO_DATA_MARKER_FLUSH_POINT,
        _ =>
          throw ArgumentError("Unknown value for AVIODataMarkerType: $value"),
      };
}

/// Bytestream IO Context.
/// New public fields can be added with minor version bumps.
/// Removal, reordering and changes to existing public fields require
/// a major version bump.
/// sizeof(AVIOContext) must not be used outside libav*.
///
/// @note None of the function pointers in AVIOContext should be called
/// directly, they should only be set by the client application
/// when implementing custom I/O. Normally these are set to the
/// function pointers specified in avio_alloc_context()
final class AVIOContext extends ffi.Struct {
  /// A class for private options.
  ///
  /// If this AVIOContext is created by avio_open2(), av_class is set and
  /// passes the options down to protocols.
  ///
  /// If this AVIOContext is manually allocated, then av_class may be set by
  /// the caller.
  ///
  /// warning -- this field can be NULL, be sure to not pass this AVIOContext
  /// to any av_opt_* functions in that case.
  external ffi.Pointer<AVClass> av_class;

  /// < Start of the buffer.
  external ffi.Pointer<ffi.UnsignedChar> buffer;

  /// < Maximum buffer size
  @ffi.Int()
  external int buffer_size;

  /// < Current position in the buffer
  external ffi.Pointer<ffi.UnsignedChar> buf_ptr;

  /// < End of the data, may be less than
  /// buffer+buffer_size if the read function returned
  /// less data than requested, e.g. for streams where
  /// no more data has been received yet.
  external ffi.Pointer<ffi.UnsignedChar> buf_end;

  /// < A private pointer, passed to the read/write/seek/...
  /// functions.
  external ffi.Pointer<ffi.Void> opaque;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
              ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>> read_packet;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void> opaque,
              ffi.Pointer<ffi.Uint8> buf, ffi.Int buf_size)>> write_packet;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Pointer<ffi.Void> opaque, ffi.Int64 offset,
              ffi.Int whence)>> seek;

  /// < position in the file of the current buffer
  @ffi.Int64()
  external int pos;

  /// < true if was unable to read due to error or eof
  @ffi.Int()
  external int eof_reached;

  /// < contains the error code or 0 if no error happened
  @ffi.Int()
  external int error;

  /// < true if open for writing
  @ffi.Int()
  external int write_flag;

  @ffi.Int()
  external int max_packet_size;

  /// < Try to buffer at least this amount of data
  /// before flushing it.
  @ffi.Int()
  external int min_packet_size;

  @ffi.UnsignedLong()
  external int checksum;

  external ffi.Pointer<ffi.UnsignedChar> checksum_ptr;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(
              ffi.UnsignedLong checksum,
              ffi.Pointer<ffi.Uint8> buf,
              ffi.UnsignedInt size)>> update_checksum;

  /// Pause or resume playback for network streaming protocols - e.g. MMS.
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Void> opaque, ffi.Int pause)>>
      read_pause;

  /// Seek to a given timestamp in stream with the specified stream_index.
  /// Needed for some network streaming protocols which don't support seeking
  /// to byte position.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int64 Function(ffi.Pointer<ffi.Void> opaque, ffi.Int stream_index,
              ffi.Int64 timestamp, ffi.Int flags)>> read_seek;

  /// A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
  @ffi.Int()
  external int seekable;

  /// avio_read and avio_write should if possible be satisfied directly
  /// instead of going through a buffer, and avio_seek will always
  /// call the underlying seek function directly.
  @ffi.Int()
  external int direct;

  /// ',' separated list of allowed protocols.
  external ffi.Pointer<ffi.Char> protocol_whitelist;

  /// ',' separated list of disallowed protocols.
  external ffi.Pointer<ffi.Char> protocol_blacklist;

  /// A callback that is used instead of write_packet.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void> opaque,
              ffi.Pointer<ffi.Uint8> buf,
              ffi.Int buf_size,
              ffi.UnsignedInt type,
              ffi.Int64 time)>> write_data_type;

  /// If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,
  /// but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly
  /// small chunks of data returned from the callback).
  @ffi.Int()
  external int ignore_boundary_point;

  /// Maximum reached position before a backward seek in the write buffer,
  /// used keeping track of already written data for a later flush.
  external ffi.Pointer<ffi.UnsignedChar> buf_ptr_max;

  /// Read-only statistic of bytes read for this AVIOContext.
  @ffi.Int64()
  external int bytes_read;

  /// Read-only statistic of bytes written for this AVIOContext.
  @ffi.Int64()
  external int bytes_written;
}

typedef va_list2 = __darwin_va_list;

/// Format I/O context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVFormatContext) must not be used outside libav*, use
/// avformat_alloc_context() to create an AVFormatContext.
///
/// Fields can be accessed through AVOptions (av_opt*),
/// the name string used matches the associated command line parameter name and
/// can be found in libavformat/options_table.h.
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
final class AVFormatContext extends ffi.Struct {
  /// A class for logging and @ref avoptions. Set by avformat_alloc_context().
  /// Exports (de)muxer private options if they exist.
  external ffi.Pointer<AVClass> av_class;

  /// The input container format.
  ///
  /// Demuxing only, set by avformat_open_input().
  external ffi.Pointer<AVInputFormat> iformat;

  /// The output container format.
  ///
  /// Muxing only, must be set by the caller before avformat_write_header().
  external ffi.Pointer<AVOutputFormat> oformat;

  /// Format private data. This is an AVOptions-enabled struct
  /// if and only if iformat/oformat.priv_class is not NULL.
  ///
  /// - muxing: set by avformat_write_header()
  /// - demuxing: set by avformat_open_input()
  external ffi.Pointer<ffi.Void> priv_data;

  /// I/O context.
  ///
  /// - demuxing: either set by the user before avformat_open_input() (then
  /// the user must close it manually) or set by avformat_open_input().
  /// - muxing: set by the user before avformat_write_header(). The caller must
  /// take care of closing / freeing the IO context.
  ///
  /// Do NOT set this field if AVFMT_NOFILE flag is set in
  /// iformat/oformat.flags. In such a case, the (de)muxer will handle
  /// I/O in some other way and this field will be NULL.
  external ffi.Pointer<AVIOContext> pb;

  /// Flags signalling stream properties. A combination of AVFMTCTX_*.
  /// Set by libavformat.
  @ffi.Int()
  external int ctx_flags;

  /// Number of elements in AVFormatContext.streams.
  ///
  /// Set by avformat_new_stream(), must not be modified by any other code.
  @ffi.UnsignedInt()
  external int nb_streams;

  /// A list of all streams in the file. New streams are created with
  /// avformat_new_stream().
  ///
  /// - demuxing: streams are created by libavformat in avformat_open_input().
  /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
  /// appear in av_read_frame().
  /// - muxing: streams are created by the user before avformat_write_header().
  ///
  /// Freed by libavformat in avformat_free_context().
  external ffi.Pointer<ffi.Pointer<AVStream>> streams;

  /// Number of elements in AVFormatContext.stream_groups.
  ///
  /// Set by avformat_stream_group_create(), must not be modified by any other code.
  @ffi.UnsignedInt()
  external int nb_stream_groups;

  /// A list of all stream groups in the file. New groups are created with
  /// avformat_stream_group_create(), and filled with avformat_stream_group_add_stream().
  ///
  /// - demuxing: groups may be created by libavformat in avformat_open_input().
  /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new groups may also
  /// appear in av_read_frame().
  /// - muxing: groups may be created by the user before avformat_write_header().
  ///
  /// Freed by libavformat in avformat_free_context().
  external ffi.Pointer<ffi.Pointer<AVStreamGroup>> stream_groups;

  /// Number of chapters in AVChapter array.
  /// When muxing, chapters are normally written in the file header,
  /// so nb_chapters should normally be initialized before write_header
  /// is called. Some muxers (e.g. mov and mkv) can also write chapters
  /// in the trailer.  To write chapters in the trailer, nb_chapters
  /// must be zero when write_header is called and non-zero when
  /// write_trailer is called.
  /// - muxing: set by user
  /// - demuxing: set by libavformat
  @ffi.UnsignedInt()
  external int nb_chapters;

  external ffi.Pointer<ffi.Pointer<AVChapter>> chapters;

  /// input or output URL. Unlike the old filename field, this field has no
  /// length restriction.
  ///
  /// - demuxing: set by avformat_open_input(), initialized to an empty
  /// string if url parameter was NULL in avformat_open_input().
  /// - muxing: may be set by the caller before calling avformat_write_header()
  /// (or avformat_init_output() if that is called first) to a string
  /// which is freeable by av_free(). Set to an empty string if it
  /// was NULL in avformat_init_output().
  ///
  /// Freed by libavformat in avformat_free_context().
  external ffi.Pointer<ffi.Char> url;

  /// Position of the first frame of the component, in
  /// AV_TIME_BASE fractional seconds. NEVER set this value directly:
  /// It is deduced from the AVStream values.
  ///
  /// Demuxing only, set by libavformat.
  @ffi.Int64()
  external int start_time;

  /// Duration of the stream, in AV_TIME_BASE fractional
  /// seconds. Only set this value if you know none of the individual stream
  /// durations and also do not set any of them. This is deduced from the
  /// AVStream values if not set.
  ///
  /// Demuxing only, set by libavformat.
  @ffi.Int64()
  external int duration;

  /// Total stream bitrate in bit/s, 0 if not
  /// available. Never set it directly if the file_size and the
  /// duration are known as FFmpeg can compute it automatically.
  @ffi.Int64()
  external int bit_rate;

  @ffi.UnsignedInt()
  external int packet_size;

  @ffi.Int()
  external int max_delay;

  /// Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.
  /// Set by the user before avformat_open_input() / avformat_write_header().
  @ffi.Int()
  external int flags;

  /// Maximum number of bytes read from input in order to determine stream
  /// properties. Used when reading the global header and in
  /// avformat_find_stream_info().
  ///
  /// Demuxing only, set by the caller before avformat_open_input().
  ///
  /// @note this is \e not  used for determining the \ref AVInputFormat
  /// "input format"
  /// @see format_probesize
  @ffi.Int64()
  external int probesize;

  /// Maximum duration (in AV_TIME_BASE units) of the data read
  /// from input in avformat_find_stream_info().
  /// Demuxing only, set by the caller before avformat_find_stream_info().
  /// Can be set to 0 to let avformat choose using a heuristic.
  @ffi.Int64()
  external int max_analyze_duration;

  external ffi.Pointer<ffi.Uint8> key;

  @ffi.Int()
  external int keylen;

  @ffi.UnsignedInt()
  external int nb_programs;

  external ffi.Pointer<ffi.Pointer<AVProgram>> programs;

  /// Forced video codec_id.
  /// Demuxing: Set by user.
  @ffi.UnsignedInt()
  external int video_codec_idAsInt;

  AVCodecID get video_codec_id => AVCodecID.fromValue(video_codec_idAsInt);

  /// Forced audio codec_id.
  /// Demuxing: Set by user.
  @ffi.UnsignedInt()
  external int audio_codec_idAsInt;

  AVCodecID get audio_codec_id => AVCodecID.fromValue(audio_codec_idAsInt);

  /// Forced subtitle codec_id.
  /// Demuxing: Set by user.
  @ffi.UnsignedInt()
  external int subtitle_codec_idAsInt;

  AVCodecID get subtitle_codec_id =>
      AVCodecID.fromValue(subtitle_codec_idAsInt);

  /// Forced Data codec_id.
  /// Demuxing: Set by user.
  @ffi.UnsignedInt()
  external int data_codec_idAsInt;

  AVCodecID get data_codec_id => AVCodecID.fromValue(data_codec_idAsInt);

  /// Metadata that applies to the whole file.
  ///
  /// - demuxing: set by libavformat in avformat_open_input()
  /// - muxing: may be set by the caller before avformat_write_header()
  ///
  /// Freed by libavformat in avformat_free_context().
  external ffi.Pointer<AVDictionary> metadata;

  /// Start time of the stream in real world time, in microseconds
  /// since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the
  /// stream was captured at this real world time.
  /// - muxing: Set by the caller before avformat_write_header(). If set to
  /// either 0 or AV_NOPTS_VALUE, then the current wall-time will
  /// be used.
  /// - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that
  /// the value may become known after some number of frames
  /// have been received.
  @ffi.Int64()
  external int start_time_realtime;

  /// The number of frames used for determining the framerate in
  /// avformat_find_stream_info().
  /// Demuxing only, set by the caller before avformat_find_stream_info().
  @ffi.Int()
  external int fps_probe_size;

  /// Error recognition; higher values will detect more errors but may
  /// misdetect some more or less valid parts as errors.
  /// Demuxing only, set by the caller before avformat_open_input().
  @ffi.Int()
  external int error_recognition;

  /// Custom interrupt callbacks for the I/O layer.
  ///
  /// demuxing: set by the user before avformat_open_input().
  /// muxing: set by the user before avformat_write_header()
  /// (mainly useful for AVFMT_NOFILE formats). The callback
  /// should also be passed to avio_open2() if it's used to
  /// open the file.
  external AVIOInterruptCB interrupt_callback;

  /// Flags to enable debugging.
  @ffi.Int()
  external int debug;

  /// The maximum number of streams.
  /// - encoding: unused
  /// - decoding: set by user
  @ffi.Int()
  external int max_streams;

  /// Maximum amount of memory in bytes to use for the index of each stream.
  /// If the index exceeds this size, entries will be discarded as
  /// needed to maintain a smaller size. This can lead to slower or less
  /// accurate seeking (depends on demuxer).
  /// Demuxers for which a full in-memory index is mandatory will ignore
  /// this.
  /// - muxing: unused
  /// - demuxing: set by user
  @ffi.UnsignedInt()
  external int max_index_size;

  /// Maximum amount of memory in bytes to use for buffering frames
  /// obtained from realtime capture devices.
  @ffi.UnsignedInt()
  external int max_picture_buffer;

  /// Maximum buffering duration for interleaving.
  ///
  /// To ensure all the streams are interleaved correctly,
  /// av_interleaved_write_frame() will wait until it has at least one packet
  /// for each stream before actually writing any packets to the output file.
  /// When some streams are "sparse" (i.e. there are large gaps between
  /// successive packets), this can result in excessive buffering.
  ///
  /// This field specifies the maximum difference between the timestamps of the
  /// first and the last packet in the muxing queue, above which libavformat
  /// will output a packet regardless of whether it has queued a packet for all
  /// the streams.
  ///
  /// Muxing only, set by the caller before avformat_write_header().
  @ffi.Int64()
  external int max_interleave_delta;

  /// Maximum number of packets to read while waiting for the first timestamp.
  /// Decoding only.
  @ffi.Int()
  external int max_ts_probe;

  /// Max chunk time in microseconds.
  /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
  /// - encoding: Set by user
  /// - decoding: unused
  @ffi.Int()
  external int max_chunk_duration;

  /// Max chunk size in bytes
  /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
  /// - encoding: Set by user
  /// - decoding: unused
  @ffi.Int()
  external int max_chunk_size;

  /// Maximum number of packets that can be probed
  /// - encoding: unused
  /// - decoding: set by user
  @ffi.Int()
  external int max_probe_packets;

  /// Allow non-standard and experimental extension
  /// @see AVCodecContext.strict_std_compliance
  @ffi.Int()
  external int strict_std_compliance;

  /// Flags indicating events happening on the file, a combination of
  /// AVFMT_EVENT_FLAG_*.
  ///
  /// - demuxing: may be set by the demuxer in avformat_open_input(),
  /// avformat_find_stream_info() and av_read_frame(). Flags must be cleared
  /// by the user once the event has been handled.
  /// - muxing: may be set by the user after avformat_write_header() to
  /// indicate a user-triggered event.  The muxer will clear the flags for
  /// events it has handled in av_[interleaved]_write_frame().
  @ffi.Int()
  external int event_flags;

  /// Avoid negative timestamps during muxing.
  /// Any value of the AVFMT_AVOID_NEG_TS_* constants.
  /// Note, this works better when using av_interleaved_write_frame().
  /// - muxing: Set by user
  /// - demuxing: unused
  @ffi.Int()
  external int avoid_negative_ts;

  /// Audio preload in microseconds.
  /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
  /// - encoding: Set by user
  /// - decoding: unused
  @ffi.Int()
  external int audio_preload;

  /// forces the use of wallclock timestamps as pts/dts of packets
  /// This has undefined results in the presence of B frames.
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.Int()
  external int use_wallclock_as_timestamps;

  /// Skip duration calcuation in estimate_timings_from_pts.
  /// - encoding: unused
  /// - decoding: set by user
  ///
  /// @see duration_probesize
  @ffi.Int()
  external int skip_estimate_duration_from_pts;

  /// avio flags, used to force AVIO_FLAG_DIRECT.
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.Int()
  external int avio_flags;

  /// The duration field can be estimated through various ways, and this field can be used
  /// to know how the duration was estimated.
  /// - encoding: unused
  /// - decoding: Read by user
  @ffi.UnsignedInt()
  external int duration_estimation_methodAsInt;

  AVDurationEstimationMethod get duration_estimation_method =>
      AVDurationEstimationMethod.fromValue(duration_estimation_methodAsInt);

  /// Skip initial bytes when opening stream
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.Int64()
  external int skip_initial_bytes;

  /// Correct single timestamp overflows
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.UnsignedInt()
  external int correct_ts_overflow;

  /// Force seeking to any (also non key) frames.
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.Int()
  external int seek2any;

  /// Flush the I/O context after each packet.
  /// - encoding: Set by user
  /// - decoding: unused
  @ffi.Int()
  external int flush_packets;

  /// format probing score.
  /// The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes
  /// the format.
  /// - encoding: unused
  /// - decoding: set by avformat, read by user
  @ffi.Int()
  external int probe_score;

  /// Maximum number of bytes read from input in order to identify the
  /// \ref AVInputFormat "input format". Only used when the format is not set
  /// explicitly by the caller.
  ///
  /// Demuxing only, set by the caller before avformat_open_input().
  ///
  /// @see probesize
  @ffi.Int()
  external int format_probesize;

  /// ',' separated list of allowed decoders.
  /// If NULL then all are allowed
  /// - encoding: unused
  /// - decoding: set by user
  external ffi.Pointer<ffi.Char> codec_whitelist;

  /// ',' separated list of allowed demuxers.
  /// If NULL then all are allowed
  /// - encoding: unused
  /// - decoding: set by user
  external ffi.Pointer<ffi.Char> format_whitelist;

  /// ',' separated list of allowed protocols.
  /// - encoding: unused
  /// - decoding: set by user
  external ffi.Pointer<ffi.Char> protocol_whitelist;

  /// ',' separated list of disallowed protocols.
  /// - encoding: unused
  /// - decoding: set by user
  external ffi.Pointer<ffi.Char> protocol_blacklist;

  /// IO repositioned flag.
  /// This is set by avformat when the underlaying IO context read pointer
  /// is repositioned, for example when doing byte based seeking.
  /// Demuxers can use the flag to detect such changes.
  @ffi.Int()
  external int io_repositioned;

  /// Forced video codec.
  /// This allows forcing a specific decoder, even when there are multiple with
  /// the same codec_id.
  /// Demuxing: Set by user
  external ffi.Pointer<AVCodec> video_codec;

  /// Forced audio codec.
  /// This allows forcing a specific decoder, even when there are multiple with
  /// the same codec_id.
  /// Demuxing: Set by user
  external ffi.Pointer<AVCodec> audio_codec;

  /// Forced subtitle codec.
  /// This allows forcing a specific decoder, even when there are multiple with
  /// the same codec_id.
  /// Demuxing: Set by user
  external ffi.Pointer<AVCodec> subtitle_codec;

  /// Forced data codec.
  /// This allows forcing a specific decoder, even when there are multiple with
  /// the same codec_id.
  /// Demuxing: Set by user
  external ffi.Pointer<AVCodec> data_codec;

  /// Number of bytes to be written as padding in a metadata header.
  /// Demuxing: Unused.
  /// Muxing: Set by user.
  @ffi.Int()
  external int metadata_header_padding;

  /// User data.
  /// This is a place for some private data of the user.
  external ffi.Pointer<ffi.Void> opaque;

  /// Callback used by devices to communicate with application.
  external av_format_control_message control_message_cb;

  /// Output timestamp offset, in microseconds.
  /// Muxing: set by user
  @ffi.Int64()
  external int output_ts_offset;

  /// dump format separator.
  /// can be ", " or "\n      " or anything else
  /// - muxing: Set by user.
  /// - demuxing: Set by user.
  external ffi.Pointer<ffi.Uint8> dump_separator;

  /// A callback for opening new IO streams.
  ///
  /// Whenever a muxer or a demuxer needs to open an IO stream (typically from
  /// avformat_open_input() for demuxers, but for certain formats can happen at
  /// other times as well), it will call this callback to obtain an IO context.
  ///
  /// @param s the format context
  /// @param pb on success, the newly opened IO context should be returned here
  /// @param url the url to open
  /// @param flags a combination of AVIO_FLAG_*
  /// @param options a dictionary of additional options, with the same
  /// semantics as in avio_open2()
  /// @return 0 on success, a negative AVERROR code on failure
  ///
  /// @note Certain muxers and demuxers do nesting, i.e. they open one or more
  /// additional internal format contexts. Thus the AVFormatContext pointer
  /// passed to this callback may be different from the one facing the caller.
  /// It will, however, have the same 'opaque' field.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFormatContext> s,
              ffi.Pointer<ffi.Pointer<AVIOContext>> pb,
              ffi.Pointer<ffi.Char> url,
              ffi.Int flags,
              ffi.Pointer<ffi.Pointer<AVDictionary>> options)>> io_open;

  /// A callback for closing the streams opened with AVFormatContext.io_open().
  ///
  /// Using this is preferred over io_close, because this can return an error.
  /// Therefore this callback is used instead of io_close by the generic
  /// libavformat code if io_close is NULL or the default.
  ///
  /// @param s the format context
  /// @param pb IO context to be closed and freed
  /// @return 0 on success, a negative AVERROR code on failure
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<AVFormatContext> s, ffi.Pointer<AVIOContext> pb)>>
      io_close2;

  /// Maximum number of bytes read from input in order to determine stream durations
  /// when using estimate_timings_from_pts in avformat_find_stream_info().
  /// Demuxing only, set by the caller before avformat_find_stream_info().
  /// Can be set to 0 to let avformat choose using a heuristic.
  ///
  /// @see skip_estimate_duration_from_pts
  @ffi.Int64()
  external int duration_probesize;
}

/// @addtogroup lavf_decoding
/// @{
final class AVInputFormat extends ffi.Struct {
  /// A comma separated list of short names for the format. New names
  /// may be appended with a minor bump.
  external ffi.Pointer<ffi.Char> name;

  /// Descriptive name for the format, meant to be more human-readable
  /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
  /// to define it.
  external ffi.Pointer<ffi.Char> long_name;

  /// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
  /// AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
  /// AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
  @ffi.Int()
  external int flags;

  /// If extensions are defined, then no probe is done. You should
  /// usually not use extension format guessing because it is not
  /// reliable enough
  external ffi.Pointer<ffi.Char> extensions;

  external ffi.Pointer<ffi.Pointer<AVCodecTag>> codec_tag;

  /// < AVClass for the private context
  external ffi.Pointer<AVClass> priv_class;

  /// Comma-separated list of mime types.
  /// It is used check for matching mime types while probing.
  /// @see av_probe_input_format2
  external ffi.Pointer<ffi.Char> mime_type;
}

/// /
final class AVCodecTag extends ffi.Opaque {}

/// @addtogroup lavf_encoding
/// @{
final class AVOutputFormat extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  /// Descriptive name for the format, meant to be more human-readable
  /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
  /// to define it.
  external ffi.Pointer<ffi.Char> long_name;

  external ffi.Pointer<ffi.Char> mime_type;

  /// < comma-separated filename extensions
  external ffi.Pointer<ffi.Char> extensions;

  /// < default audio codec
  @ffi.UnsignedInt()
  external int audio_codecAsInt;

  AVCodecID get audio_codec => AVCodecID.fromValue(audio_codecAsInt);

  /// < default video codec
  @ffi.UnsignedInt()
  external int video_codecAsInt;

  AVCodecID get video_codec => AVCodecID.fromValue(video_codecAsInt);

  /// < default subtitle codec
  @ffi.UnsignedInt()
  external int subtitle_codecAsInt;

  AVCodecID get subtitle_codec => AVCodecID.fromValue(subtitle_codecAsInt);

  /// can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,
  /// AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
  /// AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS,
  /// AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE
  @ffi.Int()
  external int flags;

  /// List of supported codec_id-codec_tag pairs, ordered by "better
  /// choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
  external ffi.Pointer<ffi.Pointer<AVCodecTag>> codec_tag;

  /// < AVClass for the private context
  external ffi.Pointer<AVClass> priv_class;
}

/// Stream structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVStream) must not be used outside libav*.
final class AVStream extends ffi.Struct {
  /// A class for @ref avoptions. Set on stream creation.
  external ffi.Pointer<AVClass> av_class;

  /// < stream index in AVFormatContext
  @ffi.Int()
  external int index;

  /// Format-specific stream ID.
  /// decoding: set by libavformat
  /// encoding: set by the user, replaced by libavformat if left unset
  @ffi.Int()
  external int id;

  /// Codec parameters associated with this stream. Allocated and freed by
  /// libavformat in avformat_new_stream() and avformat_free_context()
  /// respectively.
  ///
  /// - demuxing: filled by libavformat on stream creation or in
  /// avformat_find_stream_info()
  /// - muxing: filled by the caller before avformat_write_header()
  external ffi.Pointer<AVCodecParameters> codecpar;

  external ffi.Pointer<ffi.Void> priv_data;

  /// This is the fundamental unit of time (in seconds) in terms
  /// of which frame timestamps are represented.
  ///
  /// decoding: set by libavformat
  /// encoding: May be set by the caller before avformat_write_header() to
  /// provide a hint to the muxer about the desired timebase. In
  /// avformat_write_header(), the muxer will overwrite this field
  /// with the timebase that will actually be used for the timestamps
  /// written into the file (which may or may not be related to the
  /// user-provided one, depending on the format).
  external AVRational time_base;

  /// Decoding: pts of the first frame of the stream in presentation order, in stream time base.
  /// Only set this if you are absolutely 100% sure that the value you set
  /// it to really is the pts of the first frame.
  /// This may be undefined (AV_NOPTS_VALUE).
  /// @note The ASF header does NOT contain a correct start_time the ASF
  /// demuxer must NOT set this.
  @ffi.Int64()
  external int start_time;

  /// Decoding: duration of the stream, in stream time base.
  /// If a source file does not specify a duration, but does specify
  /// a bitrate, this value will be estimated from bitrate and file size.
  ///
  /// Encoding: May be set by the caller before avformat_write_header() to
  /// provide a hint to the muxer about the estimated duration.
  @ffi.Int64()
  external int duration;

  /// < number of frames in this stream if known or 0
  @ffi.Int64()
  external int nb_frames;

  /// Stream disposition - a combination of AV_DISPOSITION_* flags.
  /// - demuxing: set by libavformat when creating the stream or in
  /// avformat_find_stream_info().
  /// - muxing: may be set by the caller before avformat_write_header().
  @ffi.Int()
  external int disposition;

  /// < Selects which packets can be discarded at will and do not need to be demuxed.
  @ffi.Int()
  external int discardAsInt;

  AVDiscard get discard => AVDiscard.fromValue(discardAsInt);

  /// sample aspect ratio (0 if unknown)
  /// - encoding: Set by user.
  /// - decoding: Set by libavformat.
  external AVRational sample_aspect_ratio;

  external ffi.Pointer<AVDictionary> metadata;

  /// Average framerate
  ///
  /// - demuxing: May be set by libavformat when creating the stream or in
  /// avformat_find_stream_info().
  /// - muxing: May be set by the caller before avformat_write_header().
  external AVRational avg_frame_rate;

  /// For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet
  /// will contain the attached picture.
  ///
  /// decoding: set by libavformat, must not be modified by the caller.
  /// encoding: unused
  external AVPacket attached_pic;

  /// An array of side data that applies to the whole stream (i.e. the
  /// container does not allow it to change between packets).
  ///
  /// There may be no overlap between the side data in this array and side data
  /// in the packets. I.e. a given side data is either exported by the muxer
  /// (demuxing) / set by the caller (muxing) in this array, then it never
  /// appears in the packets, or the side data is exported / sent through
  /// the packets (always in the first packet where the value becomes known or
  /// changes), then it does not appear in this array.
  ///
  /// - demuxing: Set by libavformat when the stream is created.
  /// - muxing: May be set by the caller before avformat_write_header().
  ///
  /// Freed by libavformat in avformat_free_context().
  ///
  /// @deprecated use AVStream's @ref AVCodecParameters.coded_side_data
  /// "codecpar side data".
  external ffi.Pointer<AVPacketSideData> side_data;

  /// The number of elements in the AVStream.side_data array.
  ///
  /// @deprecated use AVStream's @ref AVCodecParameters.nb_coded_side_data
  /// "codecpar side data".
  @ffi.Int()
  external int nb_side_data;

  /// Flags indicating events happening on the stream, a combination of
  /// AVSTREAM_EVENT_FLAG_*.
  ///
  /// - demuxing: may be set by the demuxer in avformat_open_input(),
  /// avformat_find_stream_info() and av_read_frame(). Flags must be cleared
  /// by the user once the event has been handled.
  /// - muxing: may be set by the user after avformat_write_header(). to
  /// indicate a user-triggered event.  The muxer will clear the flags for
  /// events it has handled in av_[interleaved]_write_frame().
  @ffi.Int()
  external int event_flags;

  /// Real base framerate of the stream.
  /// This is the lowest framerate with which all timestamps can be
  /// represented accurately (it is the least common multiple of all
  /// framerates in the stream). Note, this value is just a guess!
  /// For example, if the time base is 1/90000 and all frames have either
  /// approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.
  external AVRational r_frame_rate;

  /// Number of bits in timestamps. Used for wrapping control.
  ///
  /// - demuxing: set by libavformat
  /// - muxing: set by libavformat
  @ffi.Int()
  external int pts_wrap_bits;
}

final class AVStreamGroup extends ffi.Struct {
  /// A class for @ref avoptions. Set by avformat_stream_group_create().
  external ffi.Pointer<AVClass> av_class;

  external ffi.Pointer<ffi.Void> priv_data;

  /// Group index in AVFormatContext.
  @ffi.UnsignedInt()
  external int index;

  /// Group type-specific group ID.
  ///
  /// decoding: set by libavformat
  /// encoding: may set by the user
  @ffi.Int64()
  external int id;

  /// Group type
  ///
  /// decoding: set by libavformat on group creation
  /// encoding: set by avformat_stream_group_create()
  @ffi.UnsignedInt()
  external int typeAsInt;

  AVStreamGroupParamsType get type =>
      AVStreamGroupParamsType.fromValue(typeAsInt);

  external UnnamedUnion3 params;

  /// Metadata that applies to the whole group.
  ///
  /// - demuxing: set by libavformat on group creation
  /// - muxing: may be set by the caller before avformat_write_header()
  ///
  /// Freed by libavformat in avformat_free_context().
  external ffi.Pointer<AVDictionary> metadata;

  /// Number of elements in AVStreamGroup.streams.
  ///
  /// Set by avformat_stream_group_add_stream() must not be modified by any other code.
  @ffi.UnsignedInt()
  external int nb_streams;

  /// A list of streams in the group. New entries are created with
  /// avformat_stream_group_add_stream().
  ///
  /// - demuxing: entries are created by libavformat on group creation.
  /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new entries may also
  /// appear in av_read_frame().
  /// - muxing: entries are created by the user before avformat_write_header().
  ///
  /// Freed by libavformat in avformat_free_context().
  external ffi.Pointer<ffi.Pointer<AVStream>> streams;

  /// Stream group disposition - a combination of AV_DISPOSITION_* flags.
  /// This field currently applies to all defined AVStreamGroupParamsType.
  ///
  /// - demuxing: set by libavformat when creating the group or in
  /// avformat_find_stream_info().
  /// - muxing: may be set by the caller before avformat_write_header().
  @ffi.Int()
  external int disposition;
}

enum AVStreamGroupParamsType {
  AV_STREAM_GROUP_PARAMS_NONE(0),
  AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT(1),
  AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION(2),
  AV_STREAM_GROUP_PARAMS_TILE_GRID(3),
  AV_STREAM_GROUP_PARAMS_LCEVC(4);

  final int value;
  const AVStreamGroupParamsType(this.value);

  static AVStreamGroupParamsType fromValue(int value) => switch (value) {
        0 => AV_STREAM_GROUP_PARAMS_NONE,
        1 => AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT,
        2 => AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION,
        3 => AV_STREAM_GROUP_PARAMS_TILE_GRID,
        4 => AV_STREAM_GROUP_PARAMS_LCEVC,
        _ => throw ArgumentError(
            "Unknown value for AVStreamGroupParamsType: $value"),
      };
}

/// Group type-specific parameters
final class UnnamedUnion3 extends ffi.Union {
  external ffi.Pointer<AVIAMFAudioElement> iamf_audio_element;

  external ffi.Pointer<AVIAMFMixPresentation> iamf_mix_presentation;

  external ffi.Pointer<AVStreamGroupTileGrid> tile_grid;

  external ffi.Pointer<AVStreamGroupLCEVC> lcevc;
}

/// Information on how to combine one or more audio streams, as defined in
/// section 3.6 of IAMF.
///
/// @note The struct should be allocated with av_iamf_audio_element_alloc()
/// and its size is not a part of the public ABI.
final class AVIAMFAudioElement extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  external ffi.Pointer<ffi.Pointer<AVIAMFLayer>> layers;

  /// Number of layers, or channel groups, in the Audio Element.
  /// There may be 6 layers at most, and for @ref audio_element_type
  /// AV_IAMF_AUDIO_ELEMENT_TYPE_SCENE, there may be exactly 1.
  ///
  /// Set by av_iamf_audio_element_add_layer(), must not be
  /// modified by any other code.
  @ffi.UnsignedInt()
  external int nb_layers;

  /// Demixing information used to reconstruct a scalable channel audio
  /// representation.
  /// The @ref AVIAMFParamDefinition.type "type" must be
  /// AV_IAMF_PARAMETER_DEFINITION_DEMIXING.
  external ffi.Pointer<AVIAMFParamDefinition> demixing_info;

  /// Recon gain information used to reconstruct a scalable channel audio
  /// representation.
  /// The @ref AVIAMFParamDefinition.type "type" must be
  /// AV_IAMF_PARAMETER_DEFINITION_RECON_GAIN.
  external ffi.Pointer<AVIAMFParamDefinition> recon_gain_info;

  /// Audio element type as defined in section 3.6 of IAMF.
  @ffi.UnsignedInt()
  external int audio_element_typeAsInt;

  AVIAMFAudioElementType get audio_element_type =>
      AVIAMFAudioElementType.fromValue(audio_element_typeAsInt);

  /// Default weight value as defined in section 3.6 of IAMF.
  @ffi.UnsignedInt()
  external int default_w;
}

/// A layer defining a Channel Layout in the Audio Element.
///
/// When @ref AVIAMFAudioElement.audio_element_type "the parent's Audio Element type"
/// is AV_IAMF_AUDIO_ELEMENT_TYPE_CHANNEL, this corresponds to an Scalable Channel
/// Layout layer as defined in section 3.6.2 of IAMF.
/// For AV_IAMF_AUDIO_ELEMENT_TYPE_SCENE, it is an Ambisonics channel
/// layout as defined in section 3.6.3 of IAMF.
///
/// @note The struct should be allocated with av_iamf_audio_element_add_layer()
/// and its size is not a part of the public ABI.
final class AVIAMFLayer extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  external AVChannelLayout ch_layout;

  /// A bitmask which may contain a combination of AV_IAMF_LAYER_FLAG_* flags.
  @ffi.UnsignedInt()
  external int flags;

  /// Output gain channel flags as defined in section 3.6.2 of IAMF.
  ///
  /// This field is defined only if @ref AVIAMFAudioElement.audio_element_type
  /// "the parent's Audio Element type" is AV_IAMF_AUDIO_ELEMENT_TYPE_CHANNEL,
  /// must be 0 otherwise.
  @ffi.UnsignedInt()
  external int output_gain_flags;

  /// Output gain as defined in section 3.6.2 of IAMF.
  ///
  /// Must be 0 if @ref output_gain_flags is 0.
  external AVRational output_gain;

  /// Ambisonics mode as defined in section 3.6.3 of IAMF.
  ///
  /// This field is defined only if @ref AVIAMFAudioElement.audio_element_type
  /// "the parent's Audio Element type" is AV_IAMF_AUDIO_ELEMENT_TYPE_SCENE.
  ///
  /// If AV_IAMF_AMBISONICS_MODE_MONO, channel_mapping is defined implicitly
  /// (Ambisonic Order) or explicitly (Custom Order with ambi channels) in
  /// @ref ch_layout.
  /// If AV_IAMF_AMBISONICS_MODE_PROJECTION, @ref demixing_matrix must be set.
  @ffi.UnsignedInt()
  external int ambisonics_modeAsInt;

  AVIAMFAmbisonicsMode get ambisonics_mode =>
      AVIAMFAmbisonicsMode.fromValue(ambisonics_modeAsInt);

  /// Demixing matrix as defined in section 3.6.3 of IAMF.
  ///
  /// The length of the array is ch_layout.nb_channels multiplied by the sum of
  /// the amount of streams in the group plus the amount of streams in the group
  /// that are stereo.
  ///
  /// May be set only if @ref ambisonics_mode == AV_IAMF_AMBISONICS_MODE_PROJECTION,
  /// must be NULL otherwise.
  external ffi.Pointer<AVRational> demixing_matrix;
}

/// @}
/// @addtogroup lavu_iamf_audio
/// @{
enum AVIAMFAmbisonicsMode {
  AV_IAMF_AMBISONICS_MODE_MONO(0),
  AV_IAMF_AMBISONICS_MODE_PROJECTION(1);

  final int value;
  const AVIAMFAmbisonicsMode(this.value);

  static AVIAMFAmbisonicsMode fromValue(int value) => switch (value) {
        0 => AV_IAMF_AMBISONICS_MODE_MONO,
        1 => AV_IAMF_AMBISONICS_MODE_PROJECTION,
        _ =>
          throw ArgumentError("Unknown value for AVIAMFAmbisonicsMode: $value"),
      };
}

/// Parameters as defined in section 3.6.1 of IAMF.
///
/// The struct is allocated by av_iamf_param_definition_alloc() along with an
/// array of subblocks, its type depending on the value of type.
/// This array is placed subblocks_offset bytes after the start of this struct.
///
/// @note This struct's size is not a part of the public ABI.
final class AVIAMFParamDefinition extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Offset in bytes from the start of this struct, at which the subblocks
  /// array is located.
  @ffi.Size()
  external int subblocks_offset;

  /// Size in bytes of each element in the subblocks array.
  @ffi.Size()
  external int subblock_size;

  /// Number of subblocks in the array.
  @ffi.UnsignedInt()
  external int nb_subblocks;

  /// Parameters type. Determines the type of the subblock elements.
  @ffi.UnsignedInt()
  external int typeAsInt;

  AVIAMFParamDefinitionType get type =>
      AVIAMFParamDefinitionType.fromValue(typeAsInt);

  /// Identifier for the paremeter substream.
  @ffi.UnsignedInt()
  external int parameter_id;

  /// Sample rate for the paremeter substream. It must not be 0.
  @ffi.UnsignedInt()
  external int parameter_rate;

  /// The accumulated duration of all blocks in this parameter definition,
  /// in units of 1 / @ref parameter_rate.
  ///
  /// May be 0, in which case all duration values should be specified in
  /// another parameter definition referencing the same parameter_id.
  @ffi.UnsignedInt()
  external int duration;

  /// The duration of every subblock in the case where all subblocks, with
  /// the optional exception of the last subblock, have equal durations.
  ///
  /// Must be 0 if subblocks have different durations.
  @ffi.UnsignedInt()
  external int constant_subblock_duration;
}

enum AVIAMFParamDefinitionType {
  /// Subblocks are of struct type AVIAMFMixGain
  AV_IAMF_PARAMETER_DEFINITION_MIX_GAIN(0),

  /// Subblocks are of struct type AVIAMFDemixingInfo
  AV_IAMF_PARAMETER_DEFINITION_DEMIXING(1),

  /// Subblocks are of struct type AVIAMFReconGain
  AV_IAMF_PARAMETER_DEFINITION_RECON_GAIN(2);

  final int value;
  const AVIAMFParamDefinitionType(this.value);

  static AVIAMFParamDefinitionType fromValue(int value) => switch (value) {
        0 => AV_IAMF_PARAMETER_DEFINITION_MIX_GAIN,
        1 => AV_IAMF_PARAMETER_DEFINITION_DEMIXING,
        2 => AV_IAMF_PARAMETER_DEFINITION_RECON_GAIN,
        _ => throw ArgumentError(
            "Unknown value for AVIAMFParamDefinitionType: $value"),
      };
}

enum AVIAMFAudioElementType {
  AV_IAMF_AUDIO_ELEMENT_TYPE_CHANNEL(0),
  AV_IAMF_AUDIO_ELEMENT_TYPE_SCENE(1);

  final int value;
  const AVIAMFAudioElementType(this.value);

  static AVIAMFAudioElementType fromValue(int value) => switch (value) {
        0 => AV_IAMF_AUDIO_ELEMENT_TYPE_CHANNEL,
        1 => AV_IAMF_AUDIO_ELEMENT_TYPE_SCENE,
        _ => throw ArgumentError(
            "Unknown value for AVIAMFAudioElementType: $value"),
      };
}

/// Information on how to render and mix one or more AVIAMFAudioElement to generate
/// the final audio output, as defined in section 3.7 of IAMF.
///
/// @note The struct should be allocated with av_iamf_mix_presentation_alloc()
/// and its size is not a part of the public ABI.
final class AVIAMFMixPresentation extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Array of submixes.
  ///
  /// Set by av_iamf_mix_presentation_add_submix(), must not be modified
  /// by any other code.
  external ffi.Pointer<ffi.Pointer<AVIAMFSubmix>> submixes;

  /// Number of submixes in the presentation.
  ///
  /// Set by av_iamf_mix_presentation_add_submix(), must not be modified
  /// by any other code.
  @ffi.UnsignedInt()
  external int nb_submixes;

  /// A dictionary of strings describing the mix in different languages.
  /// Must have the same amount of entries as every
  /// @ref AVIAMFSubmixElement.annotations "Submix element annotations",
  /// stored in the same order, and with the same key strings.
  ///
  /// @ref AVDictionaryEntry.key "key" is a string conforming to BCP-47
  /// that specifies the language for the string stored in
  /// @ref AVDictionaryEntry.value "value".
  external ffi.Pointer<AVDictionary> annotations;
}

/// Submix layout as defined in section 3.7 of IAMF.
///
/// @note The struct should be allocated with av_iamf_mix_presentation_add_submix()
/// and its size is not a part of the public ABI.
final class AVIAMFSubmix extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Array of submix elements.
  ///
  /// Set by av_iamf_submix_add_element(), must not be modified by any
  /// other code.
  external ffi.Pointer<ffi.Pointer<AVIAMFSubmixElement>> elements;

  /// Number of elements in the submix.
  ///
  /// Set by av_iamf_submix_add_element(), must not be modified by any
  /// other code.
  @ffi.UnsignedInt()
  external int nb_elements;

  /// Array of submix layouts.
  ///
  /// Set by av_iamf_submix_add_layout(), must not be modified by any
  /// other code.
  external ffi.Pointer<ffi.Pointer<AVIAMFSubmixLayout>> layouts;

  /// Number of layouts in the submix.
  ///
  /// Set by av_iamf_submix_add_layout(), must not be modified by any
  /// other code.
  @ffi.UnsignedInt()
  external int nb_layouts;

  /// Information required for post-processing the mixed audio signal to
  /// generate the audio signal for playback.
  /// The @ref AVIAMFParamDefinition.type "type" must be
  /// AV_IAMF_PARAMETER_DEFINITION_MIX_GAIN.
  external ffi.Pointer<AVIAMFParamDefinition> output_mix_config;

  /// Default mix gain value to apply when there are no AVIAMFParamDefinition
  /// with @ref output_mix_config "output_mix_config's"
  /// @ref AVIAMFParamDefinition.parameter_id "parameter_id" available for a
  /// given audio frame.
  external AVRational default_mix_gain;
}

/// Submix element as defined in section 3.7 of IAMF.
///
/// @note The struct should be allocated with av_iamf_submix_add_element()
/// and its size is not a part of the public ABI.
final class AVIAMFSubmixElement extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// The id of the Audio Element this submix element references.
  @ffi.UnsignedInt()
  external int audio_element_id;

  /// Information required required for applying any processing to the
  /// referenced and rendered Audio Element before being summed with other
  /// processed Audio Elements.
  /// The @ref AVIAMFParamDefinition.type "type" must be
  /// AV_IAMF_PARAMETER_DEFINITION_MIX_GAIN.
  external ffi.Pointer<AVIAMFParamDefinition> element_mix_config;

  /// Default mix gain value to apply when there are no AVIAMFParamDefinition
  /// with @ref element_mix_config "element_mix_config's"
  /// @ref AVIAMFParamDefinition.parameter_id "parameter_id" available for a
  /// given audio frame.
  external AVRational default_mix_gain;

  /// A value that indicates whether the referenced channel-based Audio Element
  /// shall be rendered to stereo loudspeakers or spatialized with a binaural
  /// renderer when played back on headphones.
  /// If the Audio Element is not of @ref AVIAMFAudioElement.audio_element_type
  /// "type" AV_IAMF_AUDIO_ELEMENT_TYPE_CHANNEL, then this field is undefined.
  @ffi.UnsignedInt()
  external int headphones_rendering_modeAsInt;

  AVIAMFHeadphonesMode get headphones_rendering_mode =>
      AVIAMFHeadphonesMode.fromValue(headphones_rendering_modeAsInt);

  /// A dictionary of strings describing the submix in different languages.
  /// Must have the same amount of entries as
  /// @ref AVIAMFMixPresentation.annotations "the mix's annotations", stored
  /// in the same order, and with the same key strings.
  ///
  /// @ref AVDictionaryEntry.key "key" is a string conforming to BCP-47 that
  /// specifies the language for the string stored in
  /// @ref AVDictionaryEntry.value "value".
  external ffi.Pointer<AVDictionary> annotations;
}

/// @}
/// @addtogroup lavu_iamf_mix
/// @{
enum AVIAMFHeadphonesMode {
  /// The referenced Audio Element shall be rendered to stereo loudspeakers.
  AV_IAMF_HEADPHONES_MODE_STEREO(0),

  /// The referenced Audio Element shall be rendered with a binaural renderer.
  AV_IAMF_HEADPHONES_MODE_BINAURAL(1);

  final int value;
  const AVIAMFHeadphonesMode(this.value);

  static AVIAMFHeadphonesMode fromValue(int value) => switch (value) {
        0 => AV_IAMF_HEADPHONES_MODE_STEREO,
        1 => AV_IAMF_HEADPHONES_MODE_BINAURAL,
        _ =>
          throw ArgumentError("Unknown value for AVIAMFHeadphonesMode: $value"),
      };
}

/// Submix layout as defined in section 3.7.6 of IAMF.
///
/// @note The struct should be allocated with av_iamf_submix_add_layout()
/// and its size is not a part of the public ABI.
final class AVIAMFSubmixLayout extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  @ffi.UnsignedInt()
  external int layout_typeAsInt;

  AVIAMFSubmixLayoutType get layout_type =>
      AVIAMFSubmixLayoutType.fromValue(layout_typeAsInt);

  /// Channel layout matching one of Sound Systems A to J of ITU-2051-3, plus
  /// 7.1.2ch and 3.1.2ch
  /// If layout_type is not AV_IAMF_SUBMIX_LAYOUT_TYPE_LOUDSPEAKERS, this field
  /// is undefined.
  external AVChannelLayout sound_system;

  /// The program integrated loudness information, as defined in
  /// ITU-1770-4.
  external AVRational integrated_loudness;

  /// The digital (sampled) peak value of the audio signal, as defined
  /// in ITU-1770-4.
  external AVRational digital_peak;

  /// The true peak of the audio signal, as defined in ITU-1770-4.
  external AVRational true_peak;

  /// The Dialogue loudness information, as defined in ITU-1770-4.
  external AVRational dialogue_anchored_loudness;

  /// The Album loudness information, as defined in ITU-1770-4.
  external AVRational album_anchored_loudness;
}

enum AVIAMFSubmixLayoutType {
  /// The layout follows the loudspeaker sound system convention of ITU-2051-3.
  AV_IAMF_SUBMIX_LAYOUT_TYPE_LOUDSPEAKERS(2),

  /// The layout is binaural.
  AV_IAMF_SUBMIX_LAYOUT_TYPE_BINAURAL(3);

  final int value;
  const AVIAMFSubmixLayoutType(this.value);

  static AVIAMFSubmixLayoutType fromValue(int value) => switch (value) {
        2 => AV_IAMF_SUBMIX_LAYOUT_TYPE_LOUDSPEAKERS,
        3 => AV_IAMF_SUBMIX_LAYOUT_TYPE_BINAURAL,
        _ => throw ArgumentError(
            "Unknown value for AVIAMFSubmixLayoutType: $value"),
      };
}

/// AVStreamGroupTileGrid holds information on how to combine several
/// independent images on a single canvas for presentation.
///
/// The output should be a @ref AVStreamGroupTileGrid.background "background"
/// colored @ref AVStreamGroupTileGrid.coded_width "coded_width" x
/// @ref AVStreamGroupTileGrid.coded_height "coded_height" canvas where a
/// @ref AVStreamGroupTileGrid.nb_tiles "nb_tiles" amount of tiles are placed in
/// the order they appear in the @ref AVStreamGroupTileGrid.offsets "offsets"
/// array, at the exact offset described for them. In particular, if two or more
/// tiles overlap, the image with higher index in the
/// @ref AVStreamGroupTileGrid.offsets "offsets" array takes priority.
/// Note that a single image may be used multiple times, i.e. multiple entries
/// in @ref AVStreamGroupTileGrid.offsets "offsets" may have the same value of
/// idx.
///
/// The following is an example of a simple grid with 3 rows and 4 columns:
///
/// +---+---+---+---+
/// | 0 | 1 | 2 | 3 |
/// +---+---+---+---+
/// | 4 | 5 | 6 | 7 |
/// +---+---+---+---+
/// | 8 | 9 |10 |11 |
/// +---+---+---+---+
///
/// Assuming all tiles have a dimension of 512x512, the
/// @ref AVStreamGroupTileGrid.offsets "offset" of the topleft pixel of
/// the first @ref AVStreamGroup.streams "stream" in the group is "0,0", the
/// @ref AVStreamGroupTileGrid.offsets "offset" of the topleft pixel of
/// the second @ref AVStreamGroup.streams "stream" in the group is "512,0", the
/// @ref AVStreamGroupTileGrid.offsets "offset" of the topleft pixel of
/// the fifth @ref AVStreamGroup.streams "stream" in the group is "0,512", the
/// @ref AVStreamGroupTileGrid.offsets "offset", of the topleft pixel of
/// the sixth @ref AVStreamGroup.streams "stream" in the group is "512,512",
/// etc.
///
/// The following is an example of a canvas with overlaping tiles:
///
/// +-----------+
/// |   %%%%%   |
/// |***%%3%%@@@|
/// |**0%%%%%2@@|
/// |***##1@@@@@|
/// |   #####   |
/// +-----------+
///
/// Assuming a canvas with size 1024x1024 and all tiles with a dimension of
/// 512x512, a possible @ref AVStreamGroupTileGrid.offsets "offset" for the
/// topleft pixel of the first @ref AVStreamGroup.streams "stream" in the group
/// would be 0x256, the @ref AVStreamGroupTileGrid.offsets "offset" for the
/// topleft pixel of the second @ref AVStreamGroup.streams "stream" in the group
/// would be 256x512, the @ref AVStreamGroupTileGrid.offsets "offset" for the
/// topleft pixel of the third @ref AVStreamGroup.streams "stream" in the group
/// would be 512x256, and the @ref AVStreamGroupTileGrid.offsets "offset" for
/// the topleft pixel of the fourth @ref AVStreamGroup.streams "stream" in the
/// group would be 256x0.
///
/// sizeof(AVStreamGroupTileGrid) is not a part of the ABI and may only be
/// allocated by avformat_stream_group_create().
final class AVStreamGroupTileGrid extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Amount of tiles in the grid.
  ///
  /// Must be > 0.
  @ffi.UnsignedInt()
  external int nb_tiles;

  /// Width of the canvas.
  ///
  /// Must be > 0.
  @ffi.Int()
  external int coded_width;

  /// Width of the canvas.
  ///
  /// Must be > 0.
  @ffi.Int()
  external int coded_height;

  external ffi.Pointer<UnnamedStruct3> offsets;

  /// The pixel value per channel in RGBA format used if no pixel of any tile
  /// is located at a particular pixel location.
  ///
  /// @see av_image_fill_color().
  /// @see av_parse_color().
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint8> background;

  /// Offset in pixels from the left edge of the canvas where the actual image
  /// meant for presentation starts.
  ///
  /// This field must be >= 0 and < @ref coded_width.
  @ffi.Int()
  external int horizontal_offset;

  /// Offset in pixels from the top edge of the canvas where the actual image
  /// meant for presentation starts.
  ///
  /// This field must be >= 0 and < @ref coded_height.
  @ffi.Int()
  external int vertical_offset;

  /// Width of the final image for presentation.
  ///
  /// Must be > 0 and <= (@ref coded_width - @ref horizontal_offset).
  /// When it's not equal to (@ref coded_width - @ref horizontal_offset), the
  /// result of (@ref coded_width - width - @ref horizontal_offset) is the
  /// amount amount of pixels to be cropped from the right edge of the
  /// final image before presentation.
  @ffi.Int()
  external int width;

  /// Height of the final image for presentation.
  ///
  /// Must be > 0 and <= (@ref coded_height - @ref vertical_offset).
  /// When it's not equal to (@ref coded_height - @ref vertical_offset), the
  /// result of (@ref coded_height - height - @ref vertical_offset) is the
  /// amount amount of pixels to be cropped from the bottom edge of the
  /// final image before presentation.
  @ffi.Int()
  external int height;
}

/// An @ref nb_tiles sized array of offsets in pixels from the topleft edge
/// of the canvas, indicating where each stream should be placed.
/// It must be allocated with the av_malloc() family of functions.
///
/// - demuxing: set by libavformat, must not be modified by the caller.
/// - muxing: set by the caller before avformat_write_header().
///
/// Freed by libavformat in avformat_free_context().
final class UnnamedStruct3 extends ffi.Struct {
  /// Index of the stream in the group this tile references.
  ///
  /// Must be < @ref AVStreamGroup.nb_streams "nb_streams".
  @ffi.UnsignedInt()
  external int idx;

  /// Offset in pixels from the left edge of the canvas where the tile
  /// should be placed.
  @ffi.Int()
  external int horizontal;

  /// Offset in pixels from the top edge of the canvas where the tile
  /// should be placed.
  @ffi.Int()
  external int vertical;
}

/// AVStreamGroupLCEVC is meant to define the relation between video streams
/// and a data stream containing LCEVC enhancement layer NALUs.
///
/// No more than one stream of @ref AVCodecParameters.codec_type "codec_type"
/// AVMEDIA_TYPE_DATA shall be present, and it must be of
/// @ref AVCodecParameters.codec_id "codec_id" AV_CODEC_ID_LCEVC.
final class AVStreamGroupLCEVC extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Index of the LCEVC data stream in AVStreamGroup.
  @ffi.UnsignedInt()
  external int lcevc_index;

  /// Width of the final stream for presentation.
  @ffi.Int()
  external int width;

  /// Height of the final image for presentation.
  @ffi.Int()
  external int height;
}

final class AVChapter extends ffi.Struct {
  /// < unique ID to identify the chapter
  @ffi.Int64()
  external int id;

  /// < time base in which the start/end timestamps are specified
  external AVRational time_base;

  /// < chapter start/end time in time_base units
  @ffi.Int64()
  external int start;

  @ffi.Int64()
  external int end;

  external ffi.Pointer<AVDictionary> metadata;
}

/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVProgram) must not be used outside libav*.
final class AVProgram extends ffi.Struct {
  @ffi.Int()
  external int id;

  @ffi.Int()
  external int flags;

  /// < selects which program to discard and which to feed to the caller
  @ffi.Int()
  external int discardAsInt;

  AVDiscard get discard => AVDiscard.fromValue(discardAsInt);

  external ffi.Pointer<ffi.UnsignedInt> stream_index;

  @ffi.UnsignedInt()
  external int nb_stream_indexes;

  external ffi.Pointer<AVDictionary> metadata;

  @ffi.Int()
  external int program_num;

  @ffi.Int()
  external int pmt_pid;

  @ffi.Int()
  external int pcr_pid;

  @ffi.Int()
  external int pmt_version;

  /// All fields below this line are not part of the public API. They
  /// may not be used outside of libavformat and can be changed and
  /// removed at will.
  /// New public fields should be added right above.
  @ffi.Int64()
  external int start_time;

  @ffi.Int64()
  external int end_time;

  /// < reference dts for wrap detection
  @ffi.Int64()
  external int pts_wrap_reference;

  /// < behavior on wrap detection
  @ffi.Int()
  external int pts_wrap_behavior;
}

/// The duration of a video can be estimated through various ways, and this enum can be used
/// to know how the duration was estimated.
enum AVDurationEstimationMethod {
  /// < Duration accurately estimated from PTSes
  AVFMT_DURATION_FROM_PTS(0),

  /// < Duration estimated from a stream with a known duration
  AVFMT_DURATION_FROM_STREAM(1),

  /// < Duration estimated from bitrate (less accurate)
  AVFMT_DURATION_FROM_BITRATE(2);

  final int value;
  const AVDurationEstimationMethod(this.value);

  static AVDurationEstimationMethod fromValue(int value) => switch (value) {
        0 => AVFMT_DURATION_FROM_PTS,
        1 => AVFMT_DURATION_FROM_STREAM,
        2 => AVFMT_DURATION_FROM_BITRATE,
        _ => throw ArgumentError(
            "Unknown value for AVDurationEstimationMethod: $value"),
      };
}

/// Callback used by devices to communicate with application.
typedef av_format_control_message
    = ffi.Pointer<ffi.NativeFunction<av_format_control_messageFunction>>;
typedef av_format_control_messageFunction = ffi.Int Function(
    ffi.Pointer<AVFormatContext> s,
    ffi.Int type,
    ffi.Pointer<ffi.Void> data,
    ffi.Size data_size);
typedef Dartav_format_control_messageFunction = int Function(
    ffi.Pointer<AVFormatContext> s,
    int type,
    ffi.Pointer<ffi.Void> data,
    int data_size);

/// This structure contains the data a format has to probe a file.
final class AVProbeData extends ffi.Struct {
  external ffi.Pointer<ffi.Char> filename;

  /// < Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero.
  external ffi.Pointer<ffi.UnsignedChar> buf;

  /// < Size of buf except extra allocated bytes
  @ffi.Int()
  external int buf_size;

  /// < mime_type, when known.
  external ffi.Pointer<ffi.Char> mime_type;
}

/// @}
enum AVStreamParseType {
  AVSTREAM_PARSE_NONE(0),

  /// < full parsing and repack
  AVSTREAM_PARSE_FULL(1),

  /// < Only parse headers, do not repack.
  AVSTREAM_PARSE_HEADERS(2),

  /// < full parsing and interpolation of timestamps for frames not starting on a packet boundary
  AVSTREAM_PARSE_TIMESTAMPS(3),

  /// < full parsing and repack of the first frame only, only implemented for H.264 currently
  AVSTREAM_PARSE_FULL_ONCE(4),

  /// < full parsing and repack with timestamp and position generation by parser for raw
  /// this assumes that each packet in the file contains no demuxer level headers and
  /// just codec level data, otherwise position generation would fail
  AVSTREAM_PARSE_FULL_RAW(5);

  final int value;
  const AVStreamParseType(this.value);

  static AVStreamParseType fromValue(int value) => switch (value) {
        0 => AVSTREAM_PARSE_NONE,
        1 => AVSTREAM_PARSE_FULL,
        2 => AVSTREAM_PARSE_HEADERS,
        3 => AVSTREAM_PARSE_TIMESTAMPS,
        4 => AVSTREAM_PARSE_FULL_ONCE,
        5 => AVSTREAM_PARSE_FULL_RAW,
        _ => throw ArgumentError("Unknown value for AVStreamParseType: $value"),
      };
}

final class AVIndexEntry extends ffi.Opaque {}

enum AVTimebaseSource {
  AVFMT_TBCF_AUTO(-1),
  AVFMT_TBCF_DECODER(0),
  AVFMT_TBCF_DEMUXER(1),
  AVFMT_TBCF_R_FRAMERATE(2);

  final int value;
  const AVTimebaseSource(this.value);

  static AVTimebaseSource fromValue(int value) => switch (value) {
        -1 => AVFMT_TBCF_AUTO,
        0 => AVFMT_TBCF_DECODER,
        1 => AVFMT_TBCF_DEMUXER,
        2 => AVFMT_TBCF_R_FRAMERATE,
        _ => throw ArgumentError("Unknown value for AVTimebaseSource: $value"),
      };
}

final class AVDeviceRect extends ffi.Struct {
  /// < x coordinate of top left corner
  @ffi.Int()
  external int x;

  /// < y coordinate of top left corner
  @ffi.Int()
  external int y;

  /// < width
  @ffi.Int()
  external int width;

  /// < height
  @ffi.Int()
  external int height;
}

/// Message types used by avdevice_app_to_dev_control_message().
enum AVAppToDevMessageType {
  /// Dummy message.
  AV_APP_TO_DEV_NONE(1313820229),

  /// Window size change message.
  ///
  /// Message is sent to the device every time the application changes the size
  /// of the window device renders to.
  /// Message should also be sent right after window is created.
  ///
  /// data: AVDeviceRect: new window size.
  AV_APP_TO_DEV_WINDOW_SIZE(1195724621),

  /// Repaint request message.
  ///
  /// Message is sent to the device when window has to be repainted.
  ///
  /// data: AVDeviceRect: area required to be repainted.
  /// NULL: whole area is required to be repainted.
  AV_APP_TO_DEV_WINDOW_REPAINT(1380274241),

  /// Request pause/play.
  ///
  /// Application requests pause/unpause playback.
  /// Mostly usable with devices that have internal buffer.
  /// By default devices are not paused.
  ///
  /// data: NULL
  AV_APP_TO_DEV_PAUSE(1346458912),
  AV_APP_TO_DEV_PLAY(1347174745),
  AV_APP_TO_DEV_TOGGLE_PAUSE(1346458964),

  /// Volume control message.
  ///
  /// Set volume level. It may be device-dependent if volume
  /// is changed per stream or system wide. Per stream volume
  /// change is expected when possible.
  ///
  /// data: double: new volume with range of 0.0 - 1.0.
  AV_APP_TO_DEV_SET_VOLUME(1398165324),

  /// Mute control messages.
  ///
  /// Change mute state. It may be device-dependent if mute status
  /// is changed per stream or system wide. Per stream mute status
  /// change is expected when possible.
  ///
  /// data: NULL.
  AV_APP_TO_DEV_MUTE(541939028),
  AV_APP_TO_DEV_UNMUTE(1431131476),
  AV_APP_TO_DEV_TOGGLE_MUTE(1414354260),

  /// Get volume/mute messages.
  ///
  /// Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or
  /// AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.
  ///
  /// data: NULL.
  AV_APP_TO_DEV_GET_VOLUME(1196838732),
  AV_APP_TO_DEV_GET_MUTE(1196250452);

  final int value;
  const AVAppToDevMessageType(this.value);

  static AVAppToDevMessageType fromValue(int value) => switch (value) {
        1313820229 => AV_APP_TO_DEV_NONE,
        1195724621 => AV_APP_TO_DEV_WINDOW_SIZE,
        1380274241 => AV_APP_TO_DEV_WINDOW_REPAINT,
        1346458912 => AV_APP_TO_DEV_PAUSE,
        1347174745 => AV_APP_TO_DEV_PLAY,
        1346458964 => AV_APP_TO_DEV_TOGGLE_PAUSE,
        1398165324 => AV_APP_TO_DEV_SET_VOLUME,
        541939028 => AV_APP_TO_DEV_MUTE,
        1431131476 => AV_APP_TO_DEV_UNMUTE,
        1414354260 => AV_APP_TO_DEV_TOGGLE_MUTE,
        1196838732 => AV_APP_TO_DEV_GET_VOLUME,
        1196250452 => AV_APP_TO_DEV_GET_MUTE,
        _ => throw ArgumentError(
            "Unknown value for AVAppToDevMessageType: $value"),
      };
}

/// Message types used by avdevice_dev_to_app_control_message().
enum AVDevToAppMessageType {
  /// Dummy message.
  AV_DEV_TO_APP_NONE(1313820229),

  /// Create window buffer message.
  ///
  /// Device requests to create a window buffer. Exact meaning is device-
  /// and application-dependent. Message is sent before rendering first
  /// frame and all one-shot initializations should be done here.
  /// Application is allowed to ignore preferred window buffer size.
  ///
  /// @note: Application is obligated to inform about window buffer size
  /// with AV_APP_TO_DEV_WINDOW_SIZE message.
  ///
  /// data: AVDeviceRect: preferred size of the window buffer.
  /// NULL: no preferred size of the window buffer.
  AV_DEV_TO_APP_CREATE_WINDOW_BUFFER(1111708229),

  /// Prepare window buffer message.
  ///
  /// Device requests to prepare a window buffer for rendering.
  /// Exact meaning is device- and application-dependent.
  /// Message is sent before rendering of each frame.
  ///
  /// data: NULL.
  AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER(1112560197),

  /// Display window buffer message.
  ///
  /// Device requests to display a window buffer.
  /// Message is sent when new frame is ready to be displayed.
  /// Usually buffers need to be swapped in handler of this message.
  ///
  /// data: NULL.
  AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER(1111771475),

  /// Destroy window buffer message.
  ///
  /// Device requests to destroy a window buffer.
  /// Message is sent when device is about to be destroyed and window
  /// buffer is not required anymore.
  ///
  /// data: NULL.
  AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER(1111770451),

  /// Buffer fullness status messages.
  ///
  /// Device signals buffer overflow/underflow.
  ///
  /// data: NULL.
  AV_DEV_TO_APP_BUFFER_OVERFLOW(1112491596),
  AV_DEV_TO_APP_BUFFER_UNDERFLOW(1112884812),

  /// Buffer readable/writable.
  ///
  /// Device informs that buffer is readable/writable.
  /// When possible, device informs how many bytes can be read/write.
  ///
  /// @warning Device may not inform when number of bytes than can be read/write changes.
  ///
  /// data: int64_t: amount of bytes available to read/write.
  /// NULL: amount of bytes available to read/write is not known.
  AV_DEV_TO_APP_BUFFER_READABLE(1112687648),
  AV_DEV_TO_APP_BUFFER_WRITABLE(1113018912),

  /// Mute state change message.
  ///
  /// Device informs that mute state has changed.
  ///
  /// data: int: 0 for not muted state, non-zero for muted state.
  AV_DEV_TO_APP_MUTE_STATE_CHANGED(1129141588),

  /// Volume level change message.
  ///
  /// Device informs that volume level has changed.
  ///
  /// data: double: new volume with range of 0.0 - 1.0.
  AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED(1129729868);

  final int value;
  const AVDevToAppMessageType(this.value);

  static AVDevToAppMessageType fromValue(int value) => switch (value) {
        1313820229 => AV_DEV_TO_APP_NONE,
        1111708229 => AV_DEV_TO_APP_CREATE_WINDOW_BUFFER,
        1112560197 => AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER,
        1111771475 => AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER,
        1111770451 => AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER,
        1112491596 => AV_DEV_TO_APP_BUFFER_OVERFLOW,
        1112884812 => AV_DEV_TO_APP_BUFFER_UNDERFLOW,
        1112687648 => AV_DEV_TO_APP_BUFFER_READABLE,
        1113018912 => AV_DEV_TO_APP_BUFFER_WRITABLE,
        1129141588 => AV_DEV_TO_APP_MUTE_STATE_CHANGED,
        1129729868 => AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED,
        _ => throw ArgumentError(
            "Unknown value for AVDevToAppMessageType: $value"),
      };
}

/// Structure describes basic parameters of the device.
final class AVDeviceInfo extends ffi.Struct {
  /// < device name, format depends on device
  external ffi.Pointer<ffi.Char> device_name;

  /// < human friendly name
  external ffi.Pointer<ffi.Char> device_description;

  /// < array indicating what media types(s), if any, a device can provide. If null, cannot provide any
  external ffi.Pointer<ffi.Int> media_types;

  /// < length of media_types array, 0 if device cannot provide any media types
  @ffi.Int()
  external int nb_media_types;
}

/// List of devices.
final class AVDeviceInfoList extends ffi.Struct {
  /// < list of autodetected devices
  external ffi.Pointer<ffi.Pointer<AVDeviceInfo>> devices;

  /// < number of autodetected devices
  @ffi.Int()
  external int nb_devices;

  /// < index of default device or -1 if no default
  @ffi.Int()
  external int default_device;
}

/// An instance of a filter
final class AVFilterContext extends ffi.Struct {
  /// < needed for av_log() and filters common options
  external ffi.Pointer<AVClass> av_class;

  /// < the AVFilter of which this is an instance
  external ffi.Pointer<AVFilter> filter;

  /// < name of this filter instance
  external ffi.Pointer<ffi.Char> name;

  /// < array of input pads
  external ffi.Pointer<AVFilterPad> input_pads;

  /// < array of pointers to input links
  external ffi.Pointer<ffi.Pointer<AVFilterLink>> inputs;

  /// < number of input pads
  @ffi.UnsignedInt()
  external int nb_inputs;

  /// < array of output pads
  external ffi.Pointer<AVFilterPad> output_pads;

  /// < array of pointers to output links
  external ffi.Pointer<ffi.Pointer<AVFilterLink>> outputs;

  /// < number of output pads
  @ffi.UnsignedInt()
  external int nb_outputs;

  /// < private data for use by the filter
  external ffi.Pointer<ffi.Void> priv;

  /// < filtergraph this filter belongs to
  external ffi.Pointer<AVFilterGraph> graph;

  /// Type of multithreading being allowed/used. A combination of
  /// AVFILTER_THREAD_* flags.
  ///
  /// May be set by the caller before initializing the filter to forbid some
  /// or all kinds of multithreading for this filter. The default is allowing
  /// everything.
  ///
  /// When the filter is initialized, this field is combined using bit AND with
  /// AVFilterGraph.thread_type to get the final mask used for determining
  /// allowed threading types. I.e. a threading type needs to be set in both
  /// to be allowed.
  ///
  /// After the filter is initialized, libavfilter sets this field to the
  /// threading type that is actually used (0 for no multithreading).
  @ffi.Int()
  external int thread_type;

  /// Max number of threads allowed in this filter instance.
  /// If <= 0, its value is ignored.
  /// Overrides global number of threads set per filter graph.
  @ffi.Int()
  external int nb_threads;

  external ffi.Pointer<AVFilterCommand> command_queue;

  /// < enable expression string
  external ffi.Pointer<ffi.Char> enable_str;

  /// < parsed expression (AVExpr*)
  external ffi.Pointer<ffi.Void> enable;

  /// < variable values for the enable expression
  external ffi.Pointer<ffi.Double> var_values;

  /// < the enabled state from the last expression evaluation
  @ffi.Int()
  external int is_disabled;

  /// For filters which will create hardware frames, sets the device the
  /// filter should create them in.  All other filters will ignore this field:
  /// in particular, a filter which consumes or processes hardware frames will
  /// instead use the hw_frames_ctx field in AVFilterLink to carry the
  /// hardware context information.
  ///
  /// May be set by the caller on filters flagged with AVFILTER_FLAG_HWDEVICE
  /// before initializing the filter with avfilter_init_str() or
  /// avfilter_init_dict().
  external ffi.Pointer<AVBufferRef> hw_device_ctx;

  /// Ready status of the filter.
  /// A non-0 value means that the filter needs activating;
  /// a higher value suggests a more urgent activation.
  @ffi.UnsignedInt()
  external int ready;

  /// Sets the number of extra hardware frames which the filter will
  /// allocate on its output links for use in following filters or by
  /// the caller.
  ///
  /// Some hardware filters require all frames that they will use for
  /// output to be defined in advance before filtering starts.  For such
  /// filters, any hardware frame pools used for output must therefore be
  /// of fixed size.  The extra frames set here are on top of any number
  /// that the filter needs internally in order to operate normally.
  ///
  /// This field must be set before the graph containing this filter is
  /// configured.
  @ffi.Int()
  external int extra_hw_frames;
}

/// Filter definition. This defines the pads a filter contains, and all the
/// callback functions used to interact with the filter.
final class AVFilter extends ffi.Struct {
  /// Filter name. Must be non-NULL and unique among filters.
  external ffi.Pointer<ffi.Char> name;

  /// A description of the filter. May be NULL.
  ///
  /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
  external ffi.Pointer<ffi.Char> description;

  /// List of static inputs.
  ///
  /// NULL if there are no (static) inputs. Instances of filters with
  /// AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
  /// this list.
  external ffi.Pointer<AVFilterPad> inputs;

  /// List of static outputs.
  ///
  /// NULL if there are no (static) outputs. Instances of filters with
  /// AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
  /// this list.
  external ffi.Pointer<AVFilterPad> outputs;

  /// A class for the private data, used to declare filter private AVOptions.
  /// This field is NULL for filters that do not declare any options.
  ///
  /// If this field is non-NULL, the first member of the filter private data
  /// must be a pointer to AVClass, which will be set by libavfilter generic
  /// code to this class.
  external ffi.Pointer<AVClass> priv_class;

  /// A combination of AVFILTER_FLAG_*
  @ffi.Int()
  external int flags;

  /// The number of entries in the list of inputs.
  @ffi.Uint8()
  external int nb_inputs;

  /// The number of entries in the list of outputs.
  @ffi.Uint8()
  external int nb_outputs;

  /// This field determines the state of the formats union.
  /// It is an enum FilterFormatsState value.
  @ffi.Uint8()
  external int formats_state;

  /// Filter pre-initialization function
  ///
  /// This callback will be called immediately after the filter context is
  /// allocated, to allow allocating and initing sub-objects.
  ///
  /// If this callback is not NULL, the uninit callback will be called on
  /// allocation failure.
  ///
  /// @return 0 on success,
  /// AVERROR code on failure (but the code will be
  /// dropped and treated as ENOMEM by the calling code)
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext> ctx)>>
      preinit;

  /// Filter initialization function.
  ///
  /// This callback will be called only once during the filter lifetime, after
  /// all the options have been set, but before links between filters are
  /// established and format negotiation is done.
  ///
  /// Basic filter initialization should be done here. Filters with dynamic
  /// inputs and/or outputs should create those inputs/outputs here based on
  /// provided options. No more changes to this filter's inputs/outputs can be
  /// done after this callback.
  ///
  /// This callback must not assume that the filter links exist or frame
  /// parameters are known.
  ///
  /// @ref AVFilter.uninit "uninit" is guaranteed to be called even if
  /// initialization fails, so this callback does not have to clean up on
  /// failure.
  ///
  /// @return 0 on success, a negative AVERROR on failure
  external ffi.Pointer<
      ffi
      .NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext> ctx)>> init;

  /// Filter uninitialization function.
  ///
  /// Called only once right before the filter is freed. Should deallocate any
  /// memory held by the filter, release any buffer references, etc. It does
  /// not need to deallocate the AVFilterContext.priv memory itself.
  ///
  /// This callback may be called even if @ref AVFilter.init "init" was not
  /// called or failed, so it must be prepared to handle such a situation.
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<AVFilterContext> ctx)>>
      uninit;

  external UnnamedUnion4 formats;

  /// < size of private data to allocate for the filter
  @ffi.Int()
  external int priv_size;

  /// < Additional flags for avfilter internal use only.
  @ffi.Int()
  external int flags_internal;

  /// Make the filter instance process a command.
  ///
  /// @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only
  /// @param arg    the argument for the command
  /// @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.
  /// @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be
  /// time consuming then a filter should treat it like an unsupported command
  ///
  /// @returns >=0 on success otherwise an error code.
  /// AVERROR(ENOSYS) on unsupported commands
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterContext>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>> process_command;

  /// Filter activation function.
  ///
  /// Called when any processing is needed from the filter, instead of any
  /// filter_frame and request_frame on pads.
  ///
  /// The function must examine inlinks and outlinks and perform a single
  /// step of processing. If there is nothing to do, the function must do
  /// nothing and not return an error. If more steps are or may be
  /// possible, it must use ff_filter_set_ready() to schedule another
  /// activation.
  external ffi.Pointer<
          ffi
          .NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext> ctx)>>
      activate;
}

final class AVFilterPad extends ffi.Opaque {}

/// The state of the following union is determined by formats_state.
/// See the documentation of enum FilterFormatsState in internal.h.
final class UnnamedUnion4 extends ffi.Union {
  /// Query formats supported by the filter on its inputs and outputs.
  ///
  /// This callback is called after the filter is initialized (so the inputs
  /// and outputs are fixed), shortly before the format negotiation. This
  /// callback may be called more than once.
  ///
  /// This callback must set ::AVFilterLink's
  /// @ref AVFilterFormatsConfig.formats "outcfg.formats"
  /// on every input link and
  /// @ref AVFilterFormatsConfig.formats "incfg.formats"
  /// on every output link to a list of pixel/sample formats that the filter
  /// supports on that link.
  /// For video links, this filter may also set
  /// @ref AVFilterFormatsConfig.color_spaces "incfg.color_spaces"
  /// /
  /// @ref AVFilterFormatsConfig.color_spaces "outcfg.color_spaces"
  /// and @ref AVFilterFormatsConfig.color_ranges "incfg.color_ranges"
  /// /
  /// @ref AVFilterFormatsConfig.color_ranges "outcfg.color_ranges"
  /// analogously.
  /// For audio links, this filter must also set
  /// @ref AVFilterFormatsConfig.samplerates "incfg.samplerates"
  /// /
  /// @ref AVFilterFormatsConfig.samplerates "outcfg.samplerates"
  /// and @ref AVFilterFormatsConfig.channel_layouts "incfg.channel_layouts"
  /// /
  /// @ref AVFilterFormatsConfig.channel_layouts "outcfg.channel_layouts"
  /// analogously.
  ///
  /// This callback must never be NULL if the union is in this state.
  ///
  /// @return zero on success, a negative value corresponding to an
  /// AVERROR code otherwise
  external ffi.Pointer<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<AVFilterContext>)>>
      query_func;

  /// Same as query_func(), except this function writes the results into
  /// provided arrays.
  ///
  /// @param cfg_in  array of input format configurations with as many
  /// members as the filters has inputs (NULL when there are
  /// no inputs);
  /// @param cfg_out array of output format configurations with as many
  /// members as the filters has outputs (NULL when there
  /// are no outputs);
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVFilterContext>,
              ffi.Pointer<ffi.Pointer<AVFilterFormatsConfig>>,
              ffi.Pointer<ffi.Pointer<AVFilterFormatsConfig>>)>> query_func2;

  /// A pointer to an array of admissible pixel formats delimited
  /// by AV_PIX_FMT_NONE. The generic code will use this list
  /// to indicate that this filter supports each of these pixel formats,
  /// provided that all inputs and outputs use the same pixel format.
  ///
  /// In addition to that the generic code will mark all inputs
  /// and all outputs as supporting all color spaces and ranges, as
  /// long as all inputs and outputs use the same color space/range.
  ///
  /// This list must never be NULL if the union is in this state.
  /// The type of all inputs and outputs of filters using this must
  /// be AVMEDIA_TYPE_VIDEO.
  external ffi.Pointer<ffi.Int> pixels_list;

  /// Analogous to pixels, but delimited by AV_SAMPLE_FMT_NONE
  /// and restricted to filters that only have AVMEDIA_TYPE_AUDIO
  /// inputs and outputs.
  ///
  /// In addition to that the generic code will mark all inputs
  /// and all outputs as supporting all sample rates and every
  /// channel count and channel layout, as long as all inputs
  /// and outputs use the same sample rate and channel count/layout.
  external ffi.Pointer<ffi.Int> samples_list;

  /// Equivalent to { pix_fmt, AV_PIX_FMT_NONE } as pixels_list.
  @ffi.Int()
  external int pix_fmtAsInt;

  AVPixelFormat get pix_fmt => AVPixelFormat.fromValue(pix_fmtAsInt);

  /// Equivalent to { sample_fmt, AV_SAMPLE_FMT_NONE } as samples_list.
  @ffi.Int()
  external int sample_fmtAsInt;

  AVSampleFormat get sample_fmt => AVSampleFormat.fromValue(sample_fmtAsInt);
}

/// Lists of formats / etc. supported by an end of a link.
///
/// This structure is directly part of AVFilterLink, in two copies:
/// one for the source filter, one for the destination filter.
///
/// These lists are used for negotiating the format to actually be used,
/// which will be loaded into the format and channel_layout members of
/// AVFilterLink, when chosen.
final class AVFilterFormatsConfig extends ffi.Struct {
  /// List of supported formats (pixel or sample).
  external ffi.Pointer<AVFilterFormats> formats;

  /// Lists of supported sample rates, only for audio.
  external ffi.Pointer<AVFilterFormats> samplerates;

  /// Lists of supported channel layouts, only for audio.
  external ffi.Pointer<AVFilterChannelLayouts> channel_layouts;

  /// < AVColorSpace
  external ffi.Pointer<AVFilterFormats> color_spaces;

  /// < AVColorRange
  external ffi.Pointer<AVFilterFormats> color_ranges;
}

final class AVFilterFormats extends ffi.Opaque {}

final class AVFilterChannelLayouts extends ffi.Opaque {}

/// A link between two filters. This contains pointers to the source and
/// destination filters between which this link exists, and the indexes of
/// the pads involved. In addition, this link also contains the parameters
/// which have been negotiated and agreed upon between the filter, such as
/// image dimensions, format, etc.
///
/// Applications must not normally access the link structure directly.
/// Use the buffersrc and buffersink API instead.
/// In the future, access to the header may be reserved for filters
/// implementation.
final class AVFilterLink extends ffi.Struct {
  /// < source filter
  external ffi.Pointer<AVFilterContext> src;

  /// < output pad on the source filter
  external ffi.Pointer<AVFilterPad> srcpad;

  /// < dest filter
  external ffi.Pointer<AVFilterContext> dst;

  /// < input pad on the dest filter
  external ffi.Pointer<AVFilterPad> dstpad;

  /// < filter media type
  @ffi.Int()
  external int typeAsInt;

  AVMediaType get type => AVMediaType.fromValue(typeAsInt);

  /// < agreed upon media format
  @ffi.Int()
  external int format;

  /// < agreed upon image width
  @ffi.Int()
  external int w;

  /// < agreed upon image height
  @ffi.Int()
  external int h;

  /// < agreed upon sample aspect ratio
  external AVRational sample_aspect_ratio;

  /// < agreed upon YUV color space
  @ffi.UnsignedInt()
  external int colorspaceAsInt;

  AVColorSpace get colorspace => AVColorSpace.fromValue(colorspaceAsInt);

  /// < agreed upon YUV color range
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  /// < samples per second
  @ffi.Int()
  external int sample_rate;

  /// < channel layout of current buffer (see libavutil/channel_layout.h)
  external AVChannelLayout ch_layout;

  /// Define the time base used by the PTS of the frames/samples
  /// which will pass through this link.
  /// During the configuration stage, each filter is supposed to
  /// change only the output timebase, while the timebase of the
  /// input link is assumed to be an unchangeable property.
  external AVRational time_base;

  /// Lists of supported formats / etc. supported by the input filter.
  external AVFilterFormatsConfig incfg;

  /// Lists of supported formats / etc. supported by the output filter.
  external AVFilterFormatsConfig outcfg;
}

final class AVFilterGraph extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  external ffi.Pointer<ffi.Pointer<AVFilterContext>> filters;

  @ffi.UnsignedInt()
  external int nb_filters;

  /// < sws options to use for the auto-inserted scale filters
  external ffi.Pointer<ffi.Char> scale_sws_opts;

  /// Type of multithreading allowed for filters in this graph. A combination
  /// of AVFILTER_THREAD_* flags.
  ///
  /// May be set by the caller at any point, the setting will apply to all
  /// filters initialized after that. The default is allowing everything.
  ///
  /// When a filter in this graph is initialized, this field is combined using
  /// bit AND with AVFilterContext.thread_type to get the final mask used for
  /// determining allowed threading types. I.e. a threading type needs to be
  /// set in both to be allowed.
  @ffi.Int()
  external int thread_type;

  /// Maximum number of threads used by filters in this graph. May be set by
  /// the caller before adding any filters to the filtergraph. Zero (the
  /// default) means that the number of threads is determined automatically.
  @ffi.Int()
  external int nb_threads;

  /// Opaque user data. May be set by the caller to an arbitrary value, e.g. to
  /// be used from callbacks like @ref AVFilterGraph.execute.
  /// Libavfilter will not touch this field in any way.
  external ffi.Pointer<ffi.Void> opaque;

  /// This callback may be set by the caller immediately after allocating the
  /// graph and before adding any filters to it, to provide a custom
  /// multithreading implementation.
  ///
  /// If set, filters with slice threading capability will call this callback
  /// to execute multiple jobs in parallel.
  ///
  /// If this field is left unset, libavfilter will use its internal
  /// implementation, which may or may not be multithreaded depending on the
  /// platform and build options.
  external ffi.Pointer<avfilter_execute_func> execute;

  /// < swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions
  external ffi.Pointer<ffi.Char> aresample_swr_opts;
}

/// A function executing multiple jobs, possibly in parallel.
///
/// @param ctx the filter context to which the jobs belong
/// @param func the function to be called multiple times
/// @param arg the argument to be passed to func
/// @param ret a nb_jobs-sized array to be filled with return values from each
/// invocation of func
/// @param nb_jobs the number of jobs to execute
///
/// @return 0 on success, a negative AVERROR on error
typedef avfilter_execute_func = ffi.NativeFunction<
    ffi.Int Function(
        ffi.Pointer<AVFilterContext> ctx,
        ffi.Pointer<avfilter_action_func> func,
        ffi.Pointer<ffi.Void> arg,
        ffi.Pointer<ffi.Int> ret,
        ffi.Int nb_jobs)>;

/// A function pointer passed to the @ref AVFilterGraph.execute callback to be
/// executed multiple times, possibly in parallel.
///
/// @param ctx the filter context the job belongs to
/// @param arg an opaque parameter passed through from @ref
/// AVFilterGraph.execute
/// @param jobnr the index of the job being executed
/// @param nb_jobs the total number of jobs
///
/// @return 0 on success, a negative AVERROR on error
typedef avfilter_action_func = ffi.NativeFunction<
    ffi.Int Function(ffi.Pointer<AVFilterContext> ctx,
        ffi.Pointer<ffi.Void> arg, ffi.Int jobnr, ffi.Int nb_jobs)>;

final class AVFilterCommand extends ffi.Opaque {}

/// A linked-list of the inputs/outputs of the filter chain.
///
/// This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),
/// where it is used to communicate open (unlinked) inputs and outputs from and
/// to the caller.
/// This struct specifies, per each not connected pad contained in the graph, the
/// filter context and the pad index required for establishing a link.
final class AVFilterInOut extends ffi.Struct {
  /// unique name for this input/output in the list
  external ffi.Pointer<ffi.Char> name;

  /// filter context associated to this input/output
  external ffi.Pointer<AVFilterContext> filter_ctx;

  /// index of the filt_ctx pad to use for linking
  @ffi.Int()
  external int pad_idx;

  /// next input/input in the list, NULL if this is the last
  external ffi.Pointer<AVFilterInOut> next;
}

/// Parameters of a filter's input or output pad.
///
/// Created as a child of AVFilterParams by avfilter_graph_segment_parse().
/// Freed in avfilter_graph_segment_free().
final class AVFilterPadParams extends ffi.Struct {
  /// An av_malloc()'ed string containing the pad label.
  ///
  /// May be av_free()'d and set to NULL by the caller, in which case this pad
  /// will be treated as unlabeled for linking.
  /// May also be replaced by another av_malloc()'ed string.
  external ffi.Pointer<ffi.Char> label;
}

/// Parameters describing a filter to be created in a filtergraph.
///
/// Created as a child of AVFilterGraphSegment by avfilter_graph_segment_parse().
/// Freed in avfilter_graph_segment_free().
final class AVFilterParams extends ffi.Struct {
  /// The filter context.
  ///
  /// Created by avfilter_graph_segment_create_filters() based on
  /// AVFilterParams.filter_name and instance_name.
  ///
  /// Callers may also create the filter context manually, then they should
  /// av_free() filter_name and set it to NULL. Such AVFilterParams instances
  /// are then skipped by avfilter_graph_segment_create_filters().
  external ffi.Pointer<AVFilterContext> filter;

  /// Name of the AVFilter to be used.
  ///
  /// An av_malloc()'ed string, set by avfilter_graph_segment_parse(). Will be
  /// passed to avfilter_get_by_name() by
  /// avfilter_graph_segment_create_filters().
  ///
  /// Callers may av_free() this string and replace it with another one or
  /// NULL. If the caller creates the filter instance manually, this string
  /// MUST be set to NULL.
  ///
  /// When both AVFilterParams.filter an AVFilterParams.filter_name are NULL,
  /// this AVFilterParams instance is skipped by avfilter_graph_segment_*()
  /// functions.
  external ffi.Pointer<ffi.Char> filter_name;

  /// Name to be used for this filter instance.
  ///
  /// An av_malloc()'ed string, may be set by avfilter_graph_segment_parse() or
  /// left NULL. The caller may av_free() this string and replace with another
  /// one or NULL.
  ///
  /// Will be used by avfilter_graph_segment_create_filters() - passed as the
  /// third argument to avfilter_graph_alloc_filter(), then freed and set to
  /// NULL.
  external ffi.Pointer<ffi.Char> instance_name;

  /// Options to be apllied to the filter.
  ///
  /// Filled by avfilter_graph_segment_parse(). Afterwards may be freely
  /// modified by the caller.
  ///
  /// Will be applied to the filter by avfilter_graph_segment_apply_opts()
  /// with an equivalent of av_opt_set_dict2(filter, &opts, AV_OPT_SEARCH_CHILDREN),
  /// i.e. any unapplied options will be left in this dictionary.
  external ffi.Pointer<AVDictionary> opts;

  external ffi.Pointer<ffi.Pointer<AVFilterPadParams>> inputs;

  @ffi.UnsignedInt()
  external int nb_inputs;

  external ffi.Pointer<ffi.Pointer<AVFilterPadParams>> outputs;

  @ffi.UnsignedInt()
  external int nb_outputs;
}

/// A filterchain is a list of filter specifications.
///
/// Created as a child of AVFilterGraphSegment by avfilter_graph_segment_parse().
/// Freed in avfilter_graph_segment_free().
final class AVFilterChain extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<AVFilterParams>> filters;

  @ffi.Size()
  external int nb_filters;
}

/// A parsed representation of a filtergraph segment.
///
/// A filtergraph segment is conceptually a list of filterchains, with some
/// supplementary information (e.g. format conversion flags).
///
/// Created by avfilter_graph_segment_parse(). Must be freed with
/// avfilter_graph_segment_free().
final class AVFilterGraphSegment extends ffi.Struct {
  /// The filtergraph this segment is associated with.
  /// Set by avfilter_graph_segment_parse().
  external ffi.Pointer<AVFilterGraph> graph;

  /// A list of filter chain contained in this segment.
  /// Set in avfilter_graph_segment_parse().
  external ffi.Pointer<ffi.Pointer<AVFilterChain>> chains;

  @ffi.Size()
  external int nb_chains;

  /// A string containing a colon-separated list of key=value options applied
  /// to all scale filters in this segment.
  ///
  /// May be set by avfilter_graph_segment_parse().
  /// The caller may free this string with av_free() and replace it with a
  /// different av_malloc()'ed string.
  external ffi.Pointer<ffi.Char> scale_sws_opts;
}

/// This structure contains the parameters describing the frames that will be
/// passed to this filter.
///
/// It should be allocated with av_buffersrc_parameters_alloc() and freed with
/// av_free(). All the allocated fields in it remain owned by the caller.
final class AVBufferSrcParameters extends ffi.Struct {
  /// video: the pixel format, value corresponds to enum AVPixelFormat
  /// audio: the sample format, value corresponds to enum AVSampleFormat
  @ffi.Int()
  external int format;

  /// The timebase to be used for the timestamps on the input frames.
  external AVRational time_base;

  /// Video only, the display dimensions of the input frames.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// Video only, the sample (pixel) aspect ratio.
  external AVRational sample_aspect_ratio;

  /// Video only, the frame rate of the input video. This field must only be
  /// set to a non-zero value if input stream has a known constant framerate
  /// and should be left at its initial value if the framerate is variable or
  /// unknown.
  external AVRational frame_rate;

  /// Video with a hwaccel pixel format only. This should be a reference to an
  /// AVHWFramesContext instance describing the input frames.
  external ffi.Pointer<AVBufferRef> hw_frames_ctx;

  /// Audio only, the audio sampling rate in samples per second.
  @ffi.Int()
  external int sample_rate;

  /// Audio only, the audio channel layout
  external AVChannelLayout ch_layout;

  /// Video only, the YUV colorspace and range.
  @ffi.UnsignedInt()
  external int color_spaceAsInt;

  AVColorSpace get color_space => AVColorSpace.fromValue(color_spaceAsInt);

  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);
}

/// @defgroup lavu_iamf Immersive Audio Model and Formats
/// @ingroup lavu_audio
///
/// Immersive Audio Model and Formats related functions and defines
///
/// @defgroup lavu_iamf_params Parameter Definition
/// @ingroup lavu_iamf
/// @{
/// Parameters as defined in section 3.6.1 and 3.8 of IAMF.
/// @}
///
/// @defgroup lavu_iamf_audio Audio Element
/// @ingroup lavu_iamf
/// @{
/// Audio Elements as defined in section 3.6 of IAMF.
/// @}
///
/// @defgroup lavu_iamf_mix Mix Presentation
/// @ingroup lavu_iamf
/// @{
/// Mix Presentations as defined in section 3.7 of IAMF.
/// @}
///
/// @addtogroup lavu_iamf_params
/// @{
enum AVIAMFAnimationType {
  AV_IAMF_ANIMATION_TYPE_STEP(0),
  AV_IAMF_ANIMATION_TYPE_LINEAR(1),
  AV_IAMF_ANIMATION_TYPE_BEZIER(2);

  final int value;
  const AVIAMFAnimationType(this.value);

  static AVIAMFAnimationType fromValue(int value) => switch (value) {
        0 => AV_IAMF_ANIMATION_TYPE_STEP,
        1 => AV_IAMF_ANIMATION_TYPE_LINEAR,
        2 => AV_IAMF_ANIMATION_TYPE_BEZIER,
        _ =>
          throw ArgumentError("Unknown value for AVIAMFAnimationType: $value"),
      };
}

/// Mix Gain Parameter Data as defined in section 3.8.1 of IAMF.
///
/// @note This struct's size is not a part of the public ABI.
final class AVIAMFMixGain extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Duration for the given subblock, in units of
  /// 1 / @ref AVIAMFParamDefinition.parameter_rate "parameter_rate".
  /// It must not be 0.
  @ffi.UnsignedInt()
  external int subblock_duration;

  /// The type of animation applied to the parameter values.
  @ffi.UnsignedInt()
  external int animation_typeAsInt;

  AVIAMFAnimationType get animation_type =>
      AVIAMFAnimationType.fromValue(animation_typeAsInt);

  /// Parameter value that is applied at the start of the subblock.
  /// Applies to all defined Animation Types.
  ///
  /// Valid range of values is -128.0 to 128.0
  external AVRational start_point_value;

  /// Parameter value that is applied at the end of the subblock.
  /// Applies only to AV_IAMF_ANIMATION_TYPE_LINEAR and
  /// AV_IAMF_ANIMATION_TYPE_BEZIER Animation Types.
  ///
  /// Valid range of values is -128.0 to 128.0
  external AVRational end_point_value;

  /// Parameter value of the middle control point of a quadratic Bezier
  /// curve, i.e., its y-axis value.
  /// Applies only to AV_IAMF_ANIMATION_TYPE_BEZIER Animation Type.
  ///
  /// Valid range of values is -128.0 to 128.0
  external AVRational control_point_value;

  /// Parameter value of the time of the middle control point of a
  /// quadratic Bezier curve, i.e., its x-axis value.
  /// Applies only to AV_IAMF_ANIMATION_TYPE_BEZIER Animation Type.
  ///
  /// Valid range of values is 0.0 to 1.0
  external AVRational control_point_relative_time;
}

/// Demixing Info Parameter Data as defined in section 3.8.2 of IAMF.
///
/// @note This struct's size is not a part of the public ABI.
final class AVIAMFDemixingInfo extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Duration for the given subblock, in units of
  /// 1 / @ref AVIAMFParamDefinition.parameter_rate "parameter_rate".
  /// It must not be 0.
  @ffi.UnsignedInt()
  external int subblock_duration;

  /// Pre-defined combination of demixing parameters.
  @ffi.UnsignedInt()
  external int dmixp_mode;
}

/// Recon Gain Info Parameter Data as defined in section 3.8.3 of IAMF.
///
/// @note This struct's size is not a part of the public ABI.
final class AVIAMFReconGain extends ffi.Struct {
  external ffi.Pointer<AVClass> av_class;

  /// Duration for the given subblock, in units of
  /// 1 / @ref AVIAMFParamDefinition.parameter_rate "parameter_rate".
  /// It must not be 0.
  @ffi.UnsignedInt()
  external int subblock_duration;

  /// Array of gain values to be applied to each channel for each layer
  /// defined in the Audio Element referencing the parent Parameter Definition.
  /// Values for layers where the AV_IAMF_LAYER_FLAG_RECON_GAIN flag is not set
  /// are undefined.
  ///
  /// Channel order is: FL, C, FR, SL, SR, TFL, TFR, BL, BR, TBL, TBR, LFE
  @ffi.Array.multi([6, 12])
  external ffi.Array<ffi.Array<ffi.Uint8>> recon_gain;
}

final class AVDetectionBBox extends ffi.Struct {
  /// Distance in pixels from the left/top edge of the frame,
  /// together with width and height, defining the bounding box.
  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;

  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;

  /// Detect result with confidence
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> detect_label;

  external AVRational detect_confidence;

  @ffi.Uint32()
  external int classify_count;

  @ffi.Array.multi([4, 64])
  external ffi.Array<ffi.Array<ffi.Char>> classify_labels;

  @ffi.Array.multi([4])
  external ffi.Array<AVRational> classify_confidences;
}

final class AVDetectionBBoxHeader extends ffi.Struct {
  /// Information about how the bounding box is generated.
  /// for example, the DNN model name.
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Char> source;

  /// Number of bounding boxes in the array.
  @ffi.Uint32()
  external int nb_bboxes;

  /// Offset in bytes from the beginning of this structure at which
  /// the array of bounding boxes starts.
  @ffi.Size()
  external int bboxes_offset;

  /// Size of each bounding box in bytes.
  @ffi.Size()
  external int bbox_size;
}

/// Ambient viewing environment metadata as defined by H.274. The values are
/// saved in AVRationals so that they keep their exactness, while allowing for
/// easy access to a double value with f.ex. av_q2d.
///
/// @note sizeof(AVAmbientViewingEnvironment) is not part of the public ABI, and
/// it must be allocated using av_ambient_viewing_environment_alloc.
final class AVAmbientViewingEnvironment extends ffi.Struct {
  /// Environmental illuminance of the ambient viewing environment in lux.
  external AVRational ambient_illuminance;

  /// Normalized x chromaticity coordinate of the environmental ambient light
  /// in the nominal viewing environment according to the CIE 1931 definition
  /// of x and y as specified in ISO/CIE 11664-1.
  external AVRational ambient_light_x;

  /// Normalized y chromaticity coordinate of the environmental ambient light
  /// in the nominal viewing environment according to the CIE 1931 definition
  /// of x and y as specified in ISO/CIE 11664-1.
  external AVRational ambient_light_y;
}

final class AVFifo extends ffi.Opaque {}

/// Callback for writing or reading from a FIFO, passed to (and invoked from) the
/// av_fifo_*_cb() functions. It may be invoked multiple times from a single
/// av_fifo_*_cb() call and may process less data than the maximum size indicated
/// by nb_elems.
///
/// @param opaque the opaque pointer provided to the av_fifo_*_cb() function
/// @param buf the buffer for reading or writing the data, depending on which
/// av_fifo_*_cb function is called
/// @param nb_elems On entry contains the maximum number of elements that can be
/// read from / written into buf. On success, the callback should
/// update it to contain the number of elements actually written.
///
/// @return 0 on success, a negative error code on failure (will be returned from
/// the invoking av_fifo_*_cb() function)
typedef AVFifoCB = ffi.NativeFunction<
    ffi.Int Function(ffi.Pointer<ffi.Void> opaque, ffi.Pointer<ffi.Void> buf,
        ffi.Pointer<ffi.Size> nb_elems)>;

final class AVBlowfish extends ffi.Struct {
  @ffi.Array.multi([18])
  external ffi.Array<ffi.Uint32> p;

  @ffi.Array.multi([4, 256])
  external ffi.Array<ffi.Array<ffi.Uint32>> s;
}

/// ReplayGain information (see
/// http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).
/// The size of this struct is a part of the public ABI.
final class AVReplayGain extends ffi.Struct {
  /// Track replay gain in microbels (divide by 100000 to get the value in dB).
  /// Should be set to INT32_MIN when unknown.
  @ffi.Int32()
  external int track_gain;

  /// Peak track amplitude, with 100000 representing full scale (but values
  /// may overflow). 0 when unknown.
  @ffi.Uint32()
  external int track_peak;

  /// Same as track_gain, but for the whole album.
  @ffi.Int32()
  external int album_gain;

  /// Same as track_peak, but for the whole album,
  @ffi.Uint32()
  external int album_peak;
}

final class AVMurMur3 extends ffi.Opaque {}

/// List of possible 3D Types
enum AVStereo3DType {
  /// Video is not stereoscopic (and metadata has to be there).
  AV_STEREO3D_2D(0),

  /// Views are next to each other.
  ///
  /// @code{.unparsed}
  /// LLLLRRRR
  /// LLLLRRRR
  /// LLLLRRRR
  /// ...
  /// @endcode
  AV_STEREO3D_SIDEBYSIDE(1),

  /// Views are on top of each other.
  ///
  /// @code{.unparsed}
  /// LLLLLLLL
  /// LLLLLLLL
  /// RRRRRRRR
  /// RRRRRRRR
  /// @endcode
  AV_STEREO3D_TOPBOTTOM(2),

  /// Views are alternated temporally.
  ///
  /// @code{.unparsed}
  /// frame0   frame1   frame2   ...
  /// LLLLLLLL RRRRRRRR LLLLLLLL
  /// LLLLLLLL RRRRRRRR LLLLLLLL
  /// LLLLLLLL RRRRRRRR LLLLLLLL
  /// ...      ...      ...
  /// @endcode
  AV_STEREO3D_FRAMESEQUENCE(3),

  /// Views are packed in a checkerboard-like structure per pixel.
  ///
  /// @code{.unparsed}
  /// LRLRLRLR
  /// RLRLRLRL
  /// LRLRLRLR
  /// ...
  /// @endcode
  AV_STEREO3D_CHECKERBOARD(4),

  /// Views are next to each other, but when upscaling
  /// apply a checkerboard pattern.
  ///
  /// @code{.unparsed}
  /// LLLLRRRR          L L L L    R R R R
  /// LLLLRRRR    =>     L L L L  R R R R
  /// LLLLRRRR          L L L L    R R R R
  /// LLLLRRRR           L L L L  R R R R
  /// @endcode
  AV_STEREO3D_SIDEBYSIDE_QUINCUNX(5),

  /// Views are packed per line, as if interlaced.
  ///
  /// @code{.unparsed}
  /// LLLLLLLL
  /// RRRRRRRR
  /// LLLLLLLL
  /// ...
  /// @endcode
  AV_STEREO3D_LINES(6),

  /// Views are packed per column.
  ///
  /// @code{.unparsed}
  /// LRLRLRLR
  /// LRLRLRLR
  /// LRLRLRLR
  /// ...
  /// @endcode
  AV_STEREO3D_COLUMNS(7),

  /// Video is stereoscopic but the packing is unspecified.
  AV_STEREO3D_UNSPEC(8);

  final int value;
  const AVStereo3DType(this.value);

  static AVStereo3DType fromValue(int value) => switch (value) {
        0 => AV_STEREO3D_2D,
        1 => AV_STEREO3D_SIDEBYSIDE,
        2 => AV_STEREO3D_TOPBOTTOM,
        3 => AV_STEREO3D_FRAMESEQUENCE,
        4 => AV_STEREO3D_CHECKERBOARD,
        5 => AV_STEREO3D_SIDEBYSIDE_QUINCUNX,
        6 => AV_STEREO3D_LINES,
        7 => AV_STEREO3D_COLUMNS,
        8 => AV_STEREO3D_UNSPEC,
        _ => throw ArgumentError("Unknown value for AVStereo3DType: $value"),
      };
}

/// List of possible view types.
enum AVStereo3DView {
  /// Frame contains two packed views.
  AV_STEREO3D_VIEW_PACKED(0),

  /// Frame contains only the left view.
  AV_STEREO3D_VIEW_LEFT(1),

  /// Frame contains only the right view.
  AV_STEREO3D_VIEW_RIGHT(2),

  /// Content is unspecified.
  AV_STEREO3D_VIEW_UNSPEC(3);

  final int value;
  const AVStereo3DView(this.value);

  static AVStereo3DView fromValue(int value) => switch (value) {
        0 => AV_STEREO3D_VIEW_PACKED,
        1 => AV_STEREO3D_VIEW_LEFT,
        2 => AV_STEREO3D_VIEW_RIGHT,
        3 => AV_STEREO3D_VIEW_UNSPEC,
        _ => throw ArgumentError("Unknown value for AVStereo3DView: $value"),
      };
}

/// List of possible primary eyes.
enum AVStereo3DPrimaryEye {
  /// Neither eye.
  AV_PRIMARY_EYE_NONE(0),

  /// Left eye.
  AV_PRIMARY_EYE_LEFT(1),

  /// Right eye
  AV_PRIMARY_EYE_RIGHT(2);

  final int value;
  const AVStereo3DPrimaryEye(this.value);

  static AVStereo3DPrimaryEye fromValue(int value) => switch (value) {
        0 => AV_PRIMARY_EYE_NONE,
        1 => AV_PRIMARY_EYE_LEFT,
        2 => AV_PRIMARY_EYE_RIGHT,
        _ =>
          throw ArgumentError("Unknown value for AVStereo3DPrimaryEye: $value"),
      };
}

/// Stereo 3D type: this structure describes how two videos are packed
/// within a single video surface, with additional information as needed.
///
/// @note The struct must be allocated with av_stereo3d_alloc() and
/// its size is not a part of the public ABI.
final class AVStereo3D extends ffi.Struct {
  /// How views are packed within the video.
  @ffi.UnsignedInt()
  external int typeAsInt;

  AVStereo3DType get type => AVStereo3DType.fromValue(typeAsInt);

  /// Additional information about the frame packing.
  @ffi.Int()
  external int flags;

  /// Determines which views are packed.
  @ffi.UnsignedInt()
  external int viewAsInt;

  AVStereo3DView get view => AVStereo3DView.fromValue(viewAsInt);

  /// Which eye is the primary eye when rendering in 2D.
  @ffi.UnsignedInt()
  external int primary_eyeAsInt;

  AVStereo3DPrimaryEye get primary_eye =>
      AVStereo3DPrimaryEye.fromValue(primary_eyeAsInt);

  /// The distance between the centres of the lenses of the camera system,
  /// in micrometers. Zero if unset.
  @ffi.Uint32()
  external int baseline;

  /// Relative shift of the left and right images, which changes the zero parallax plane.
  /// Range is -1.0 to 1.0. Zero if unset.
  external AVRational horizontal_disparity_adjustment;

  /// Horizontal field of view, in degrees. Zero if unset.
  external AVRational horizontal_field_of_view;
}

final class AVComponentDescriptor extends ffi.Struct {
  /// Which of the 4 planes contains the component.
  @ffi.Int()
  external int plane;

  /// Number of elements between 2 horizontally consecutive pixels.
  /// Elements are bits for bitstream formats, bytes otherwise.
  @ffi.Int()
  external int step;

  /// Number of elements before the component of the first pixel.
  /// Elements are bits for bitstream formats, bytes otherwise.
  @ffi.Int()
  external int offset;

  /// Number of least significant bits that must be shifted away
  /// to get the value.
  @ffi.Int()
  external int shift;

  /// Number of bits in the component.
  @ffi.Int()
  external int depth;
}

/// Descriptor that unambiguously describes how the bits of a pixel are
/// stored in the up to 4 data planes of an image. It also stores the
/// subsampling factors and number of components.
///
/// @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
/// and all the YUV variants) AVPixFmtDescriptor just stores how values
/// are stored not what these values represent.
final class AVPixFmtDescriptor extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  /// < The number of components each pixel has, (1-4)
  @ffi.Uint8()
  external int nb_components;

  /// Amount to shift the luma width right to find the chroma width.
  /// For YV12 this is 1 for example.
  /// chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)
  /// The note above is needed to ensure rounding up.
  /// This value only refers to the chroma components.
  @ffi.Uint8()
  external int log2_chroma_w;

  /// Amount to shift the luma height right to find the chroma height.
  /// For YV12 this is 1 for example.
  /// chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)
  /// The note above is needed to ensure rounding up.
  /// This value only refers to the chroma components.
  @ffi.Uint8()
  external int log2_chroma_h;

  /// Combination of AV_PIX_FMT_FLAG_... flags.
  @ffi.Uint64()
  external int flags;

  /// Parameters that describe how pixels are packed.
  /// If the format has 1 or 2 components, then luma is 0.
  /// If the format has 3 or 4 components:
  /// if the RGB flag is set then 0 is red, 1 is green and 2 is blue;
  /// otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.
  ///
  /// If present, the Alpha channel is always the last component.
  @ffi.Array.multi([4])
  external ffi.Array<AVComponentDescriptor> comp;

  /// Alternative comma-separated names.
  external ffi.Pointer<ffi.Char> alias;
}

final class AVSHA extends ffi.Opaque {}

final class AVMotionVector extends ffi.Struct {
  /// Where the current macroblock comes from; negative value when it comes
  /// from the past, positive value when it comes from the future.
  /// XXX: set exact relative ref frame reference instead of a +/- 1 "direction".
  @ffi.Int32()
  external int source;

  /// Width and height of the block.
  @ffi.Uint8()
  external int w;

  @ffi.Uint8()
  external int h;

  /// Absolute source position. Can be outside the frame area.
  @ffi.Int16()
  external int src_x;

  @ffi.Int16()
  external int src_y;

  /// Absolute destination position. Can be outside the frame area.
  @ffi.Int16()
  external int dst_x;

  @ffi.Int16()
  external int dst_y;

  /// Extra flag information.
  /// Currently unused.
  @ffi.Uint64()
  external int flags;

  /// Motion vector
  /// src_x = dst_x + motion_x / motion_scale
  /// src_y = dst_y + motion_y / motion_scale
  @ffi.Int32()
  external int motion_x;

  @ffi.Int32()
  external int motion_y;

  @ffi.Uint16()
  external int motion_scale;
}

/// Context structure for the Lagged Fibonacci PRNG.
/// The exact layout, types and content of this struct may change and should
/// not be accessed directly. Only its `sizeof()` is guaranteed to stay the same
/// to allow easy instanciation.
final class AVLFG extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.UnsignedInt> state;

  @ffi.Int()
  external int index;
}

/// @file
/// @brief Public header for libavutil XTEA algorithm
/// @defgroup lavu_xtea XTEA
/// @ingroup lavu_crypto
/// @{
final class AVXTEA extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint32> key;
}

enum AVCRCId {
  AV_CRC_8_ATM(0),
  AV_CRC_16_ANSI(1),
  AV_CRC_16_CCITT(2),
  AV_CRC_32_IEEE(3),
  AV_CRC_32_IEEE_LE(4),
  AV_CRC_16_ANSI_LE(5),
  AV_CRC_24_IEEE(6),
  AV_CRC_8_EBU(7),
  AV_CRC_MAX(8);

  final int value;
  const AVCRCId(this.value);

  static AVCRCId fromValue(int value) => switch (value) {
        0 => AV_CRC_8_ATM,
        1 => AV_CRC_16_ANSI,
        2 => AV_CRC_16_CCITT,
        3 => AV_CRC_32_IEEE,
        4 => AV_CRC_32_IEEE_LE,
        5 => AV_CRC_16_ANSI_LE,
        6 => AV_CRC_24_IEEE,
        7 => AV_CRC_8_EBU,
        8 => AV_CRC_MAX,
        _ => throw ArgumentError("Unknown value for AVCRCId: $value"),
      };
}

/// @defgroup lavu_crc32 CRC
/// @ingroup lavu_hash
/// CRC (Cyclic Redundancy Check) hash function implementation.
///
/// This module supports numerous CRC polynomials, in addition to the most
/// widely used CRC-32-IEEE. See @ref AVCRCId for a list of available
/// polynomials.
///
/// @{
typedef AVCRC = ffi.Uint32;
typedef DartAVCRC = int;

final class AVMD5 extends ffi.Opaque {}

final class AVCAST5 extends ffi.Opaque {}

/// Projection of the video surface(s) on a sphere.
enum AVSphericalProjection {
  /// Video represents a sphere mapped on a flat surface using
  /// equirectangular projection.
  AV_SPHERICAL_EQUIRECTANGULAR(0),

  /// Video frame is split into 6 faces of a cube, and arranged on a
  /// 3x2 layout. Faces are oriented upwards for the front, left, right,
  /// and back faces. The up face is oriented so the top of the face is
  /// forwards and the down face is oriented so the top of the face is
  /// to the back.
  AV_SPHERICAL_CUBEMAP(1),

  /// Video represents a portion of a sphere mapped on a flat surface
  /// using equirectangular projection. The @ref bounding fields indicate
  /// the position of the current video in a larger surface.
  AV_SPHERICAL_EQUIRECTANGULAR_TILE(2),

  /// Video frame displays as a 180 degree equirectangular projection.
  AV_SPHERICAL_HALF_EQUIRECTANGULAR(3),

  /// Video frame displays on a flat, rectangular 2D surface.
  AV_SPHERICAL_RECTILINEAR(4),

  /// Fisheye projection (Apple).
  /// See: https://developer.apple.com/documentation/coremedia/cmprojectiontype/fisheye
  AV_SPHERICAL_FISHEYE(5);

  final int value;
  const AVSphericalProjection(this.value);

  static AVSphericalProjection fromValue(int value) => switch (value) {
        0 => AV_SPHERICAL_EQUIRECTANGULAR,
        1 => AV_SPHERICAL_CUBEMAP,
        2 => AV_SPHERICAL_EQUIRECTANGULAR_TILE,
        3 => AV_SPHERICAL_HALF_EQUIRECTANGULAR,
        4 => AV_SPHERICAL_RECTILINEAR,
        5 => AV_SPHERICAL_FISHEYE,
        _ => throw ArgumentError(
            "Unknown value for AVSphericalProjection: $value"),
      };
}

/// This structure describes how to handle spherical videos, outlining
/// information about projection, initial layout, and any other view modifier.
///
/// @note The struct must be allocated with av_spherical_alloc() and
/// its size is not a part of the public ABI.
final class AVSphericalMapping extends ffi.Struct {
  /// Projection type.
  @ffi.UnsignedInt()
  external int projectionAsInt;

  AVSphericalProjection get projection =>
      AVSphericalProjection.fromValue(projectionAsInt);

  /// < Rotation around the up vector [-180, 180].
  @ffi.Int32()
  external int yaw;

  /// < Rotation around the right vector [-90, 90].
  @ffi.Int32()
  external int pitch;

  /// < Rotation around the forward vector [-180, 180].
  @ffi.Int32()
  external int roll;

  /// < Distance from the left edge
  @ffi.Uint32()
  external int bound_left;

  /// < Distance from the top edge
  @ffi.Uint32()
  external int bound_top;

  /// < Distance from the right edge
  @ffi.Uint32()
  external int bound_right;

  /// < Distance from the bottom edge
  @ffi.Uint32()
  external int bound_bottom;

  /// Number of pixels to pad from the edge of each cube face.
  ///
  /// @note This value is valid for only for the cubemap projection type
  /// (@ref AV_SPHERICAL_CUBEMAP), and should be ignored in all other
  /// cases.
  @ffi.Uint32()
  external int padding;
}

final class AVAudioFifo extends ffi.Opaque {}

/// @addtogroup lavu_tree AVTree
/// @ingroup lavu_data
///
/// Low-complexity tree container
///
/// Insertion, removal, finding equal, largest which is smaller than and
/// smallest which is larger than, all have O(log n) worst-case complexity.
/// @{
final class AVTreeNode extends ffi.Opaque {}

final class AVThreadMessageQueue extends ffi.Opaque {}

enum AVThreadMessageFlags {
  /// Perform non-blocking operation.
  /// If this flag is set, send and recv operations are non-blocking and
  /// return AVERROR(EAGAIN) immediately if they can not proceed.
  AV_THREAD_MESSAGE_NONBLOCK(1);

  final int value;
  const AVThreadMessageFlags(this.value);

  static AVThreadMessageFlags fromValue(int value) => switch (value) {
        1 => AV_THREAD_MESSAGE_NONBLOCK,
        _ =>
          throw ArgumentError("Unknown value for AVThreadMessageFlags: $value"),
      };
}

/// HDR Vivid three spline params.
final class AVHDRVivid3SplineParams extends ffi.Struct {
  /// The mode of three Spline. the value shall be in the range
  /// of 0 to 3, inclusive.
  @ffi.Int()
  external int th_mode;

  /// three_Spline_TH_enable_MB is in the range of 0.0 to 1.0, inclusive
  /// and in multiples of 1.0/255.
  external AVRational th_enable_mb;

  /// 3Spline_TH_enable of three Spline.
  /// The value shall be in the range of 0.0 to 1.0, inclusive.
  /// and in multiples of 1.0/4095.
  external AVRational th_enable;

  /// 3Spline_TH_Delta1 of three Spline.
  /// The value shall be in the range of 0.0 to 0.25, inclusive,
  /// and in multiples of 0.25/1023.
  external AVRational th_delta1;

  /// 3Spline_TH_Delta2 of three Spline.
  /// The value shall be in the range of 0.0 to 0.25, inclusive,
  /// and in multiples of 0.25/1023.
  external AVRational th_delta2;

  /// 3Spline_enable_Strength of three Spline.
  /// The value shall be in the range of 0.0 to 1.0, inclusive,
  /// and in multiples of 1.0/255.
  external AVRational enable_strength;
}

/// Color tone mapping parameters at a processing window in a dynamic metadata for
/// CUVA 005.1:2021.
final class AVHDRVividColorToneMappingParams extends ffi.Struct {
  /// The nominal maximum display luminance of the targeted system display,
  /// in multiples of 1.0/4095 candelas per square metre. The value shall be in
  /// the range of 0.0 to 1.0, inclusive.
  external AVRational targeted_system_display_maximum_luminance;

  /// This flag indicates that transfer the base paramter(for value of 1)
  @ffi.Int()
  external int base_enable_flag;

  /// base_param_m_p in the base parameter,
  /// in multiples of 1.0/16383. The value shall be in
  /// the range of 0.0 to 1.0, inclusive.
  external AVRational base_param_m_p;

  /// base_param_m_m in the base parameter,
  /// in multiples of 1.0/10. The value shall be in
  /// the range of 0.0 to 6.3, inclusive.
  external AVRational base_param_m_m;

  /// base_param_m_a in the base parameter,
  /// in multiples of 1.0/1023. The value shall be in
  /// the range of 0.0 to 1.0 inclusive.
  external AVRational base_param_m_a;

  /// base_param_m_b in the base parameter,
  /// in multiples of 1/1023. The value shall be in
  /// the range of 0.0 to 1.0, inclusive.
  external AVRational base_param_m_b;

  /// base_param_m_n in the base parameter,
  /// in multiples of 1.0/10. The value shall be in
  /// the range of 0.0 to 6.3, inclusive.
  external AVRational base_param_m_n;

  /// indicates k1_0 in the base parameter,
  /// base_param_k1 <= 1: k1_0 = base_param_k1
  /// base_param_k1 > 1: reserved
  @ffi.Int()
  external int base_param_k1;

  /// indicates k2_0 in the base parameter,
  /// base_param_k2 <= 1: k2_0 = base_param_k2
  /// base_param_k2 > 1: reserved
  @ffi.Int()
  external int base_param_k2;

  /// indicates k3_0 in the base parameter,
  /// base_param_k3 == 1: k3_0 = base_param_k3
  /// base_param_k3 == 2: k3_0 = maximum_maxrgb
  /// base_param_k3 > 2: reserved
  @ffi.Int()
  external int base_param_k3;

  /// This flag indicates that delta mode of base paramter(for value of 1)
  @ffi.Int()
  external int base_param_Delta_enable_mode;

  /// base_param_Delta in the base parameter,
  /// in multiples of 1.0/127. The value shall be in
  /// the range of 0.0 to 1.0, inclusive.
  external AVRational base_param_Delta;

  /// indicates 3Spline_enable_flag in the base parameter,
  /// This flag indicates that transfer three Spline of base paramter(for value of 1)
  @ffi.Int()
  external int three_Spline_enable_flag;

  /// The number of three Spline. The value shall be in the range
  /// of 1 to 2, inclusive.
  @ffi.Int()
  external int three_Spline_num;

  /// The mode of three Spline. the value shall be in the range
  /// of 0 to 3, inclusive.
  /// @deprecated Use three_spline instead
  @ffi.Int()
  external int three_Spline_TH_mode;

  /// three_Spline_TH_enable_MB is in the range of 0.0 to 1.0, inclusive
  /// and in multiples of 1.0/255.
  /// @deprecated Use three_spline instead
  external AVRational three_Spline_TH_enable_MB;

  /// 3Spline_TH_enable of three Spline.
  /// The value shall be in the range of 0.0 to 1.0, inclusive.
  /// and in multiples of 1.0/4095.
  /// @deprecated Use three_spline instead
  external AVRational three_Spline_TH_enable;

  /// 3Spline_TH_Delta1 of three Spline.
  /// The value shall be in the range of 0.0 to 0.25, inclusive,
  /// and in multiples of 0.25/1023.
  /// @deprecated Use three_spline instead
  external AVRational three_Spline_TH_Delta1;

  /// 3Spline_TH_Delta2 of three Spline.
  /// The value shall be in the range of 0.0 to 0.25, inclusive,
  /// and in multiples of 0.25/1023.
  /// @deprecated Use three_spline instead
  external AVRational three_Spline_TH_Delta2;

  /// 3Spline_enable_Strength of three Spline.
  /// The value shall be in the range of 0.0 to 1.0, inclusive,
  /// and in multiples of 1.0/255.
  /// @deprecated Use three_spline instead
  external AVRational three_Spline_enable_Strength;

  @ffi.Array.multi([2])
  external ffi.Array<AVHDRVivid3SplineParams> three_spline;
}

/// Color transform parameters at a processing window in a dynamic metadata for
/// CUVA 005.1:2021.
final class AVHDRVividColorTransformParams extends ffi.Struct {
  /// Indicates the minimum brightness of the displayed content.
  /// The values should be in the range of 0.0 to 1.0,
  /// inclusive and in multiples of 1/4095.
  external AVRational minimum_maxrgb;

  /// Indicates the average brightness of the displayed content.
  /// The values should be in the range of 0.0 to 1.0,
  /// inclusive and in multiples of 1/4095.
  external AVRational average_maxrgb;

  /// Indicates the variance brightness of the displayed content.
  /// The values should be in the range of 0.0 to 1.0,
  /// inclusive and in multiples of 1/4095.
  external AVRational variance_maxrgb;

  /// Indicates the maximum brightness of the displayed content.
  /// The values should be in the range of 0.0 to 1.0, inclusive
  /// and in multiples of 1/4095.
  external AVRational maximum_maxrgb;

  /// This flag indicates that the metadata for the tone mapping function in
  /// the processing window is present (for value of 1).
  @ffi.Int()
  external int tone_mapping_mode_flag;

  /// The number of tone mapping param. The value shall be in the range
  /// of 1 to 2, inclusive.
  @ffi.Int()
  external int tone_mapping_param_num;

  /// The color tone mapping parameters.
  @ffi.Array.multi([2])
  external ffi.Array<AVHDRVividColorToneMappingParams> tm_params;

  /// This flag indicates that the metadata for the color saturation mapping in
  /// the processing window is present (for value of 1).
  @ffi.Int()
  external int color_saturation_mapping_flag;

  /// The number of color saturation param. The value shall be in the range
  /// of 0 to 7, inclusive.
  @ffi.Int()
  external int color_saturation_num;

  /// Indicates the color correction strength parameter.
  /// The values should be in the range of 0.0 to 2.0, inclusive
  /// and in multiples of 1/128.
  @ffi.Array.multi([8])
  external ffi.Array<AVRational> color_saturation_gain;
}

/// This struct represents dynamic metadata for color volume transform -
/// CUVA 005.1:2021 standard
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with
/// av_dynamic_hdr_vivid_alloc() and its size is not a part of
/// the public ABI.
final class AVDynamicHDRVivid extends ffi.Struct {
  /// The system start code. The value shall be set to 0x01.
  @ffi.Uint8()
  external int system_start_code;

  /// The number of processing windows. The value shall be set to 0x01
  /// if the system_start_code is 0x01.
  @ffi.Uint8()
  external int num_windows;

  /// The color transform parameters for every processing window.
  @ffi.Array.multi([3])
  external ffi.Array<AVHDRVividColorTransformParams> params;
}

/// @defgroup lavu_adler32 Adler-32
/// @ingroup lavu_hash
/// Adler-32 hash function implementation.
///
/// @{
typedef AVAdler = ffi.Uint32;
typedef DartAVAdler = int;

enum AVTimecodeFlag {
  /// < timecode is drop frame
  AV_TIMECODE_FLAG_DROPFRAME(1),

  /// < timecode wraps after 24 hours
  AV_TIMECODE_FLAG_24HOURSMAX(2),

  /// < negative time values are allowed
  AV_TIMECODE_FLAG_ALLOWNEGATIVE(4);

  final int value;
  const AVTimecodeFlag(this.value);

  static AVTimecodeFlag fromValue(int value) => switch (value) {
        1 => AV_TIMECODE_FLAG_DROPFRAME,
        2 => AV_TIMECODE_FLAG_24HOURSMAX,
        4 => AV_TIMECODE_FLAG_ALLOWNEGATIVE,
        _ => throw ArgumentError("Unknown value for AVTimecodeFlag: $value"),
      };
}

final class AVTimecode extends ffi.Struct {
  /// < timecode frame start (first base frame number)
  @ffi.Int()
  external int start;

  /// < flags such as drop frame, +24 hours support, ...
  @ffi.Uint32()
  external int flags;

  /// < frame rate in rational form
  external AVRational rate;

  /// < frame per second; must be consistent with the rate field
  @ffi.UnsignedInt()
  external int fps;
}

/// Struct containing luma coefficients to be used for RGB to YUV/YCoCg, or similar
/// calculations.
final class AVLumaCoefficients extends ffi.Struct {
  external AVRational cr;

  external AVRational cg;

  external AVRational cb;
}

/// Struct containing chromaticity x and y values for the standard CIE 1931
/// chromaticity definition.
final class AVCIExy extends ffi.Struct {
  external AVRational x;

  external AVRational y;
}

/// Struct defining the red, green, and blue primary locations in terms of CIE
/// 1931 chromaticity x and y.
final class AVPrimaryCoefficients extends ffi.Struct {
  external AVCIExy r;

  external AVCIExy g;

  external AVCIExy b;
}

/// Struct that contains both white point location and primaries location, providing
/// the complete description of a color gamut.
final class AVColorPrimariesDesc extends ffi.Struct {
  external AVWhitepointCoefficients wp;

  external AVPrimaryCoefficients prim;
}

/// Struct defining white point location in terms of CIE 1931 chromaticity x
/// and y.
typedef AVWhitepointCoefficients = AVCIExy;

/// Function pointer representing a double -> double transfer function that performs
/// an EOTF transfer inversion. This function outputs linear light.
typedef av_csp_trc_function
    = ffi.Pointer<ffi.NativeFunction<av_csp_trc_functionFunction>>;
typedef av_csp_trc_functionFunction = ffi.Double Function(ffi.Double);
typedef Dartav_csp_trc_functionFunction = double Function(double);

final class AVDOVIDecoderConfigurationRecord extends ffi.Struct {
  @ffi.Uint8()
  external int dv_version_major;

  @ffi.Uint8()
  external int dv_version_minor;

  @ffi.Uint8()
  external int dv_profile;

  @ffi.Uint8()
  external int dv_level;

  @ffi.Uint8()
  external int rpu_present_flag;

  @ffi.Uint8()
  external int el_present_flag;

  @ffi.Uint8()
  external int bl_present_flag;

  @ffi.Uint8()
  external int dv_bl_signal_compatibility_id;

  @ffi.Uint8()
  external int dv_md_compression;
}

enum AVDOVICompression {
  AV_DOVI_COMPRESSION_NONE(0),
  AV_DOVI_COMPRESSION_LIMITED(1),
  AV_DOVI_COMPRESSION_RESERVED(2),
  AV_DOVI_COMPRESSION_EXTENDED(3);

  final int value;
  const AVDOVICompression(this.value);

  static AVDOVICompression fromValue(int value) => switch (value) {
        0 => AV_DOVI_COMPRESSION_NONE,
        1 => AV_DOVI_COMPRESSION_LIMITED,
        2 => AV_DOVI_COMPRESSION_RESERVED,
        3 => AV_DOVI_COMPRESSION_EXTENDED,
        _ => throw ArgumentError("Unknown value for AVDOVICompression: $value"),
      };
}

/// Dolby Vision RPU data header.
///
/// @note sizeof(AVDOVIRpuDataHeader) is not part of the public ABI.
final class AVDOVIRpuDataHeader extends ffi.Struct {
  @ffi.Uint8()
  external int rpu_type;

  @ffi.Uint16()
  external int rpu_format;

  @ffi.Uint8()
  external int vdr_rpu_profile;

  @ffi.Uint8()
  external int vdr_rpu_level;

  @ffi.Uint8()
  external int chroma_resampling_explicit_filter_flag;

  @ffi.Uint8()
  external int coef_data_type;

  @ffi.Uint8()
  external int coef_log2_denom;

  @ffi.Uint8()
  external int vdr_rpu_normalized_idc;

  @ffi.Uint8()
  external int bl_video_full_range_flag;

  @ffi.Uint8()
  external int bl_bit_depth;

  @ffi.Uint8()
  external int el_bit_depth;

  @ffi.Uint8()
  external int vdr_bit_depth;

  @ffi.Uint8()
  external int spatial_resampling_filter_flag;

  @ffi.Uint8()
  external int el_spatial_resampling_filter_flag;

  @ffi.Uint8()
  external int disable_residual_flag;

  @ffi.Uint8()
  external int ext_mapping_idc_0_4;

  @ffi.Uint8()
  external int ext_mapping_idc_5_7;
}

enum AVDOVIMappingMethod {
  AV_DOVI_MAPPING_POLYNOMIAL(0),
  AV_DOVI_MAPPING_MMR(1);

  final int value;
  const AVDOVIMappingMethod(this.value);

  static AVDOVIMappingMethod fromValue(int value) => switch (value) {
        0 => AV_DOVI_MAPPING_POLYNOMIAL,
        1 => AV_DOVI_MAPPING_MMR,
        _ =>
          throw ArgumentError("Unknown value for AVDOVIMappingMethod: $value"),
      };
}

final class AVDOVIReshapingCurve extends ffi.Struct {
  @ffi.Uint8()
  external int num_pivots;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint16> pivots;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.UnsignedInt> mapping_idc;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> poly_order;

  @ffi.Array.multi([8, 3])
  external ffi.Array<ffi.Array<ffi.Int64>> poly_coef;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> mmr_order;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int64> mmr_constant;

  @ffi.Array.multi([8, 3, 7])
  external ffi.Array<ffi.Array<ffi.Array<ffi.Int64>>> mmr_coef;
}

enum AVDOVINLQMethod {
  AV_DOVI_NLQ_NONE(-1),
  AV_DOVI_NLQ_LINEAR_DZ(0);

  final int value;
  const AVDOVINLQMethod(this.value);

  static AVDOVINLQMethod fromValue(int value) => switch (value) {
        -1 => AV_DOVI_NLQ_NONE,
        0 => AV_DOVI_NLQ_LINEAR_DZ,
        _ => throw ArgumentError("Unknown value for AVDOVINLQMethod: $value"),
      };
}

/// Coefficients of the non-linear inverse quantization. For the interpretation
/// of these, see ETSI GS CCM 001.
final class AVDOVINLQParams extends ffi.Struct {
  @ffi.Uint16()
  external int nlq_offset;

  @ffi.Uint64()
  external int vdr_in_max;

  @ffi.Uint64()
  external int linear_deadzone_slope;

  @ffi.Uint64()
  external int linear_deadzone_threshold;
}

/// Dolby Vision RPU data mapping parameters.
///
/// @note sizeof(AVDOVIDataMapping) is not part of the public ABI.
final class AVDOVIDataMapping extends ffi.Struct {
  @ffi.Uint8()
  external int vdr_rpu_id;

  @ffi.Uint8()
  external int mapping_color_space;

  @ffi.Uint8()
  external int mapping_chroma_format_idc;

  @ffi.Array.multi([3])
  external ffi.Array<AVDOVIReshapingCurve> curves;

  @ffi.Int()
  external int nlq_method_idcAsInt;

  AVDOVINLQMethod get nlq_method_idc =>
      AVDOVINLQMethod.fromValue(nlq_method_idcAsInt);

  @ffi.Uint32()
  external int num_x_partitions;

  @ffi.Uint32()
  external int num_y_partitions;

  @ffi.Array.multi([3])
  external ffi.Array<AVDOVINLQParams> nlq;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint16> nlq_pivots;
}

/// Dolby Vision RPU colorspace metadata parameters.
///
/// @note sizeof(AVDOVIColorMetadata) is not part of the public ABI.
final class AVDOVIColorMetadata extends ffi.Struct {
  @ffi.Uint8()
  external int dm_metadata_id;

  @ffi.Uint8()
  external int scene_refresh_flag;

  /// Coefficients of the custom Dolby Vision IPT-PQ matrices. These are to be
  /// used instead of the matrices indicated by the frame's colorspace tags.
  /// The output of rgb_to_lms_matrix is to be fed into a BT.2020 LMS->RGB
  /// matrix based on a Hunt-Pointer-Estevez transform, but without any
  /// crosstalk. (See the definition of the ICtCp colorspace for more
  /// information.)
  @ffi.Array.multi([9])
  external ffi.Array<AVRational> ycc_to_rgb_matrix;

  @ffi.Array.multi([3])
  external ffi.Array<AVRational> ycc_to_rgb_offset;

  @ffi.Array.multi([9])
  external ffi.Array<AVRational> rgb_to_lms_matrix;

  /// Extra signal metadata (see Dolby patents for more info).
  @ffi.Uint16()
  external int signal_eotf;

  @ffi.Uint16()
  external int signal_eotf_param0;

  @ffi.Uint16()
  external int signal_eotf_param1;

  @ffi.Uint32()
  external int signal_eotf_param2;

  @ffi.Uint8()
  external int signal_bit_depth;

  @ffi.Uint8()
  external int signal_color_space;

  @ffi.Uint8()
  external int signal_chroma_format;

  @ffi.Uint8()
  external int signal_full_range_flag;

  @ffi.Uint16()
  external int source_min_pq;

  @ffi.Uint16()
  external int source_max_pq;

  @ffi.Uint16()
  external int source_diagonal;
}

final class AVDOVIDmLevel1 extends ffi.Struct {
  @ffi.Uint16()
  external int min_pq;

  @ffi.Uint16()
  external int max_pq;

  @ffi.Uint16()
  external int avg_pq;
}

final class AVDOVIDmLevel2 extends ffi.Struct {
  @ffi.Uint16()
  external int target_max_pq;

  @ffi.Uint16()
  external int trim_slope;

  @ffi.Uint16()
  external int trim_offset;

  @ffi.Uint16()
  external int trim_power;

  @ffi.Uint16()
  external int trim_chroma_weight;

  @ffi.Uint16()
  external int trim_saturation_gain;

  @ffi.Int16()
  external int ms_weight;
}

final class AVDOVIDmLevel3 extends ffi.Struct {
  @ffi.Uint16()
  external int min_pq_offset;

  @ffi.Uint16()
  external int max_pq_offset;

  @ffi.Uint16()
  external int avg_pq_offset;
}

final class AVDOVIDmLevel4 extends ffi.Struct {
  @ffi.Uint16()
  external int anchor_pq;

  @ffi.Uint16()
  external int anchor_power;
}

final class AVDOVIDmLevel5 extends ffi.Struct {
  @ffi.Uint16()
  external int left_offset;

  @ffi.Uint16()
  external int right_offset;

  @ffi.Uint16()
  external int top_offset;

  @ffi.Uint16()
  external int bottom_offset;
}

final class AVDOVIDmLevel6 extends ffi.Struct {
  @ffi.Uint16()
  external int max_luminance;

  @ffi.Uint16()
  external int min_luminance;

  @ffi.Uint16()
  external int max_cll;

  @ffi.Uint16()
  external int max_fall;
}

final class AVDOVIDmLevel8 extends ffi.Struct {
  @ffi.Uint8()
  external int target_display_index;

  @ffi.Uint16()
  external int trim_slope;

  @ffi.Uint16()
  external int trim_offset;

  @ffi.Uint16()
  external int trim_power;

  @ffi.Uint16()
  external int trim_chroma_weight;

  @ffi.Uint16()
  external int trim_saturation_gain;

  @ffi.Uint16()
  external int ms_weight;

  @ffi.Uint16()
  external int target_mid_contrast;

  @ffi.Uint16()
  external int clip_trim;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Uint8> saturation_vector_field;

  @ffi.Array.multi([6])
  external ffi.Array<ffi.Uint8> hue_vector_field;
}

final class AVDOVIDmLevel9 extends ffi.Struct {
  @ffi.Uint8()
  external int source_primary_index;

  external AVColorPrimariesDesc source_display_primaries;
}

final class AVDOVIDmLevel10 extends ffi.Struct {
  @ffi.Uint8()
  external int target_display_index;

  @ffi.Uint16()
  external int target_max_pq;

  @ffi.Uint16()
  external int target_min_pq;

  @ffi.Uint8()
  external int target_primary_index;

  external AVColorPrimariesDesc target_display_primaries;
}

final class AVDOVIDmLevel11 extends ffi.Struct {
  @ffi.Uint8()
  external int content_type;

  @ffi.Uint8()
  external int whitepoint;

  @ffi.Uint8()
  external int reference_mode_flag;

  @ffi.Uint8()
  external int sharpness;

  @ffi.Uint8()
  external int noise_reduction;

  @ffi.Uint8()
  external int mpeg_noise_reduction;

  @ffi.Uint8()
  external int frame_rate_conversion;

  @ffi.Uint8()
  external int brightness;

  @ffi.Uint8()
  external int color;
}

final class AVDOVIDmLevel254 extends ffi.Struct {
  @ffi.Uint8()
  external int dm_mode;

  @ffi.Uint8()
  external int dm_version_index;
}

final class AVDOVIDmLevel255 extends ffi.Struct {
  @ffi.Uint8()
  external int dm_run_mode;

  @ffi.Uint8()
  external int dm_run_version;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint8> dm_debug;
}

/// Dolby Vision metadata extension block. Dynamic extension blocks may change
/// from frame to frame, while static blocks are constant throughout the entire
/// sequence.
///
/// @note sizeof(AVDOVIDmData) is not part of the public API.
final class AVDOVIDmData extends ffi.Struct {
  @ffi.Uint8()
  external int level;

  external UnnamedUnion5 unnamed;
}

final class UnnamedUnion5 extends ffi.Union {
  external AVDOVIDmLevel1 l1;

  external AVDOVIDmLevel2 l2;

  external AVDOVIDmLevel3 l3;

  external AVDOVIDmLevel4 l4;

  external AVDOVIDmLevel5 l5;

  external AVDOVIDmLevel6 l6;

  external AVDOVIDmLevel8 l8;

  external AVDOVIDmLevel9 l9;

  external AVDOVIDmLevel10 l10;

  external AVDOVIDmLevel11 l11;

  external AVDOVIDmLevel254 l254;

  external AVDOVIDmLevel255 l255;
}

/// Combined struct representing a combination of header, mapping and color
/// metadata, for attaching to frames as side data.
///
/// @note The struct must be allocated with av_dovi_metadata_alloc() and
/// its size is not a part of the public ABI.
final class AVDOVIMetadata extends ffi.Struct {
  /// Offset in bytes from the beginning of this structure at which the
  /// respective structs start.
  @ffi.Size()
  external int header_offset;

  @ffi.Size()
  external int mapping_offset;

  @ffi.Size()
  external int color_offset;

  @ffi.Size()
  external int ext_block_offset;

  @ffi.Size()
  external int ext_block_size;

  @ffi.Int()
  external int num_ext_blocks;
}

final class AVTXContext extends ffi.Opaque {}

final class AVComplexFloat extends ffi.Struct {
  @ffi.Float()
  external double re;

  @ffi.Float()
  external double im;
}

final class AVComplexDouble extends ffi.Struct {
  @ffi.Double()
  external double re;

  @ffi.Double()
  external double im;
}

final class AVComplexInt32 extends ffi.Struct {
  @ffi.Int32()
  external int re;

  @ffi.Int32()
  external int im;
}

enum AVTXType {
  /// Standard complex to complex FFT with sample data type of AVComplexFloat,
  /// AVComplexDouble or AVComplexInt32, for each respective variant.
  ///
  /// Output is not 1/len normalized. Scaling currently unsupported.
  /// The stride parameter must be set to the size of a single sample in bytes.
  AV_TX_FLOAT_FFT(0),
  AV_TX_DOUBLE_FFT(2),
  AV_TX_INT32_FFT(4),

  /// Standard MDCT with a sample data type of float, double or int32_t,
  /// respecively. For the float and int32 variants, the scale type is
  /// 'float', while for the double variant, it's 'double'.
  /// If scale is NULL, 1.0 will be used as a default.
  ///
  /// Length is the frame size, not the window size (which is 2x frame).
  /// For forward transforms, the stride specifies the spacing between each
  /// sample in the output array in bytes. The input must be a flat array.
  ///
  /// For inverse transforms, the stride specifies the spacing between each
  /// sample in the input array in bytes. The output must be a flat array.
  ///
  /// NOTE: the inverse transform is half-length, meaning the output will not
  /// contain redundant data. This is what most codecs work with. To do a full
  /// inverse transform, set the AV_TX_FULL_IMDCT flag on init.
  AV_TX_FLOAT_MDCT(1),
  AV_TX_DOUBLE_MDCT(3),
  AV_TX_INT32_MDCT(5),

  /// Real to complex and complex to real DFTs.
  /// For the float and int32 variants, the scale type is 'float', while for
  /// the double variant, it's a 'double'. If scale is NULL, 1.0 will be used
  /// as a default.
  ///
  /// For forward transforms (R2C), stride must be the spacing between two
  /// samples in bytes. For inverse transforms, the stride must be set
  /// to the spacing between two complex values in bytes.
  ///
  /// The forward transform performs a real-to-complex DFT of N samples to
  /// N/2+1 complex values.
  ///
  /// The inverse transform performs a complex-to-real DFT of N/2+1 complex
  /// values to N real samples. The output is not normalized, but can be
  /// made so by setting the scale value to 1.0/len.
  /// NOTE: the inverse transform always overwrites the input.
  AV_TX_FLOAT_RDFT(6),
  AV_TX_DOUBLE_RDFT(7),
  AV_TX_INT32_RDFT(8),

  /// Real to real (DCT) transforms.
  ///
  /// The forward transform is a DCT-II.
  /// The inverse transform is a DCT-III.
  ///
  /// The input array is always overwritten. DCT-III requires that the
  /// input be padded with 2 extra samples. Stride must be set to the
  /// spacing between two samples in bytes.
  AV_TX_FLOAT_DCT(9),
  AV_TX_DOUBLE_DCT(10),
  AV_TX_INT32_DCT(11),

  /// Discrete Cosine Transform I
  ///
  /// The forward transform is a DCT-I.
  /// The inverse transform is a DCT-I multiplied by 2/(N + 1).
  ///
  /// The input array is always overwritten.
  AV_TX_FLOAT_DCT_I(12),
  AV_TX_DOUBLE_DCT_I(13),
  AV_TX_INT32_DCT_I(14),

  /// Discrete Sine Transform I
  ///
  /// The forward transform is a DST-I.
  /// The inverse transform is a DST-I multiplied by 2/(N + 1).
  ///
  /// The input array is always overwritten.
  AV_TX_FLOAT_DST_I(15),
  AV_TX_DOUBLE_DST_I(16),
  AV_TX_INT32_DST_I(17),
  AV_TX_NB(18);

  final int value;
  const AVTXType(this.value);

  static AVTXType fromValue(int value) => switch (value) {
        0 => AV_TX_FLOAT_FFT,
        2 => AV_TX_DOUBLE_FFT,
        4 => AV_TX_INT32_FFT,
        1 => AV_TX_FLOAT_MDCT,
        3 => AV_TX_DOUBLE_MDCT,
        5 => AV_TX_INT32_MDCT,
        6 => AV_TX_FLOAT_RDFT,
        7 => AV_TX_DOUBLE_RDFT,
        8 => AV_TX_INT32_RDFT,
        9 => AV_TX_FLOAT_DCT,
        10 => AV_TX_DOUBLE_DCT,
        11 => AV_TX_INT32_DCT,
        12 => AV_TX_FLOAT_DCT_I,
        13 => AV_TX_DOUBLE_DCT_I,
        14 => AV_TX_INT32_DCT_I,
        15 => AV_TX_FLOAT_DST_I,
        16 => AV_TX_DOUBLE_DST_I,
        17 => AV_TX_INT32_DST_I,
        18 => AV_TX_NB,
        _ => throw ArgumentError("Unknown value for AVTXType: $value"),
      };
}

/// Flags for av_tx_init()
enum AVTXFlags {
  /// Allows for in-place transformations, where input == output.
  /// May be unsupported or slower for some transform types.
  AV_TX_INPLACE(1),

  /// Relaxes alignment requirement for the in and out arrays of av_tx_fn().
  /// May be slower with certain transform types.
  AV_TX_UNALIGNED(2),

  /// Performs a full inverse MDCT rather than leaving out samples that can be
  /// derived through symmetry. Requires an output array of 'len' floats,
  /// rather than the usual 'len/2' floats.
  /// Ignored for all transforms but inverse MDCTs.
  AV_TX_FULL_IMDCT(4),

  /// Perform a real to half-complex RDFT.
  /// Only the real, or imaginary coefficients will
  /// be output, depending on the flag used. Only available for forward RDFTs.
  /// Output array must have enough space to hold N complex values
  /// (regular size for a real to complex transform).
  AV_TX_REAL_TO_REAL(8),
  AV_TX_REAL_TO_IMAGINARY(16);

  final int value;
  const AVTXFlags(this.value);

  static AVTXFlags fromValue(int value) => switch (value) {
        1 => AV_TX_INPLACE,
        2 => AV_TX_UNALIGNED,
        4 => AV_TX_FULL_IMDCT,
        8 => AV_TX_REAL_TO_REAL,
        16 => AV_TX_REAL_TO_IMAGINARY,
        _ => throw ArgumentError("Unknown value for AVTXFlags: $value"),
      };
}

/// Function pointer to a function to perform the transform.
///
/// @note Using a different context than the one allocated during av_tx_init()
/// is not allowed.
///
/// @param s the transform context
/// @param out the output array
/// @param in the input array
/// @param stride the input or output stride in bytes
///
/// The out and in arrays must be aligned to the maximum required by the CPU
/// architecture unless the AV_TX_UNALIGNED flag was set in av_tx_init().
/// The stride must follow the constraints the transform type has specified.
typedef av_tx_fn = ffi.Pointer<ffi.NativeFunction<av_tx_fnFunction>>;
typedef av_tx_fnFunction = ffi.Void Function(ffi.Pointer<AVTXContext> s,
    ffi.Pointer<ffi.Void> out, ffi.Pointer<ffi.Void> in1, ptrdiff_t stride);
typedef Dartav_tx_fnFunction = void Function(
    ffi.Pointer<AVTXContext> s,
    ffi.Pointer<ffi.Void> out,
    ffi.Pointer<ffi.Void> in1,
    Dart__darwin_ptrdiff_t stride);

final class AVSHA512 extends ffi.Opaque {}

final class AVCAMELLIA extends ffi.Opaque {}

final class AVVideoRect extends ffi.Struct {
  @ffi.Uint32()
  external int x;

  @ffi.Uint32()
  external int y;

  @ffi.Uint32()
  external int width;

  @ffi.Uint32()
  external int height;
}

enum AVVideoHintType {
  AV_VIDEO_HINT_TYPE_CONSTANT(0),
  AV_VIDEO_HINT_TYPE_CHANGED(1);

  final int value;
  const AVVideoHintType(this.value);

  static AVVideoHintType fromValue(int value) => switch (value) {
        0 => AV_VIDEO_HINT_TYPE_CONSTANT,
        1 => AV_VIDEO_HINT_TYPE_CHANGED,
        _ => throw ArgumentError("Unknown value for AVVideoHintType: $value"),
      };
}

final class AVVideoHint extends ffi.Struct {
  /// Number of AVVideoRect present.
  ///
  /// May be 0, in which case no per-rectangle information is present. In this
  /// case the values of rect_offset / rect_size are unspecified and should
  /// not be accessed.
  @ffi.Size()
  external int nb_rects;

  /// Offset in bytes from the beginning of this structure at which the array
  /// of AVVideoRect starts.
  @ffi.Size()
  external int rect_offset;

  /// Size in bytes of AVVideoRect.
  @ffi.Size()
  external int rect_size;

  @ffi.UnsignedInt()
  external int typeAsInt;

  AVVideoHintType get type => AVVideoHintType.fromValue(typeAsInt);
}

/// Sum of abs(src1[x] - src2[x])
typedef av_pixelutils_sad_fn
    = ffi.Pointer<ffi.NativeFunction<av_pixelutils_sad_fnFunction>>;
typedef av_pixelutils_sad_fnFunction = ffi.Int Function(
    ffi.Pointer<ffi.Uint8> src1,
    ptrdiff_t stride1,
    ffi.Pointer<ffi.Uint8> src2,
    ptrdiff_t stride2);
typedef Dartav_pixelutils_sad_fnFunction = int Function(
    ffi.Pointer<ffi.Uint8> src1,
    Dart__darwin_ptrdiff_t stride1,
    ffi.Pointer<ffi.Uint8> src2,
    Dart__darwin_ptrdiff_t stride2);

/// @defgroup lavu_hmac HMAC
/// @ingroup lavu_crypto
/// @{
enum AVHMACType {
  AV_HMAC_MD5(0),
  AV_HMAC_SHA1(1),
  AV_HMAC_SHA224(2),
  AV_HMAC_SHA256(3),
  AV_HMAC_SHA384(4),
  AV_HMAC_SHA512(5);

  final int value;
  const AVHMACType(this.value);

  static AVHMACType fromValue(int value) => switch (value) {
        0 => AV_HMAC_MD5,
        1 => AV_HMAC_SHA1,
        2 => AV_HMAC_SHA224,
        3 => AV_HMAC_SHA256,
        4 => AV_HMAC_SHA384,
        5 => AV_HMAC_SHA512,
        _ => throw ArgumentError("Unknown value for AVHMACType: $value"),
      };
}

final class AVHMAC extends ffi.Opaque {}

final class AVExpr extends ffi.Opaque {}

final class AVExecutor extends ffi.Opaque {}

final class AVTask extends ffi.Struct {
  external ffi.Pointer<AVTask> next;
}

final class AVTaskCallbacks extends ffi.Struct {
  external ffi.Pointer<ffi.Void> user_data;

  @ffi.Int()
  external int local_context_size;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<AVTask> a, ffi.Pointer<AVTask> b)>>
      priority_higher;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVTask> t, ffi.Pointer<ffi.Void> user_data)>> ready;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<AVTask> t,
              ffi.Pointer<ffi.Void> local_context,
              ffi.Pointer<ffi.Void> user_data)>> run;
}

/// Mastering display metadata capable of representing the color volume of
/// the display used to master the content (SMPTE 2086:2014).
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with av_mastering_display_metadata_alloc()
/// and its size is not a part of the public ABI.
final class AVMasteringDisplayMetadata extends ffi.Struct {
  /// CIE 1931 xy chromaticity coords of color primaries (r, g, b order).
  @ffi.Array.multi([3, 2])
  external ffi.Array<ffi.Array<AVRational>> display_primaries;

  /// CIE 1931 xy chromaticity coords of white point.
  @ffi.Array.multi([2])
  external ffi.Array<AVRational> white_point;

  /// Min luminance of mastering display (cd/m^2).
  external AVRational min_luminance;

  /// Max luminance of mastering display (cd/m^2).
  external AVRational max_luminance;

  /// Flag indicating whether the display primaries (and white point) are set.
  @ffi.Int()
  external int has_primaries;

  /// Flag indicating whether the luminance (min_ and max_) have been set.
  @ffi.Int()
  external int has_luminance;
}

/// Content light level needed by to transmit HDR over HDMI (CTA-861.3).
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with av_content_light_metadata_alloc()
/// and its size is not a part of the public ABI.
final class AVContentLightMetadata extends ffi.Struct {
  /// Max content light level (cd/m^2).
  @ffi.UnsignedInt()
  external int MaxCLL;

  /// Max average light level per frame (cd/m^2).
  @ffi.UnsignedInt()
  external int MaxFALL;
}

final class AVAES extends ffi.Opaque {}

/// @defgroup lavu_rc4 RC4
/// @ingroup lavu_crypto
/// @{
final class AVRC4 extends ffi.Struct {
  @ffi.Array.multi([256])
  external ffi.Array<ffi.Uint8> state;

  @ffi.Int()
  external int x;

  @ffi.Int()
  external int y;
}

final class AVTEA extends ffi.Opaque {}

/// @defgroup lavu_des DES
/// @ingroup lavu_crypto
/// @{
final class AVDES extends ffi.Struct {
  @ffi.Array.multi([3, 16])
  external ffi.Array<ffi.Array<ffi.Uint64>> round_keys;

  @ffi.Int()
  external int triple_des;
}

final class AVSubsampleEncryptionInfo extends ffi.Struct {
  /// The number of bytes that are clear.
  @ffi.UnsignedInt()
  external int bytes_of_clear_data;

  /// The number of bytes that are protected.  If using pattern encryption,
  /// the pattern applies to only the protected bytes; if not using pattern
  /// encryption, all these bytes are encrypted.
  @ffi.UnsignedInt()
  external int bytes_of_protected_data;
}

/// This describes encryption info for a packet.  This contains frame-specific
/// info for how to decrypt the packet before passing it to the decoder.
///
/// The size of this struct is not part of the public ABI.
final class AVEncryptionInfo extends ffi.Struct {
  /// The fourcc encryption scheme, in big-endian byte order.
  @ffi.Uint32()
  external int scheme;

  /// Only used for pattern encryption.  This is the number of 16-byte blocks
  /// that are encrypted.
  @ffi.Uint32()
  external int crypt_byte_block;

  /// Only used for pattern encryption.  This is the number of 16-byte blocks
  /// that are clear.
  @ffi.Uint32()
  external int skip_byte_block;

  /// The ID of the key used to encrypt the packet.  This should always be
  /// 16 bytes long, but may be changed in the future.
  external ffi.Pointer<ffi.Uint8> key_id;

  @ffi.Uint32()
  external int key_id_size;

  /// The initialization vector.  This may have been zero-filled to be the
  /// correct block size.  This should always be 16 bytes long, but may be
  /// changed in the future.
  external ffi.Pointer<ffi.Uint8> iv;

  @ffi.Uint32()
  external int iv_size;

  /// An array of subsample encryption info specifying how parts of the sample
  /// are encrypted.  If there are no subsamples, then the whole sample is
  /// encrypted.
  external ffi.Pointer<AVSubsampleEncryptionInfo> subsamples;

  @ffi.Uint32()
  external int subsample_count;
}

/// This describes info used to initialize an encryption key system.
///
/// The size of this struct is not part of the public ABI.
final class AVEncryptionInitInfo extends ffi.Struct {
  /// A unique identifier for the key system this is for, can be NULL if it
  /// is not known.  This should always be 16 bytes, but may change in the
  /// future.
  external ffi.Pointer<ffi.Uint8> system_id;

  @ffi.Uint32()
  external int system_id_size;

  /// An array of key IDs this initialization data is for.  All IDs are the
  /// same length.  Can be NULL if there are no known key IDs.
  external ffi.Pointer<ffi.Pointer<ffi.Uint8>> key_ids;

  /// The number of key IDs.
  @ffi.Uint32()
  external int num_key_ids;

  /// The number of bytes in each key ID.  This should always be 16, but may
  /// change in the future.
  @ffi.Uint32()
  external int key_id_size;

  /// Key-system specific initialization data.  This data is copied directly
  /// from the file and the format depends on the specific key system.  This
  /// can be NULL if there is no initialization data; in that case, there
  /// will be at least one key ID.
  external ffi.Pointer<ffi.Uint8> data;

  @ffi.Uint32()
  external int data_size;

  /// An optional pointer to the next initialization info in the list.
  external ffi.Pointer<AVEncryptionInitInfo> next;
}

final class AVTWOFISH extends ffi.Opaque {}

enum AVVideoEncParamsType {
  AV_VIDEO_ENC_PARAMS_NONE(-1),

  /// VP9 stores:
  /// - per-frame base (luma AC) quantizer index, exported as AVVideoEncParams.qp
  /// - deltas for luma DC, chroma AC and chroma DC, exported in the
  /// corresponding entries in AVVideoEncParams.delta_qp
  /// - per-segment delta, exported as for each block as AVVideoBlockParams.delta_qp
  ///
  /// To compute the resulting quantizer index for a block:
  /// - for luma AC, add the base qp and the per-block delta_qp, saturating to
  /// unsigned 8-bit.
  /// - for luma DC and chroma AC/DC, add the corresponding
  /// AVVideoBlockParams.delta_qp to the luma AC index, again saturating to
  /// unsigned 8-bit.
  AV_VIDEO_ENC_PARAMS_VP9(0),

  /// H.264 stores:
  /// - in PPS (per-picture):
  /// * initial QP_Y (luma) value, exported as AVVideoEncParams.qp
  /// * delta(s) for chroma QP values (same for both, or each separately),
  /// exported as in the corresponding entries in AVVideoEncParams.delta_qp
  /// - per-slice QP delta, not exported directly, added to the per-MB value
  /// - per-MB delta; not exported directly; the final per-MB quantizer
  /// parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported
  /// as AVVideoBlockParams.qp_delta.
  AV_VIDEO_ENC_PARAMS_H264(1),
  AV_VIDEO_ENC_PARAMS_MPEG2(2);

  final int value;
  const AVVideoEncParamsType(this.value);

  static AVVideoEncParamsType fromValue(int value) => switch (value) {
        -1 => AV_VIDEO_ENC_PARAMS_NONE,
        0 => AV_VIDEO_ENC_PARAMS_VP9,
        1 => AV_VIDEO_ENC_PARAMS_H264,
        2 => AV_VIDEO_ENC_PARAMS_MPEG2,
        _ =>
          throw ArgumentError("Unknown value for AVVideoEncParamsType: $value"),
      };
}

/// Video encoding parameters for a given frame. This struct is allocated along
/// with an optional array of per-block AVVideoBlockParams descriptors.
/// Must be allocated with av_video_enc_params_alloc().
final class AVVideoEncParams extends ffi.Struct {
  /// Number of blocks in the array.
  ///
  /// May be 0, in which case no per-block information is present. In this case
  /// the values of blocks_offset / block_size are unspecified and should not
  /// be accessed.
  @ffi.UnsignedInt()
  external int nb_blocks;

  /// Offset in bytes from the beginning of this structure at which the array
  /// of blocks starts.
  @ffi.Size()
  external int blocks_offset;

  @ffi.Size()
  external int block_size;

  /// Type of the parameters (the codec they are used with).
  @ffi.Int()
  external int typeAsInt;

  AVVideoEncParamsType get type => AVVideoEncParamsType.fromValue(typeAsInt);

  /// Base quantisation parameter for the frame. The final quantiser for a
  /// given block in a given plane is obtained from this value, possibly
  /// combined with {@code delta_qp} and the per-block delta in a manner
  /// documented for each type.
  @ffi.Int32()
  external int qp;

  /// Quantisation parameter offset from the base (per-frame) qp for a given
  /// plane (first index) and AC/DC coefficients (second index).
  @ffi.Array.multi([4, 2])
  external ffi.Array<ffi.Array<ffi.Int32>> delta_qp;
}

/// Data structure for storing block-level encoding information.
/// It is allocated as a part of AVVideoEncParams and should be retrieved with
/// av_video_enc_params_block().
///
/// sizeof(AVVideoBlockParams) is not a part of the ABI and new fields may be
/// added to it.
final class AVVideoBlockParams extends ffi.Struct {
  /// Distance in luma pixels from the top-left corner of the visible frame
  /// to the top-left corner of the block.
  /// Can be negative if top/right padding is present on the coded frame.
  @ffi.Int()
  external int src_x;

  @ffi.Int()
  external int src_y;

  /// Width and height of the block in luma pixels.
  @ffi.Int()
  external int w;

  @ffi.Int()
  external int h;

  /// Difference between this block's final quantization parameter and the
  /// corresponding per-frame value.
  @ffi.Int32()
  external int delta_qp;
}

final class timespec extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @ffi.Long()
  external int tv_nsec;
}

final class tm extends ffi.Struct {
  @ffi.Int()
  external int tm_sec;

  @ffi.Int()
  external int tm_min;

  @ffi.Int()
  external int tm_hour;

  @ffi.Int()
  external int tm_mday;

  @ffi.Int()
  external int tm_mon;

  @ffi.Int()
  external int tm_year;

  @ffi.Int()
  external int tm_wday;

  @ffi.Int()
  external int tm_yday;

  @ffi.Int()
  external int tm_isdst;

  @ffi.Long()
  external int tm_gmtoff;

  external ffi.Pointer<ffi.Char> tm_zone;
}

typedef clock_t = __darwin_clock_t;
typedef __darwin_clock_t = ffi.UnsignedLong;
typedef Dart__darwin_clock_t = int;
typedef time_t = __darwin_time_t;

enum clockid_t {
  _CLOCK_REALTIME(0),
  _CLOCK_MONOTONIC(6),
  _CLOCK_MONOTONIC_RAW(4),
  _CLOCK_MONOTONIC_RAW_APPROX(5),
  _CLOCK_UPTIME_RAW(8),
  _CLOCK_UPTIME_RAW_APPROX(9),
  _CLOCK_PROCESS_CPUTIME_ID(12),
  _CLOCK_THREAD_CPUTIME_ID(16);

  final int value;
  const clockid_t(this.value);

  static clockid_t fromValue(int value) => switch (value) {
        0 => _CLOCK_REALTIME,
        6 => _CLOCK_MONOTONIC,
        4 => _CLOCK_MONOTONIC_RAW,
        5 => _CLOCK_MONOTONIC_RAW_APPROX,
        8 => _CLOCK_UPTIME_RAW,
        9 => _CLOCK_UPTIME_RAW_APPROX,
        12 => _CLOCK_PROCESS_CPUTIME_ID,
        16 => _CLOCK_THREAD_CPUTIME_ID,
        _ => throw ArgumentError("Unknown value for clockid_t: $value"),
      };
}

final class AVRIPEMD extends ffi.Opaque {}

enum AVEscapeMode {
  /// < Use auto-selected escaping mode.
  AV_ESCAPE_MODE_AUTO(0),

  /// < Use backslash escaping.
  AV_ESCAPE_MODE_BACKSLASH(1),

  /// < Use single-quote escaping.
  AV_ESCAPE_MODE_QUOTE(2),

  /// < Use XML non-markup character data escaping.
  AV_ESCAPE_MODE_XML(3);

  final int value;
  const AVEscapeMode(this.value);

  static AVEscapeMode fromValue(int value) => switch (value) {
        0 => AV_ESCAPE_MODE_AUTO,
        1 => AV_ESCAPE_MODE_BACKSLASH,
        2 => AV_ESCAPE_MODE_QUOTE,
        3 => AV_ESCAPE_MODE_XML,
        _ => throw ArgumentError("Unknown value for AVEscapeMode: $value"),
      };
}

final class ff_pad_helper_AVBPrint extends ffi.Struct {
  external ffi.Pointer<ffi.Char> str;

  @ffi.UnsignedInt()
  external int len;

  @ffi.UnsignedInt()
  external int size;

  @ffi.UnsignedInt()
  external int size_max;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> reserved_internal_buffer;
}

/// Option for overlapping elliptical pixel selectors in an image.
enum AVHDRPlusOverlapProcessOption {
  AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING(0),
  AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING(1);

  final int value;
  const AVHDRPlusOverlapProcessOption(this.value);

  static AVHDRPlusOverlapProcessOption fromValue(int value) => switch (value) {
        0 => AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING,
        1 => AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING,
        _ => throw ArgumentError(
            "Unknown value for AVHDRPlusOverlapProcessOption: $value"),
      };
}

/// Represents the percentile at a specific percentage in
/// a distribution.
final class AVHDRPlusPercentile extends ffi.Struct {
  /// The percentage value corresponding to a specific percentile linearized
  /// RGB value in the processing window in the scene. The value shall be in
  /// the range of 0 to100, inclusive.
  @ffi.Uint8()
  external int percentage;

  /// The linearized maxRGB value at a specific percentile in the processing
  /// window in the scene. The value shall be in the range of 0 to 1, inclusive
  /// and in multiples of 0.00001.
  external AVRational percentile;
}

/// Color transform parameters at a processing window in a dynamic metadata for
/// SMPTE 2094-40.
final class AVHDRPlusColorTransformParams extends ffi.Struct {
  /// The relative x coordinate of the top left pixel of the processing
  /// window. The value shall be in the range of 0 and 1, inclusive and
  /// in multiples of 1/(width of Picture - 1). The value 1 corresponds
  /// to the absolute coordinate of width of Picture - 1. The value for
  /// first processing window shall be 0.
  external AVRational window_upper_left_corner_x;

  /// The relative y coordinate of the top left pixel of the processing
  /// window. The value shall be in the range of 0 and 1, inclusive and
  /// in multiples of 1/(height of Picture - 1). The value 1 corresponds
  /// to the absolute coordinate of height of Picture - 1. The value for
  /// first processing window shall be 0.
  external AVRational window_upper_left_corner_y;

  /// The relative x coordinate of the bottom right pixel of the processing
  /// window. The value shall be in the range of 0 and 1, inclusive and
  /// in multiples of 1/(width of Picture - 1). The value 1 corresponds
  /// to the absolute coordinate of width of Picture - 1. The value for
  /// first processing window shall be 1.
  external AVRational window_lower_right_corner_x;

  /// The relative y coordinate of the bottom right pixel of the processing
  /// window. The value shall be in the range of 0 and 1, inclusive and
  /// in multiples of 1/(height of Picture - 1). The value 1 corresponds
  /// to the absolute coordinate of height of Picture - 1. The value for
  /// first processing window shall be 1.
  external AVRational window_lower_right_corner_y;

  /// The x coordinate of the center position of the concentric internal and
  /// external ellipses of the elliptical pixel selector in the processing
  /// window. The value shall be in the range of 0 to (width of Picture - 1),
  /// inclusive and in multiples of 1 pixel.
  @ffi.Uint16()
  external int center_of_ellipse_x;

  /// The y coordinate of the center position of the concentric internal and
  /// external ellipses of the elliptical pixel selector in the processing
  /// window. The value shall be in the range of 0 to (height of Picture - 1),
  /// inclusive and in multiples of 1 pixel.
  @ffi.Uint16()
  external int center_of_ellipse_y;

  /// The clockwise rotation angle in degree of arc with respect to the
  /// positive direction of the x-axis of the concentric internal and external
  /// ellipses of the elliptical pixel selector in the processing window. The
  /// value shall be in the range of 0 to 180, inclusive and in multiples of 1.
  @ffi.Uint8()
  external int rotation_angle;

  /// The semi-major axis value of the internal ellipse of the elliptical pixel
  /// selector in amount of pixels in the processing window. The value shall be
  /// in the range of 1 to 65535, inclusive and in multiples of 1 pixel.
  @ffi.Uint16()
  external int semimajor_axis_internal_ellipse;

  /// The semi-major axis value of the external ellipse of the elliptical pixel
  /// selector in amount of pixels in the processing window. The value
  /// shall not be less than semimajor_axis_internal_ellipse of the current
  /// processing window. The value shall be in the range of 1 to 65535,
  /// inclusive and in multiples of 1 pixel.
  @ffi.Uint16()
  external int semimajor_axis_external_ellipse;

  /// The semi-minor axis value of the external ellipse of the elliptical pixel
  /// selector in amount of pixels in the processing window. The value shall be
  /// in the range of 1 to 65535, inclusive and in multiples of 1 pixel.
  @ffi.Uint16()
  external int semiminor_axis_external_ellipse;

  /// Overlap process option indicates one of the two methods of combining
  /// rendered pixels in the processing window in an image with at least one
  /// elliptical pixel selector. For overlapping elliptical pixel selectors
  /// in an image, overlap_process_option shall have the same value.
  @ffi.UnsignedInt()
  external int overlap_process_optionAsInt;

  AVHDRPlusOverlapProcessOption get overlap_process_option =>
      AVHDRPlusOverlapProcessOption.fromValue(overlap_process_optionAsInt);

  /// The maximum of the color components of linearized RGB values in the
  /// processing window in the scene. The values should be in the range of 0 to
  /// 1, inclusive and in multiples of 0.00001. maxscl[ 0 ], maxscl[ 1 ], and
  /// maxscl[ 2 ] are corresponding to R, G, B color components respectively.
  @ffi.Array.multi([3])
  external ffi.Array<AVRational> maxscl;

  /// The average of linearized maxRGB values in the processing window in the
  /// scene. The value should be in the range of 0 to 1, inclusive and in
  /// multiples of 0.00001.
  external AVRational average_maxrgb;

  /// The number of linearized maxRGB values at given percentiles in the
  /// processing window in the scene. The maximum value shall be 15.
  @ffi.Uint8()
  external int num_distribution_maxrgb_percentiles;

  /// The linearized maxRGB values at given percentiles in the
  /// processing window in the scene.
  @ffi.Array.multi([15])
  external ffi.Array<AVHDRPlusPercentile> distribution_maxrgb;

  /// The fraction of selected pixels in the image that contains the brightest
  /// pixel in the scene. The value shall be in the range of 0 to 1, inclusive
  /// and in multiples of 0.001.
  external AVRational fraction_bright_pixels;

  /// This flag indicates that the metadata for the tone mapping function in
  /// the processing window is present (for value of 1).
  @ffi.Uint8()
  external int tone_mapping_flag;

  /// The x coordinate of the separation point between the linear part and the
  /// curved part of the tone mapping function. The value shall be in the range
  /// of 0 to 1, excluding 0 and in multiples of 1/4095.
  external AVRational knee_point_x;

  /// The y coordinate of the separation point between the linear part and the
  /// curved part of the tone mapping function. The value shall be in the range
  /// of 0 to 1, excluding 0 and in multiples of 1/4095.
  external AVRational knee_point_y;

  /// The number of the intermediate anchor parameters of the tone mapping
  /// function in the processing window. The maximum value shall be 15.
  @ffi.Uint8()
  external int num_bezier_curve_anchors;

  /// The intermediate anchor parameters of the tone mapping function in the
  /// processing window in the scene. The values should be in the range of 0
  /// to 1, inclusive and in multiples of 1/1023.
  @ffi.Array.multi([15])
  external ffi.Array<AVRational> bezier_curve_anchors;

  /// This flag shall be equal to 0 in bitstreams conforming to this version of
  /// this Specification. Other values are reserved for future use.
  @ffi.Uint8()
  external int color_saturation_mapping_flag;

  /// The color saturation gain in the processing window in the scene. The
  /// value shall be in the range of 0 to 63/8, inclusive and in multiples of
  /// 1/8. The default value shall be 1.
  external AVRational color_saturation_weight;
}

/// This struct represents dynamic metadata for color volume transform -
/// application 4 of SMPTE 2094-40:2016 standard.
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with
/// av_dynamic_hdr_plus_alloc() and its size is not a part of
/// the public ABI.
final class AVDynamicHDRPlus extends ffi.Struct {
  /// Country code by Rec. ITU-T T.35 Annex A. The value shall be 0xB5.
  @ffi.Uint8()
  external int itu_t_t35_country_code;

  /// Application version in the application defining document in ST-2094
  /// suite. The value shall be set to 0.
  @ffi.Uint8()
  external int application_version;

  /// The number of processing windows. The value shall be in the range
  /// of 1 to 3, inclusive.
  @ffi.Uint8()
  external int num_windows;

  /// The color transform parameters for every processing window.
  @ffi.Array.multi([3])
  external ffi.Array<AVHDRPlusColorTransformParams> params;

  /// The nominal maximum display luminance of the targeted system display,
  /// in units of 0.0001 candelas per square metre. The value shall be in
  /// the range of 0 to 10000, inclusive.
  external AVRational targeted_system_display_maximum_luminance;

  /// This flag shall be equal to 0 in bit streams conforming to this version
  /// of this Specification. The value 1 is reserved for future use.
  @ffi.Uint8()
  external int targeted_system_display_actual_peak_luminance_flag;

  /// The number of rows in the targeted system_display_actual_peak_luminance
  /// array. The value shall be in the range of 2 to 25, inclusive.
  @ffi.Uint8()
  external int num_rows_targeted_system_display_actual_peak_luminance;

  /// The number of columns in the
  /// targeted_system_display_actual_peak_luminance array. The value shall be
  /// in the range of 2 to 25, inclusive.
  @ffi.Uint8()
  external int num_cols_targeted_system_display_actual_peak_luminance;

  /// The normalized actual peak luminance of the targeted system display. The
  /// values should be in the range of 0 to 1, inclusive and in multiples of
  /// 1/15.
  @ffi.Array.multi([25, 25])
  external ffi.Array<ffi.Array<AVRational>>
      targeted_system_display_actual_peak_luminance;

  /// This flag shall be equal to 0 in bitstreams conforming to this version of
  /// this Specification. The value 1 is reserved for future use.
  @ffi.Uint8()
  external int mastering_display_actual_peak_luminance_flag;

  /// The number of rows in the mastering_display_actual_peak_luminance array.
  /// The value shall be in the range of 2 to 25, inclusive.
  @ffi.Uint8()
  external int num_rows_mastering_display_actual_peak_luminance;

  /// The number of columns in the mastering_display_actual_peak_luminance
  /// array. The value shall be in the range of 2 to 25, inclusive.
  @ffi.Uint8()
  external int num_cols_mastering_display_actual_peak_luminance;

  /// The normalized actual peak luminance of the mastering display used for
  /// mastering the image essence. The values should be in the range of 0 to 1,
  /// inclusive and in multiples of 1/15.
  @ffi.Array.multi([25, 25])
  external ffi.Array<ffi.Array<AVRational>>
      mastering_display_actual_peak_luminance;
}

final class AVAESCTR extends ffi.Opaque {}

/// Possible downmix types.
enum AVDownmixType {
  /// < Not indicated.
  AV_DOWNMIX_TYPE_UNKNOWN(0),

  /// < Lo/Ro 2-channel downmix (Stereo).
  AV_DOWNMIX_TYPE_LORO(1),

  /// < Lt/Rt 2-channel downmix, Dolby Surround compatible.
  AV_DOWNMIX_TYPE_LTRT(2),

  /// < Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible.
  AV_DOWNMIX_TYPE_DPLII(3),

  /// < Number of downmix types. Not part of ABI.
  AV_DOWNMIX_TYPE_NB(4);

  final int value;
  const AVDownmixType(this.value);

  static AVDownmixType fromValue(int value) => switch (value) {
        0 => AV_DOWNMIX_TYPE_UNKNOWN,
        1 => AV_DOWNMIX_TYPE_LORO,
        2 => AV_DOWNMIX_TYPE_LTRT,
        3 => AV_DOWNMIX_TYPE_DPLII,
        4 => AV_DOWNMIX_TYPE_NB,
        _ => throw ArgumentError("Unknown value for AVDownmixType: $value"),
      };
}

/// This structure describes optional metadata relevant to a downmix procedure.
///
/// All fields are set by the decoder to the value indicated in the audio
/// bitstream (if present), or to a "sane" default otherwise.
final class AVDownmixInfo extends ffi.Struct {
  /// Type of downmix preferred by the mastering engineer.
  @ffi.UnsignedInt()
  external int preferred_downmix_typeAsInt;

  AVDownmixType get preferred_downmix_type =>
      AVDownmixType.fromValue(preferred_downmix_typeAsInt);

  /// Absolute scale factor representing the nominal level of the center
  /// channel during a regular downmix.
  @ffi.Double()
  external double center_mix_level;

  /// Absolute scale factor representing the nominal level of the center
  /// channel during an Lt/Rt compatible downmix.
  @ffi.Double()
  external double center_mix_level_ltrt;

  /// Absolute scale factor representing the nominal level of the surround
  /// channels during a regular downmix.
  @ffi.Double()
  external double surround_mix_level;

  /// Absolute scale factor representing the nominal level of the surround
  /// channels during an Lt/Rt compatible downmix.
  @ffi.Double()
  external double surround_mix_level_ltrt;

  /// Absolute scale factor representing the level at which the LFE data is
  /// mixed into L/R channels during downmixing.
  @ffi.Double()
  external double lfe_mix_level;
}

/// @example ffhash.c
/// This example is a simple command line application that takes one or more
/// arguments. It demonstrates a typical use of the hashing API with allocation,
/// initialization, updating, and finalizing.
final class AVHashContext extends ffi.Opaque {}

final class av_alias64 extends ffi.Union {
  @ffi.Uint64()
  external int u64;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> u32;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint16> u16;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Uint8> u8;

  @ffi.Double()
  external double f64;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> f32;
}

final class av_alias32 extends ffi.Union {
  @ffi.Uint32()
  external int u32;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint16> u16;

  @ffi.Array.multi([4])
  external ffi.Array<ffi.Uint8> u8;

  @ffi.Float()
  external double f32;
}

final class av_alias16 extends ffi.Union {
  @ffi.Uint16()
  external int u16;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint8> u8;
}

final class unaligned_64 extends ffi.Union {
  @ffi.Uint64()
  external int l;
}

final class unaligned_32 extends ffi.Union {
  @ffi.Uint32()
  external int l;
}

final class unaligned_16 extends ffi.Union {
  @ffi.Uint16()
  external int l;
}

enum AVFilmGrainParamsType {
  AV_FILM_GRAIN_PARAMS_NONE(0),

  /// The union is valid when interpreted as AVFilmGrainAOMParams (codec.aom)
  AV_FILM_GRAIN_PARAMS_AV1(1),

  /// The union is valid when interpreted as AVFilmGrainH274Params (codec.h274)
  AV_FILM_GRAIN_PARAMS_H274(2);

  final int value;
  const AVFilmGrainParamsType(this.value);

  static AVFilmGrainParamsType fromValue(int value) => switch (value) {
        0 => AV_FILM_GRAIN_PARAMS_NONE,
        1 => AV_FILM_GRAIN_PARAMS_AV1,
        2 => AV_FILM_GRAIN_PARAMS_H274,
        _ => throw ArgumentError(
            "Unknown value for AVFilmGrainParamsType: $value"),
      };
}

/// This structure describes how to handle film grain synthesis for AOM codecs.
///
/// @note The struct must be allocated as part of AVFilmGrainParams using
/// av_film_grain_params_alloc(). Its size is not a part of the public ABI.
final class AVFilmGrainAOMParams extends ffi.Struct {
  /// Number of points, and the scale and value for each point of the
  /// piecewise linear scaling function for the uma plane.
  @ffi.Int()
  external int num_y_points;

  @ffi.Array.multi([14, 2])
  external ffi.Array<ffi.Array<ffi.Uint8>> y_points;

  /// Signals whether to derive the chroma scaling function from the luma.
  /// Not equivalent to copying the luma values and scales.
  @ffi.Int()
  external int chroma_scaling_from_luma;

  /// If chroma_scaling_from_luma is set to 0, signals the chroma scaling
  /// function parameters.
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> num_uv_points;

  @ffi.Array.multi([2, 10, 2])
  external ffi.Array<ffi.Array<ffi.Array<ffi.Uint8>>> uv_points;

  /// Specifies the shift applied to the chroma components. For AV1, its within
  /// [8; 11] and determines the range and quantization of the film grain.
  @ffi.Int()
  external int scaling_shift;

  /// Specifies the auto-regression lag.
  @ffi.Int()
  external int ar_coeff_lag;

  /// Luma auto-regression coefficients. The number of coefficients is given by
  /// 2 * ar_coeff_lag * (ar_coeff_lag + 1).
  @ffi.Array.multi([24])
  external ffi.Array<ffi.Int8> ar_coeffs_y;

  /// Chroma auto-regression coefficients. The number of coefficients is given by
  /// 2 * ar_coeff_lag * (ar_coeff_lag + 1) + !!num_y_points.
  @ffi.Array.multi([2, 25])
  external ffi.Array<ffi.Array<ffi.Int8>> ar_coeffs_uv;

  /// Specifies the range of the auto-regressive coefficients. Values of 6,
  /// 7, 8 and so on represent a range of [-2, 2), [-1, 1), [-0.5, 0.5) and
  /// so on. For AV1 must be between 6 and 9.
  @ffi.Int()
  external int ar_coeff_shift;

  /// Signals the down shift applied to the generated gaussian numbers during
  /// synthesis.
  @ffi.Int()
  external int grain_scale_shift;

  /// Specifies the luma/chroma multipliers for the index to the component
  /// scaling function.
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> uv_mult;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> uv_mult_luma;

  /// Offset used for component scaling function. For AV1 its a 9-bit value
  /// with a range [-256, 255]
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> uv_offset;

  /// Signals whether to overlap film grain blocks.
  @ffi.Int()
  external int overlap_flag;

  /// Signals to clip to limited color levels after film grain application.
  @ffi.Int()
  external int limit_output_range;
}

/// This structure describes how to handle film grain synthesis for codecs using
/// the ITU-T H.274 Versatile suplemental enhancement information message.
///
/// @note The struct must be allocated as part of AVFilmGrainParams using
/// av_film_grain_params_alloc(). Its size is not a part of the public ABI.
final class AVFilmGrainH274Params extends ffi.Struct {
  /// Specifies the film grain simulation mode.
  /// 0 = Frequency filtering, 1 = Auto-regression
  @ffi.Int()
  external int model_id;

  /// Specifies the bit depth used for the luma component.
  ///
  /// @deprecated use AVFilmGrainParams.bit_depth_luma.
  @ffi.Int()
  external int bit_depth_luma;

  /// Specifies the bit depth used for the chroma components.
  ///
  /// @deprecated use AVFilmGrainParams.bit_depth_chroma.
  @ffi.Int()
  external int bit_depth_chroma;

  /// Specifies the video signal characteristics.
  ///
  /// @deprecated use AVFilmGrainParams.color_{range,primaries,trc,space}.
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  AVColorPrimaries get color_primaries =>
      AVColorPrimaries.fromValue(color_primariesAsInt);

  @ffi.UnsignedInt()
  external int color_trcAsInt;

  AVColorTransferCharacteristic get color_trc =>
      AVColorTransferCharacteristic.fromValue(color_trcAsInt);

  @ffi.UnsignedInt()
  external int color_spaceAsInt;

  AVColorSpace get color_space => AVColorSpace.fromValue(color_spaceAsInt);

  /// Specifies the blending mode used to blend the simulated film grain
  /// with the decoded images.
  ///
  /// 0 = Additive, 1 = Multiplicative
  @ffi.Int()
  external int blending_mode_id;

  /// Specifies a scale factor used in the film grain characterization equations.
  @ffi.Int()
  external int log2_scale_factor;

  /// Indicates if the modelling of film grain for a given component is present.
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Int> component_model_present;

  /// Specifies the number of intensity intervals for which a specific set of
  /// model values has been estimated, with a range of [1, 256].
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint16> num_intensity_intervals;

  /// Specifies the number of model values present for each intensity interval
  /// in which the film grain has been modelled, with a range of [1, 6].
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint8> num_model_values;

  /// Specifies the lower ounds of each intensity interval for whichthe set of
  /// model values applies for the component.
  @ffi.Array.multi([3, 256])
  external ffi.Array<ffi.Array<ffi.Uint8>> intensity_interval_lower_bound;

  /// Specifies the upper bound of each intensity interval for which the set of
  /// model values applies for the component.
  @ffi.Array.multi([3, 256])
  external ffi.Array<ffi.Array<ffi.Uint8>> intensity_interval_upper_bound;

  /// Specifies the model values for the component for each intensity interval.
  /// - When model_id == 0, the following applies:
  /// For comp_model_value[y], the range of values is [0, 2^bit_depth_luma - 1]
  /// For comp_model_value[cb..cr], the range of values is [0, 2^bit_depth_chroma - 1]
  /// - Otherwise, the following applies:
  /// For comp_model_value[y], the range of values is [-2^(bit_depth_luma - 1), 2^(bit_depth_luma - 1) - 1]
  /// For comp_model_value[cb..cr], the range of values is [-2^(bit_depth_chroma - 1), 2^(bit_depth_chroma - 1) - 1]
  @ffi.Array.multi([3, 256, 6])
  external ffi.Array<ffi.Array<ffi.Array<ffi.Int16>>> comp_model_value;
}

/// This structure describes how to handle film grain synthesis in video
/// for specific codecs. Must be present on every frame where film grain is
/// meant to be synthesised for correct presentation.
///
/// @note The struct must be allocated with av_film_grain_params_alloc() and
/// its size is not a part of the public ABI.
final class AVFilmGrainParams extends ffi.Struct {
  /// Specifies the codec for which this structure is valid.
  @ffi.UnsignedInt()
  external int typeAsInt;

  AVFilmGrainParamsType get type => AVFilmGrainParamsType.fromValue(typeAsInt);

  /// Seed to use for the synthesis process, if the codec allows for it.
  ///
  /// @note For H.264, this refers to `pic_offset` as defined in
  /// SMPTE RDD 5-2006.
  @ffi.Uint64()
  external int seed;

  external UnnamedUnion6 codec;

  /// Intended display resolution. May be 0 if the codec does not specify
  /// any restrictions.
  @ffi.Int()
  external int width;

  @ffi.Int()
  external int height;

  /// Intended subsampling ratio, or 0 for luma-only streams.
  @ffi.Int()
  external int subsampling_x;

  @ffi.Int()
  external int subsampling_y;

  /// Intended video signal characteristics.
  @ffi.UnsignedInt()
  external int color_rangeAsInt;

  AVColorRange get color_range => AVColorRange.fromValue(color_rangeAsInt);

  @ffi.UnsignedInt()
  external int color_primariesAsInt;

  AVColorPrimaries get color_primaries =>
      AVColorPrimaries.fromValue(color_primariesAsInt);

  @ffi.UnsignedInt()
  external int color_trcAsInt;

  AVColorTransferCharacteristic get color_trc =>
      AVColorTransferCharacteristic.fromValue(color_trcAsInt);

  @ffi.UnsignedInt()
  external int color_spaceAsInt;

  AVColorSpace get color_space => AVColorSpace.fromValue(color_spaceAsInt);

  /// Intended bit depth, or 0 for unknown/unspecified.
  @ffi.Int()
  external int bit_depth_luma;

  @ffi.Int()
  external int bit_depth_chroma;
}

/// Additional fields may be added both here and in any structure included.
/// If a codec's film grain structure differs slightly over another
/// codec's, fields within may change meaning depending on the type.
///
/// TODO: Move this to the end of the structure, at the next ABI bump.
final class UnnamedUnion6 extends ffi.Union {
  external AVFilmGrainAOMParams aom;

  external AVFilmGrainH274Params h274;
}

typedef pp_mode = ffi.Void;
typedef Dartpp_mode = void;
typedef pp_context = ffi.Void;
typedef Dartpp_context = void;

/// Dithering algorithms
enum SwrDitherType {
  SWR_DITHER_NONE(0),
  SWR_DITHER_RECTANGULAR(1),
  SWR_DITHER_TRIANGULAR(2),
  SWR_DITHER_TRIANGULAR_HIGHPASS(3),

  /// < not part of API/ABI
  SWR_DITHER_NS(64),
  SWR_DITHER_NS_LIPSHITZ(65),
  SWR_DITHER_NS_F_WEIGHTED(66),
  SWR_DITHER_NS_MODIFIED_E_WEIGHTED(67),
  SWR_DITHER_NS_IMPROVED_E_WEIGHTED(68),
  SWR_DITHER_NS_SHIBATA(69),
  SWR_DITHER_NS_LOW_SHIBATA(70),
  SWR_DITHER_NS_HIGH_SHIBATA(71),

  /// < not part of API/ABI
  SWR_DITHER_NB(72);

  final int value;
  const SwrDitherType(this.value);

  static SwrDitherType fromValue(int value) => switch (value) {
        0 => SWR_DITHER_NONE,
        1 => SWR_DITHER_RECTANGULAR,
        2 => SWR_DITHER_TRIANGULAR,
        3 => SWR_DITHER_TRIANGULAR_HIGHPASS,
        64 => SWR_DITHER_NS,
        65 => SWR_DITHER_NS_LIPSHITZ,
        66 => SWR_DITHER_NS_F_WEIGHTED,
        67 => SWR_DITHER_NS_MODIFIED_E_WEIGHTED,
        68 => SWR_DITHER_NS_IMPROVED_E_WEIGHTED,
        69 => SWR_DITHER_NS_SHIBATA,
        70 => SWR_DITHER_NS_LOW_SHIBATA,
        71 => SWR_DITHER_NS_HIGH_SHIBATA,
        72 => SWR_DITHER_NB,
        _ => throw ArgumentError("Unknown value for SwrDitherType: $value"),
      };
}

/// Resampling Engines
enum SwrEngine {
  /// < SW Resampler
  SWR_ENGINE_SWR(0),

  /// < SoX Resampler
  SWR_ENGINE_SOXR(1),

  /// < not part of API/ABI
  SWR_ENGINE_NB(2);

  final int value;
  const SwrEngine(this.value);

  static SwrEngine fromValue(int value) => switch (value) {
        0 => SWR_ENGINE_SWR,
        1 => SWR_ENGINE_SOXR,
        2 => SWR_ENGINE_NB,
        _ => throw ArgumentError("Unknown value for SwrEngine: $value"),
      };
}

/// Resampling Filter Types
enum SwrFilterType {
  /// < Cubic
  SWR_FILTER_TYPE_CUBIC(0),

  /// < Blackman Nuttall windowed sinc
  SWR_FILTER_TYPE_BLACKMAN_NUTTALL(1),

  /// < Kaiser windowed sinc
  SWR_FILTER_TYPE_KAISER(2);

  final int value;
  const SwrFilterType(this.value);

  static SwrFilterType fromValue(int value) => switch (value) {
        0 => SWR_FILTER_TYPE_CUBIC,
        1 => SWR_FILTER_TYPE_BLACKMAN_NUTTALL,
        2 => SWR_FILTER_TYPE_KAISER,
        _ => throw ArgumentError("Unknown value for SwrFilterType: $value"),
      };
}

final class SwrContext extends ffi.Opaque {}

final class SwsVector extends ffi.Struct {
  /// < pointer to the list of coefficients
  external ffi.Pointer<ffi.Double> coeff;

  /// < number of coefficients in the vector
  @ffi.Int()
  external int length;
}

final class SwsFilter extends ffi.Struct {
  external ffi.Pointer<SwsVector> lumH;

  external ffi.Pointer<SwsVector> lumV;

  external ffi.Pointer<SwsVector> chrH;

  external ffi.Pointer<SwsVector> chrV;
}

final class SwsContext extends ffi.Opaque {}

const int AV_FRAME_CROP_UNALIGNED = 1;

const int AV_HWFRAME_MAP_READ = 1;

const int AV_HWFRAME_MAP_WRITE = 2;

const int AV_HWFRAME_MAP_OVERWRITE = 4;

const int AV_HWFRAME_MAP_DIRECT = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8;

const int AV_OPT_FLAG_IMPLICIT_KEY = 1;

const int AVFILTER_AUTO_CONVERT_ALL = 0;

const int AVFILTER_AUTO_CONVERT_NONE = -1;

const int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1;

const int AV_BUFFERSRC_FLAG_PUSH = 4;

const int AV_BUFFERSRC_FLAG_KEEP_REF = 8;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int AV_AAC_ADTS_HEADER_SIZE = 7;

const int FF_LAMBDA_SHIFT = 7;

const int FF_LAMBDA_SCALE = 128;

const int FF_QP2LAMBDA = 118;

const int FF_LAMBDA_MAX = 32767;

const int FF_QUALITY_SCALE = 128;

const int AV_NOPTS_VALUE = -9223372036854775808;

const int AV_TIME_BASE = 1000000;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EDEADLK = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int ENOTBLK = 15;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int EINVAL = 22;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int ETXTBSY = 26;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int ERANGE = 34;

const int EAGAIN = 35;

const int EWOULDBLOCK = 35;

const int EINPROGRESS = 36;

const int EALREADY = 37;

const int ENOTSOCK = 38;

const int EDESTADDRREQ = 39;

const int EMSGSIZE = 40;

const int EPROTOTYPE = 41;

const int ENOPROTOOPT = 42;

const int EPROTONOSUPPORT = 43;

const int ESOCKTNOSUPPORT = 44;

const int ENOTSUP = 45;

const int EPFNOSUPPORT = 46;

const int EAFNOSUPPORT = 47;

const int EADDRINUSE = 48;

const int EADDRNOTAVAIL = 49;

const int ENETDOWN = 50;

const int ENETUNREACH = 51;

const int ENETRESET = 52;

const int ECONNABORTED = 53;

const int ECONNRESET = 54;

const int ENOBUFS = 55;

const int EISCONN = 56;

const int ENOTCONN = 57;

const int ESHUTDOWN = 58;

const int ETOOMANYREFS = 59;

const int ETIMEDOUT = 60;

const int ECONNREFUSED = 61;

const int ELOOP = 62;

const int ENAMETOOLONG = 63;

const int EHOSTDOWN = 64;

const int EHOSTUNREACH = 65;

const int ENOTEMPTY = 66;

const int EPROCLIM = 67;

const int EUSERS = 68;

const int EDQUOT = 69;

const int ESTALE = 70;

const int EREMOTE = 71;

const int EBADRPC = 72;

const int ERPCMISMATCH = 73;

const int EPROGUNAVAIL = 74;

const int EPROGMISMATCH = 75;

const int EPROCUNAVAIL = 76;

const int ENOLCK = 77;

const int ENOSYS = 78;

const int EFTYPE = 79;

const int EAUTH = 80;

const int ENEEDAUTH = 81;

const int EPWROFF = 82;

const int EDEVERR = 83;

const int EOVERFLOW = 84;

const int EBADEXEC = 85;

const int EBADARCH = 86;

const int ESHLIBVERS = 87;

const int EBADMACHO = 88;

const int ECANCELED = 89;

const int EIDRM = 90;

const int ENOMSG = 91;

const int EILSEQ = 92;

const int ENOATTR = 93;

const int EBADMSG = 94;

const int EMULTIHOP = 95;

const int ENODATA = 96;

const int ENOLINK = 97;

const int ENOSR = 98;

const int ENOSTR = 99;

const int EPROTO = 100;

const int ETIME = 101;

const int EOPNOTSUPP = 102;

const int ENOPOLICY = 103;

const int ENOTRECOVERABLE = 104;

const int EOWNERDEAD = 105;

const int EQFULL = 106;

const int ELAST = 106;

const String __PRI_8_LENGTH_MODIFIER__ = 'hh';

const String __PRI_64_LENGTH_MODIFIER__ = 'll';

const String __SCN_64_LENGTH_MODIFIER__ = 'll';

const String __PRI_MAX_LENGTH_MODIFIER__ = 'j';

const String __SCN_MAX_LENGTH_MODIFIER__ = 'j';

const String PRId8 = 'hhd';

const String PRIi8 = 'hhi';

const String PRIo8 = 'hho';

const String PRIu8 = 'hhu';

const String PRIx8 = 'hhx';

const String PRIX8 = 'hhX';

const String PRId16 = 'hd';

const String PRIi16 = 'hi';

const String PRIo16 = 'ho';

const String PRIu16 = 'hu';

const String PRIx16 = 'hx';

const String PRIX16 = 'hX';

const String PRId32 = 'd';

const String PRIi32 = 'i';

const String PRIo32 = 'o';

const String PRIu32 = 'u';

const String PRIx32 = 'x';

const String PRIX32 = 'X';

const String PRId64 = 'lld';

const String PRIi64 = 'lli';

const String PRIo64 = 'llo';

const String PRIu64 = 'llu';

const String PRIx64 = 'llx';

const String PRIX64 = 'llX';

const String PRIdLEAST8 = 'hhd';

const String PRIiLEAST8 = 'hhi';

const String PRIoLEAST8 = 'hho';

const String PRIuLEAST8 = 'hhu';

const String PRIxLEAST8 = 'hhx';

const String PRIXLEAST8 = 'hhX';

const String PRIdLEAST16 = 'hd';

const String PRIiLEAST16 = 'hi';

const String PRIoLEAST16 = 'ho';

const String PRIuLEAST16 = 'hu';

const String PRIxLEAST16 = 'hx';

const String PRIXLEAST16 = 'hX';

const String PRIdLEAST32 = 'd';

const String PRIiLEAST32 = 'i';

const String PRIoLEAST32 = 'o';

const String PRIuLEAST32 = 'u';

const String PRIxLEAST32 = 'x';

const String PRIXLEAST32 = 'X';

const String PRIdLEAST64 = 'lld';

const String PRIiLEAST64 = 'lli';

const String PRIoLEAST64 = 'llo';

const String PRIuLEAST64 = 'llu';

const String PRIxLEAST64 = 'llx';

const String PRIXLEAST64 = 'llX';

const String PRIdFAST8 = 'hhd';

const String PRIiFAST8 = 'hhi';

const String PRIoFAST8 = 'hho';

const String PRIuFAST8 = 'hhu';

const String PRIxFAST8 = 'hhx';

const String PRIXFAST8 = 'hhX';

const String PRIdFAST16 = 'hd';

const String PRIiFAST16 = 'hi';

const String PRIoFAST16 = 'ho';

const String PRIuFAST16 = 'hu';

const String PRIxFAST16 = 'hx';

const String PRIXFAST16 = 'hX';

const String PRIdFAST32 = 'd';

const String PRIiFAST32 = 'i';

const String PRIoFAST32 = 'o';

const String PRIuFAST32 = 'u';

const String PRIxFAST32 = 'x';

const String PRIXFAST32 = 'X';

const String PRIdFAST64 = 'lld';

const String PRIiFAST64 = 'lli';

const String PRIoFAST64 = 'llo';

const String PRIuFAST64 = 'llu';

const String PRIxFAST64 = 'llx';

const String PRIXFAST64 = 'llX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String PRIdMAX = 'jd';

const String PRIiMAX = 'ji';

const String PRIoMAX = 'jo';

const String PRIuMAX = 'ju';

const String PRIxMAX = 'jx';

const String PRIXMAX = 'jX';

const String SCNd8 = 'hhd';

const String SCNi8 = 'hhi';

const String SCNo8 = 'hho';

const String SCNu8 = 'hhu';

const String SCNx8 = 'hhx';

const String SCNd16 = 'hd';

const String SCNi16 = 'hi';

const String SCNo16 = 'ho';

const String SCNu16 = 'hu';

const String SCNx16 = 'hx';

const String SCNd32 = 'd';

const String SCNi32 = 'i';

const String SCNo32 = 'o';

const String SCNu32 = 'u';

const String SCNx32 = 'x';

const String SCNd64 = 'lld';

const String SCNi64 = 'lli';

const String SCNo64 = 'llo';

const String SCNu64 = 'llu';

const String SCNx64 = 'llx';

const String SCNdLEAST8 = 'hhd';

const String SCNiLEAST8 = 'hhi';

const String SCNoLEAST8 = 'hho';

const String SCNuLEAST8 = 'hhu';

const String SCNxLEAST8 = 'hhx';

const String SCNdLEAST16 = 'hd';

const String SCNiLEAST16 = 'hi';

const String SCNoLEAST16 = 'ho';

const String SCNuLEAST16 = 'hu';

const String SCNxLEAST16 = 'hx';

const String SCNdLEAST32 = 'd';

const String SCNiLEAST32 = 'i';

const String SCNoLEAST32 = 'o';

const String SCNuLEAST32 = 'u';

const String SCNxLEAST32 = 'x';

const String SCNdLEAST64 = 'lld';

const String SCNiLEAST64 = 'lli';

const String SCNoLEAST64 = 'llo';

const String SCNuLEAST64 = 'llu';

const String SCNxLEAST64 = 'llx';

const String SCNdFAST8 = 'hhd';

const String SCNiFAST8 = 'hhi';

const String SCNoFAST8 = 'hho';

const String SCNuFAST8 = 'hhu';

const String SCNxFAST8 = 'hhx';

const String SCNdFAST16 = 'hd';

const String SCNiFAST16 = 'hi';

const String SCNoFAST16 = 'ho';

const String SCNuFAST16 = 'hu';

const String SCNxFAST16 = 'hx';

const String SCNdFAST32 = 'd';

const String SCNiFAST32 = 'i';

const String SCNoFAST32 = 'o';

const String SCNuFAST32 = 'u';

const String SCNxFAST32 = 'x';

const String SCNdFAST64 = 'lld';

const String SCNiFAST64 = 'lli';

const String SCNoFAST64 = 'llo';

const String SCNuFAST64 = 'llu';

const String SCNxFAST64 = 'llx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const String SCNdMAX = 'jd';

const String SCNiMAX = 'ji';

const String SCNoMAX = 'jo';

const String SCNuMAX = 'ju';

const String SCNxMAX = 'jx';

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_15_0 = 150000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_4 = 140400;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_18_0 = 180000;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_11_0 = 110000;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_18_0 = 180000;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_9_0 = 90000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_24_0 = 240000;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_2_0 = 20000;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_15_0 = 150000;

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 150000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 150000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_CLK_TCK = 100;

const int MB_LEN_MAX = 6;

const int CLK_TCK = 100;

const int CHAR_BIT = 8;

const int SCHAR_MAX = 127;

const int SCHAR_MIN = -128;

const int UCHAR_MAX = 255;

const int CHAR_MAX = 127;

const int CHAR_MIN = -128;

const int USHRT_MAX = 65535;

const int SHRT_MAX = 32767;

const int SHRT_MIN = -32768;

const int UINT_MAX = 4294967295;

const int INT_MAX = 2147483647;

const int INT_MIN = -2147483648;

const int ULONG_MAX = -1;

const int LONG_MAX = 9223372036854775807;

const int LONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int LONG_BIT = 64;

const int SSIZE_MAX = 9223372036854775807;

const int WORD_BIT = 32;

const int SIZE_T_MAX = -1;

const int UQUAD_MAX = -1;

const int QUAD_MAX = 9223372036854775807;

const int QUAD_MIN = -9223372036854775808;

const int ARG_MAX = 1048576;

const int CHILD_MAX = 266;

const int GID_MAX = 2147483647;

const int LINK_MAX = 32767;

const int MAX_CANON = 1024;

const int MAX_INPUT = 1024;

const int NAME_MAX = 255;

const int NGROUPS_MAX = 16;

const int UID_MAX = 2147483647;

const int OPEN_MAX = 10240;

const int PATH_MAX = 1024;

const int PIPE_BUF = 512;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int CHARCLASS_NAME_MAX = 14;

const int COLL_WEIGHTS_MAX = 2;

const int EQUIV_CLASS_MAX = 2;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int RE_DUP_MAX = 255;

const int NZERO = 20;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_EQUIV_CLASS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_KEYS_MAX = 512;

const int PTHREAD_STACK_MIN = 16384;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_SS_REPL_MAX = 4;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TRACE_EVENT_NAME_MAX = 30;

const int _POSIX_TRACE_NAME_MAX = 8;

const int _POSIX_TRACE_SYS_MAX = 8;

const int _POSIX_TRACE_USER_EVENT_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX_RE_DUP_MAX = 255;

const int OFF_MIN = -9223372036854775808;

const int OFF_MAX = 9223372036854775807;

const int PASS_MAX = 128;

const int NL_ARGMAX = 9;

const int NL_LANGMAX = 14;

const int NL_MSGMAX = 32767;

const int NL_NMAX = 1;

const int NL_SETMAX = 255;

const int NL_TEXTMAX = 2048;

const int _XOPEN_IOV_MAX = 16;

const int IOV_MAX = 1024;

const int _XOPEN_NAME_MAX = 255;

const int _XOPEN_PATH_MAX = 1024;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double NAN = double.nan;

const double INFINITY = double.infinity;

const int FP_NAN = 1;

const int FP_INFINITE = 2;

const int FP_ZERO = 3;

const int FP_NORMAL = 4;

const int FP_SUBNORMAL = 5;

const int FP_SUPERNORMAL = 6;

const int FP_FAST_FMA = 1;

const int FP_FAST_FMAF = 1;

const int FP_FAST_FMAL = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = -2147483648;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const double M_E = 2.718281828459045;

const double M_LOG2E = 1.4426950408889634;

const double M_LOG10E = 0.4342944819032518;

const double M_LN2 = 0.6931471805599453;

const double M_LN10 = 2.302585092994046;

const double M_PI = 3.141592653589793;

const double M_PI_2 = 1.5707963267948966;

const double M_PI_4 = 0.7853981633974483;

const double M_1_PI = 0.3183098861837907;

const double M_2_PI = 0.6366197723675814;

const double M_2_SQRTPI = 1.1283791670955126;

const double M_SQRT2 = 1.4142135623730951;

const double M_SQRT1_2 = 0.7071067811865476;

const double MAXFLOAT = 3.4028234663852886e+38;

const int FP_SNAN = 1;

const int FP_QNAN = 1;

const double HUGE = 3.4028234663852886e+38;

const double X_TLOSS = 14148475504056880.0;

const int DOMAIN = 1;

const int SING = 2;

const int OVERFLOW = 3;

const int UNDERFLOW = 4;

const int TLOSS = 5;

const int PLOSS = 6;

const int RENAME_SECLUDE = 1;

const int RENAME_SWAP = 2;

const int RENAME_EXCL = 4;

const int RENAME_RESERVED1 = 8;

const int RENAME_NOFOLLOW_ANY = 16;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const int SEEK_HOLE = 3;

const int SEEK_DATA = 4;

const int __SLBF = 1;

const int __SNBF = 2;

const int __SRD = 4;

const int __SWR = 8;

const int __SRW = 16;

const int __SEOF = 32;

const int __SERR = 64;

const int __SMBF = 128;

const int __SAPP = 256;

const int __SSTR = 512;

const int __SOPT = 1024;

const int __SNPT = 2048;

const int __SOFF = 4096;

const int __SMOD = 8192;

const int __SALC = 16384;

const int __SIGN = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 1024;

const int EOF = -1;

const int FOPEN_MAX = 20;

const int FILENAME_MAX = 1024;

const String P_tmpdir = '/var/tmp/';

const int L_tmpnam = 1024;

const int TMP_MAX = 308915776;

const int L_ctermid = 1024;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int AV_HAVE_BIGENDIAN = 0;

const int AV_HAVE_FAST_UNALIGNED = 1;

const int AVERROR_BSF_NOT_FOUND = -1179861752;

const int AVERROR_BUG = -558323010;

const int AVERROR_BUFFER_TOO_SMALL = -1397118274;

const int AVERROR_DECODER_NOT_FOUND = -1128613112;

const int AVERROR_DEMUXER_NOT_FOUND = -1296385272;

const int AVERROR_ENCODER_NOT_FOUND = -1129203192;

const int AVERROR_EOF = -541478725;

const int AVERROR_EXIT = -1414092869;

const int AVERROR_EXTERNAL = -542398533;

const int AVERROR_FILTER_NOT_FOUND = -1279870712;

const int AVERROR_INVALIDDATA = -1094995529;

const int AVERROR_MUXER_NOT_FOUND = -1481985528;

const int AVERROR_OPTION_NOT_FOUND = -1414549496;

const int AVERROR_PATCHWELCOME = -1163346256;

const int AVERROR_PROTOCOL_NOT_FOUND = -1330794744;

const int AVERROR_STREAM_NOT_FOUND = -1381258232;

const int AVERROR_BUG2 = -541545794;

const int AVERROR_UNKNOWN = -1313558101;

const int AVERROR_EXPERIMENTAL = -733130664;

const int AVERROR_INPUT_CHANGED = -1668179713;

const int AVERROR_OUTPUT_CHANGED = -1668179714;

const int AVERROR_HTTP_BAD_REQUEST = -808465656;

const int AVERROR_HTTP_UNAUTHORIZED = -825242872;

const int AVERROR_HTTP_FORBIDDEN = -858797304;

const int AVERROR_HTTP_NOT_FOUND = -875574520;

const int AVERROR_HTTP_TOO_MANY_REQUESTS = -959591672;

const int AVERROR_HTTP_OTHER_4XX = -1482175736;

const int AVERROR_HTTP_SERVER_ERROR = -1482175992;

const int AV_ERROR_MAX_STRING_SIZE = 64;

const int LIBAVUTIL_VERSION_MAJOR = 59;

const int LIBAVUTIL_VERSION_MINOR = 39;

const int LIBAVUTIL_VERSION_MICRO = 100;

const int LIBAVUTIL_VERSION_INT = 3876708;

const int LIBAVUTIL_BUILD = 3876708;

const String LIBAVUTIL_IDENT = 'Lavu59.39.100';

const int FF_API_HDR_VIVID_THREE_SPLINE = 1;

const int FF_API_FRAME_PKT = 1;

const int FF_API_INTERLACED_FRAME = 1;

const int FF_API_FRAME_KEY = 1;

const int FF_API_PALETTE_HAS_CHANGED = 1;

const int FF_API_VULKAN_CONTIGUOUS_MEMORY = 1;

const int FF_API_H274_FILM_GRAIN_VCS = 1;

const int FF_API_MOD_UINTP2 = 1;

const int FF_API_RISCV_FD_ZBA = 1;

const int FF_API_VULKAN_FIXED_QUEUES = 1;

const double M_Ef = 2.7182817459106445;

const double M_LN2f = 0.6931471824645996;

const double M_LN10f = 2.3025851249694824;

const double M_LOG2_10 = 3.321928094887362;

const double M_LOG2_10f = 3.321928024291992;

const double M_PHI = 1.618033988749895;

const double M_PHIf = 1.6180340051651;

const double M_PIf = 3.1415927410125732;

const double M_PI_2f = 1.5707963705062866;

const double M_PI_4f = 0.7853981852531433;

const double M_1_PIf = 0.31830987334251404;

const double M_2_PIf = 0.6366197466850281;

const double M_2_SQRTPIf = 1.128379225730896;

const double M_SQRT1_2f = 0.7071067690849304;

const double M_SQRT2f = 1.4142135381698608;

const int AV_LOG_QUIET = -8;

const int AV_LOG_PANIC = 0;

const int AV_LOG_FATAL = 8;

const int AV_LOG_ERROR = 16;

const int AV_LOG_WARNING = 24;

const int AV_LOG_INFO = 32;

const int AV_LOG_VERBOSE = 40;

const int AV_LOG_DEBUG = 48;

const int AV_LOG_TRACE = 56;

const int AV_LOG_MAX_OFFSET = 64;

const int AV_LOG_SKIP_REPEATED = 1;

const int AV_LOG_PRINT_LEVEL = 2;

const int AVPALETTE_SIZE = 1024;

const int AVPALETTE_COUNT = 256;

const int AV_VIDEO_MAX_PLANES = 4;

const int AV_PIX_FMT_RGB32 = 28;

const int AV_PIX_FMT_RGB32_1 = 27;

const int AV_PIX_FMT_BGR32 = 26;

const int AV_PIX_FMT_BGR32_1 = 25;

const int AV_PIX_FMT_0RGB32 = 121;

const int AV_PIX_FMT_0BGR32 = 119;

const int AV_PIX_FMT_GRAY9 = 173;

const int AV_PIX_FMT_GRAY10 = 168;

const int AV_PIX_FMT_GRAY12 = 166;

const int AV_PIX_FMT_GRAY14 = 181;

const int AV_PIX_FMT_GRAY16 = 30;

const int AV_PIX_FMT_YA16 = 110;

const int AV_PIX_FMT_RGB48 = 35;

const int AV_PIX_FMT_RGB565 = 37;

const int AV_PIX_FMT_RGB555 = 39;

const int AV_PIX_FMT_RGB444 = 52;

const int AV_PIX_FMT_RGBA64 = 105;

const int AV_PIX_FMT_BGR48 = 58;

const int AV_PIX_FMT_BGR565 = 41;

const int AV_PIX_FMT_BGR555 = 43;

const int AV_PIX_FMT_BGR444 = 54;

const int AV_PIX_FMT_BGRA64 = 107;

const int AV_PIX_FMT_YUV420P9 = 60;

const int AV_PIX_FMT_YUV422P9 = 70;

const int AV_PIX_FMT_YUV444P9 = 66;

const int AV_PIX_FMT_YUV420P10 = 62;

const int AV_PIX_FMT_YUV422P10 = 64;

const int AV_PIX_FMT_YUV440P10 = 151;

const int AV_PIX_FMT_YUV444P10 = 68;

const int AV_PIX_FMT_YUV420P12 = 123;

const int AV_PIX_FMT_YUV422P12 = 127;

const int AV_PIX_FMT_YUV440P12 = 153;

const int AV_PIX_FMT_YUV444P12 = 131;

const int AV_PIX_FMT_YUV420P14 = 125;

const int AV_PIX_FMT_YUV422P14 = 129;

const int AV_PIX_FMT_YUV444P14 = 133;

const int AV_PIX_FMT_YUV420P16 = 45;

const int AV_PIX_FMT_YUV422P16 = 47;

const int AV_PIX_FMT_YUV444P16 = 49;

const int AV_PIX_FMT_GBRP9 = 73;

const int AV_PIX_FMT_GBRP10 = 75;

const int AV_PIX_FMT_GBRP12 = 135;

const int AV_PIX_FMT_GBRP14 = 137;

const int AV_PIX_FMT_GBRP16 = 77;

const int AV_PIX_FMT_GBRAP10 = 163;

const int AV_PIX_FMT_GBRAP12 = 161;

const int AV_PIX_FMT_GBRAP14 = 226;

const int AV_PIX_FMT_GBRAP16 = 113;

const int AV_PIX_FMT_BAYER_BGGR16 = 143;

const int AV_PIX_FMT_BAYER_RGGB16 = 145;

const int AV_PIX_FMT_BAYER_GBRG16 = 147;

const int AV_PIX_FMT_BAYER_GRBG16 = 149;

const int AV_PIX_FMT_GBRPF32 = 175;

const int AV_PIX_FMT_GBRAPF32 = 177;

const int AV_PIX_FMT_GRAYF32 = 183;

const int AV_PIX_FMT_YUVA420P9 = 81;

const int AV_PIX_FMT_YUVA422P9 = 83;

const int AV_PIX_FMT_YUVA444P9 = 85;

const int AV_PIX_FMT_YUVA420P10 = 87;

const int AV_PIX_FMT_YUVA422P10 = 89;

const int AV_PIX_FMT_YUVA444P10 = 91;

const int AV_PIX_FMT_YUVA422P12 = 185;

const int AV_PIX_FMT_YUVA444P12 = 187;

const int AV_PIX_FMT_YUVA420P16 = 93;

const int AV_PIX_FMT_YUVA422P16 = 95;

const int AV_PIX_FMT_YUVA444P16 = 97;

const int AV_PIX_FMT_XYZ12 = 99;

const int AV_PIX_FMT_NV20 = 102;

const int AV_PIX_FMT_AYUV64 = 155;

const int AV_PIX_FMT_P010 = 158;

const int AV_PIX_FMT_P012 = 209;

const int AV_PIX_FMT_P016 = 169;

const int AV_PIX_FMT_Y210 = 192;

const int AV_PIX_FMT_Y212 = 212;

const int AV_PIX_FMT_XV30 = 214;

const int AV_PIX_FMT_XV36 = 216;

const int AV_PIX_FMT_X2RGB10 = 193;

const int AV_PIX_FMT_X2BGR10 = 195;

const int AV_PIX_FMT_P210 = 198;

const int AV_PIX_FMT_P410 = 200;

const int AV_PIX_FMT_P212 = 222;

const int AV_PIX_FMT_P412 = 224;

const int AV_PIX_FMT_P216 = 202;

const int AV_PIX_FMT_P416 = 204;

const int AV_PIX_FMT_RGBAF16 = 207;

const int AV_PIX_FMT_RGBF32 = 218;

const int AV_PIX_FMT_RGBAF32 = 220;

const int AV_FOURCC_MAX_STRING_SIZE = 32;

const int AV_BUFFER_FLAG_READONLY = 1;

const int AV_CH_FRONT_LEFT = 1;

const int AV_CH_FRONT_RIGHT = 2;

const int AV_CH_FRONT_CENTER = 4;

const int AV_CH_LOW_FREQUENCY = 8;

const int AV_CH_BACK_LEFT = 16;

const int AV_CH_BACK_RIGHT = 32;

const int AV_CH_FRONT_LEFT_OF_CENTER = 64;

const int AV_CH_FRONT_RIGHT_OF_CENTER = 128;

const int AV_CH_BACK_CENTER = 256;

const int AV_CH_SIDE_LEFT = 512;

const int AV_CH_SIDE_RIGHT = 1024;

const int AV_CH_TOP_CENTER = 2048;

const int AV_CH_TOP_FRONT_LEFT = 4096;

const int AV_CH_TOP_FRONT_CENTER = 8192;

const int AV_CH_TOP_FRONT_RIGHT = 16384;

const int AV_CH_TOP_BACK_LEFT = 32768;

const int AV_CH_TOP_BACK_CENTER = 65536;

const int AV_CH_TOP_BACK_RIGHT = 131072;

const int AV_CH_STEREO_LEFT = 536870912;

const int AV_CH_STEREO_RIGHT = 1073741824;

const int AV_CH_WIDE_LEFT = 2147483648;

const int AV_CH_WIDE_RIGHT = 4294967296;

const int AV_CH_SURROUND_DIRECT_LEFT = 8589934592;

const int AV_CH_SURROUND_DIRECT_RIGHT = 17179869184;

const int AV_CH_LOW_FREQUENCY_2 = 34359738368;

const int AV_CH_TOP_SIDE_LEFT = 68719476736;

const int AV_CH_TOP_SIDE_RIGHT = 137438953472;

const int AV_CH_BOTTOM_FRONT_CENTER = 274877906944;

const int AV_CH_BOTTOM_FRONT_LEFT = 549755813888;

const int AV_CH_BOTTOM_FRONT_RIGHT = 1099511627776;

const int AV_CH_SIDE_SURROUND_LEFT = 2199023255552;

const int AV_CH_SIDE_SURROUND_RIGHT = 4398046511104;

const int AV_CH_TOP_SURROUND_LEFT = 8796093022208;

const int AV_CH_TOP_SURROUND_RIGHT = 17592186044416;

const int AV_CH_LAYOUT_MONO = 4;

const int AV_CH_LAYOUT_STEREO = 3;

const int AV_CH_LAYOUT_2POINT1 = 11;

const int AV_CH_LAYOUT_2_1 = 259;

const int AV_CH_LAYOUT_SURROUND = 7;

const int AV_CH_LAYOUT_3POINT1 = 15;

const int AV_CH_LAYOUT_4POINT0 = 263;

const int AV_CH_LAYOUT_4POINT1 = 271;

const int AV_CH_LAYOUT_2_2 = 1539;

const int AV_CH_LAYOUT_QUAD = 51;

const int AV_CH_LAYOUT_5POINT0 = 1543;

const int AV_CH_LAYOUT_5POINT1 = 1551;

const int AV_CH_LAYOUT_5POINT0_BACK = 55;

const int AV_CH_LAYOUT_5POINT1_BACK = 63;

const int AV_CH_LAYOUT_6POINT0 = 1799;

const int AV_CH_LAYOUT_6POINT0_FRONT = 1731;

const int AV_CH_LAYOUT_HEXAGONAL = 311;

const int AV_CH_LAYOUT_3POINT1POINT2 = 20495;

const int AV_CH_LAYOUT_6POINT1 = 1807;

const int AV_CH_LAYOUT_6POINT1_BACK = 319;

const int AV_CH_LAYOUT_6POINT1_FRONT = 1739;

const int AV_CH_LAYOUT_7POINT0 = 1591;

const int AV_CH_LAYOUT_7POINT0_FRONT = 1735;

const int AV_CH_LAYOUT_7POINT1 = 1599;

const int AV_CH_LAYOUT_7POINT1_WIDE = 1743;

const int AV_CH_LAYOUT_7POINT1_WIDE_BACK = 255;

const int AV_CH_LAYOUT_5POINT1POINT2_BACK = 20543;

const int AV_CH_LAYOUT_OCTAGONAL = 1847;

const int AV_CH_LAYOUT_CUBE = 184371;

const int AV_CH_LAYOUT_5POINT1POINT4_BACK = 184383;

const int AV_CH_LAYOUT_7POINT1POINT2 = 22079;

const int AV_CH_LAYOUT_7POINT1POINT4_BACK = 185919;

const int AV_CH_LAYOUT_7POINT2POINT3 = 34359825983;

const int AV_CH_LAYOUT_9POINT1POINT4_BACK = 186111;

const int AV_CH_LAYOUT_HEXADECAGONAL = 6442710839;

const int AV_CH_LAYOUT_STEREO_DOWNMIX = 1610612736;

const int AV_CH_LAYOUT_22POINT2 = 2164663779327;

const int AV_CH_LAYOUT_7POINT1_TOP_BACK = 20543;

const int AV_CHANNEL_LAYOUT_RETYPE_FLAG_LOSSLESS = 1;

const int AV_CHANNEL_LAYOUT_RETYPE_FLAG_CANONICAL = 2;

const int AV_DICT_MATCH_CASE = 1;

const int AV_DICT_IGNORE_SUFFIX = 2;

const int AV_DICT_DONT_STRDUP_KEY = 4;

const int AV_DICT_DONT_STRDUP_VAL = 8;

const int AV_DICT_DONT_OVERWRITE = 16;

const int AV_DICT_APPEND = 32;

const int AV_DICT_MULTIKEY = 64;

const int AV_NUM_DATA_POINTERS = 8;

const int AV_FRAME_FLAG_CORRUPT = 1;

const int AV_FRAME_FLAG_KEY = 2;

const int AV_FRAME_FLAG_DISCARD = 4;

const int AV_FRAME_FLAG_INTERLACED = 8;

const int AV_FRAME_FLAG_TOP_FIELD_FIRST = 16;

const int FF_DECODE_ERROR_INVALID_BITSTREAM = 1;

const int FF_DECODE_ERROR_MISSING_REFERENCE = 2;

const int FF_DECODE_ERROR_CONCEALMENT_ACTIVE = 4;

const int FF_DECODE_ERROR_DECODE_SLICES = 8;

const int AV_FRAME_SIDE_DATA_FLAG_UNIQUE = 1;

const int AV_FRAME_SIDE_DATA_FLAG_REPLACE = 2;

const int LIBAVCODEC_VERSION_MAJOR = 61;

const int FF_API_INIT_PACKET = 1;

const int FF_API_SUBFRAMES = 1;

const int FF_API_TICKS_PER_FRAME = 1;

const int FF_API_DROPCHANGED = 1;

const int FF_API_AVFFT = 1;

const int FF_API_FF_PROFILE_LEVEL = 1;

const int FF_API_AVCODEC_CLOSE = 1;

const int FF_API_BUFFER_MIN_SIZE = 1;

const int FF_API_VDPAU_ALLOC_GET_SET = 1;

const int FF_API_QUALITY_FACTOR = 1;

const int AV_CODEC_ID_IFF_BYTERUN1 = 136;

const int AV_CODEC_ID_H265 = 173;

const int AV_CODEC_ID_H266 = 196;

const int AV_CODEC_CAP_DRAW_HORIZ_BAND = 1;

const int AV_CODEC_CAP_DR1 = 2;

const int AV_CODEC_CAP_DELAY = 32;

const int AV_CODEC_CAP_SMALL_LAST_FRAME = 64;

const int AV_CODEC_CAP_SUBFRAMES = 256;

const int AV_CODEC_CAP_EXPERIMENTAL = 512;

const int AV_CODEC_CAP_CHANNEL_CONF = 1024;

const int AV_CODEC_CAP_FRAME_THREADS = 4096;

const int AV_CODEC_CAP_SLICE_THREADS = 8192;

const int AV_CODEC_CAP_PARAM_CHANGE = 16384;

const int AV_CODEC_CAP_OTHER_THREADS = 32768;

const int AV_CODEC_CAP_VARIABLE_FRAME_SIZE = 65536;

const int AV_CODEC_CAP_AVOID_PROBING = 131072;

const int AV_CODEC_CAP_HARDWARE = 262144;

const int AV_CODEC_CAP_HYBRID = 524288;

const int AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = 1048576;

const int AV_CODEC_CAP_ENCODER_FLUSH = 2097152;

const int AV_CODEC_CAP_ENCODER_RECON_FRAME = 4194304;

const int AV_INPUT_BUFFER_PADDING_SIZE = 64;

const int AV_EF_CRCCHECK = 1;

const int AV_EF_BITSTREAM = 2;

const int AV_EF_BUFFER = 4;

const int AV_EF_EXPLODE = 8;

const int AV_EF_IGNORE_ERR = 32768;

const int AV_EF_CAREFUL = 65536;

const int AV_EF_COMPLIANT = 131072;

const int AV_EF_AGGRESSIVE = 262144;

const int FF_COMPLIANCE_VERY_STRICT = 2;

const int FF_COMPLIANCE_STRICT = 1;

const int FF_COMPLIANCE_NORMAL = 0;

const int FF_COMPLIANCE_UNOFFICIAL = -1;

const int FF_COMPLIANCE_EXPERIMENTAL = -2;

const int AV_PROFILE_UNKNOWN = -99;

const int AV_PROFILE_RESERVED = -100;

const int AV_PROFILE_AAC_MAIN = 0;

const int AV_PROFILE_AAC_LOW = 1;

const int AV_PROFILE_AAC_SSR = 2;

const int AV_PROFILE_AAC_LTP = 3;

const int AV_PROFILE_AAC_HE = 4;

const int AV_PROFILE_AAC_HE_V2 = 28;

const int AV_PROFILE_AAC_LD = 22;

const int AV_PROFILE_AAC_ELD = 38;

const int AV_PROFILE_AAC_USAC = 41;

const int AV_PROFILE_MPEG2_AAC_LOW = 128;

const int AV_PROFILE_MPEG2_AAC_HE = 131;

const int AV_PROFILE_DNXHD = 0;

const int AV_PROFILE_DNXHR_LB = 1;

const int AV_PROFILE_DNXHR_SQ = 2;

const int AV_PROFILE_DNXHR_HQ = 3;

const int AV_PROFILE_DNXHR_HQX = 4;

const int AV_PROFILE_DNXHR_444 = 5;

const int AV_PROFILE_DTS = 20;

const int AV_PROFILE_DTS_ES = 30;

const int AV_PROFILE_DTS_96_24 = 40;

const int AV_PROFILE_DTS_HD_HRA = 50;

const int AV_PROFILE_DTS_HD_MA = 60;

const int AV_PROFILE_DTS_EXPRESS = 70;

const int AV_PROFILE_DTS_HD_MA_X = 61;

const int AV_PROFILE_DTS_HD_MA_X_IMAX = 62;

const int AV_PROFILE_EAC3_DDP_ATMOS = 30;

const int AV_PROFILE_TRUEHD_ATMOS = 30;

const int AV_PROFILE_MPEG2_422 = 0;

const int AV_PROFILE_MPEG2_HIGH = 1;

const int AV_PROFILE_MPEG2_SS = 2;

const int AV_PROFILE_MPEG2_SNR_SCALABLE = 3;

const int AV_PROFILE_MPEG2_MAIN = 4;

const int AV_PROFILE_MPEG2_SIMPLE = 5;

const int AV_PROFILE_H264_CONSTRAINED = 512;

const int AV_PROFILE_H264_INTRA = 2048;

const int AV_PROFILE_H264_BASELINE = 66;

const int AV_PROFILE_H264_CONSTRAINED_BASELINE = 578;

const int AV_PROFILE_H264_MAIN = 77;

const int AV_PROFILE_H264_EXTENDED = 88;

const int AV_PROFILE_H264_HIGH = 100;

const int AV_PROFILE_H264_HIGH_10 = 110;

const int AV_PROFILE_H264_HIGH_10_INTRA = 2158;

const int AV_PROFILE_H264_MULTIVIEW_HIGH = 118;

const int AV_PROFILE_H264_HIGH_422 = 122;

const int AV_PROFILE_H264_HIGH_422_INTRA = 2170;

const int AV_PROFILE_H264_STEREO_HIGH = 128;

const int AV_PROFILE_H264_HIGH_444 = 144;

const int AV_PROFILE_H264_HIGH_444_PREDICTIVE = 244;

const int AV_PROFILE_H264_HIGH_444_INTRA = 2292;

const int AV_PROFILE_H264_CAVLC_444 = 44;

const int AV_PROFILE_VC1_SIMPLE = 0;

const int AV_PROFILE_VC1_MAIN = 1;

const int AV_PROFILE_VC1_COMPLEX = 2;

const int AV_PROFILE_VC1_ADVANCED = 3;

const int AV_PROFILE_MPEG4_SIMPLE = 0;

const int AV_PROFILE_MPEG4_SIMPLE_SCALABLE = 1;

const int AV_PROFILE_MPEG4_CORE = 2;

const int AV_PROFILE_MPEG4_MAIN = 3;

const int AV_PROFILE_MPEG4_N_BIT = 4;

const int AV_PROFILE_MPEG4_SCALABLE_TEXTURE = 5;

const int AV_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6;

const int AV_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7;

const int AV_PROFILE_MPEG4_HYBRID = 8;

const int AV_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9;

const int AV_PROFILE_MPEG4_CORE_SCALABLE = 10;

const int AV_PROFILE_MPEG4_ADVANCED_CODING = 11;

const int AV_PROFILE_MPEG4_ADVANCED_CORE = 12;

const int AV_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;

const int AV_PROFILE_MPEG4_SIMPLE_STUDIO = 14;

const int AV_PROFILE_MPEG4_ADVANCED_SIMPLE = 15;

const int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 1;

const int AV_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 2;

const int AV_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768;

const int AV_PROFILE_JPEG2000_DCINEMA_2K = 3;

const int AV_PROFILE_JPEG2000_DCINEMA_4K = 4;

const int AV_PROFILE_VP9_0 = 0;

const int AV_PROFILE_VP9_1 = 1;

const int AV_PROFILE_VP9_2 = 2;

const int AV_PROFILE_VP9_3 = 3;

const int AV_PROFILE_HEVC_MAIN = 1;

const int AV_PROFILE_HEVC_MAIN_10 = 2;

const int AV_PROFILE_HEVC_MAIN_STILL_PICTURE = 3;

const int AV_PROFILE_HEVC_REXT = 4;

const int AV_PROFILE_HEVC_MULTIVIEW_MAIN = 6;

const int AV_PROFILE_HEVC_SCC = 9;

const int AV_PROFILE_VVC_MAIN_10 = 1;

const int AV_PROFILE_VVC_MAIN_10_444 = 33;

const int AV_PROFILE_AV1_MAIN = 0;

const int AV_PROFILE_AV1_HIGH = 1;

const int AV_PROFILE_AV1_PROFESSIONAL = 2;

const int AV_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = 192;

const int AV_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 193;

const int AV_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = 194;

const int AV_PROFILE_MJPEG_HUFFMAN_LOSSLESS = 195;

const int AV_PROFILE_MJPEG_JPEG_LS = 247;

const int AV_PROFILE_SBC_MSBC = 1;

const int AV_PROFILE_PRORES_PROXY = 0;

const int AV_PROFILE_PRORES_LT = 1;

const int AV_PROFILE_PRORES_STANDARD = 2;

const int AV_PROFILE_PRORES_HQ = 3;

const int AV_PROFILE_PRORES_4444 = 4;

const int AV_PROFILE_PRORES_XQ = 5;

const int AV_PROFILE_ARIB_PROFILE_A = 0;

const int AV_PROFILE_ARIB_PROFILE_C = 1;

const int AV_PROFILE_KLVA_SYNC = 0;

const int AV_PROFILE_KLVA_ASYNC = 1;

const int AV_PROFILE_EVC_BASELINE = 0;

const int AV_PROFILE_EVC_MAIN = 1;

const int AV_LEVEL_UNKNOWN = -99;

const int AV_PKT_DATA_QUALITY_FACTOR = 8;

const int AV_PKT_FLAG_KEY = 1;

const int AV_PKT_FLAG_CORRUPT = 2;

const int AV_PKT_FLAG_DISCARD = 4;

const int AV_PKT_FLAG_TRUSTED = 8;

const int AV_PKT_FLAG_DISPOSABLE = 16;

const int LIBAVCODEC_VERSION_MINOR = 19;

const int LIBAVCODEC_VERSION_MICRO = 100;

const int LIBAVCODEC_VERSION_INT = 4002660;

const int LIBAVCODEC_BUILD = 4002660;

const String LIBAVCODEC_IDENT = 'Lavc61.19.100';

const int AV_CODEC_PROP_INTRA_ONLY = 1;

const int AV_CODEC_PROP_LOSSY = 2;

const int AV_CODEC_PROP_LOSSLESS = 4;

const int AV_CODEC_PROP_REORDER = 8;

const int AV_CODEC_PROP_FIELDS = 16;

const int AV_CODEC_PROP_BITMAP_SUB = 65536;

const int AV_CODEC_PROP_TEXT_SUB = 131072;

const int AV_INPUT_BUFFER_MIN_SIZE = 16384;

const int AV_CODEC_FLAG_UNALIGNED = 1;

const int AV_CODEC_FLAG_QSCALE = 2;

const int AV_CODEC_FLAG_4MV = 4;

const int AV_CODEC_FLAG_OUTPUT_CORRUPT = 8;

const int AV_CODEC_FLAG_QPEL = 16;

const int AV_CODEC_FLAG_DROPCHANGED = 32;

const int AV_CODEC_FLAG_RECON_FRAME = 64;

const int AV_CODEC_FLAG_COPY_OPAQUE = 128;

const int AV_CODEC_FLAG_FRAME_DURATION = 256;

const int AV_CODEC_FLAG_PASS1 = 512;

const int AV_CODEC_FLAG_PASS2 = 1024;

const int AV_CODEC_FLAG_LOOP_FILTER = 2048;

const int AV_CODEC_FLAG_GRAY = 8192;

const int AV_CODEC_FLAG_PSNR = 32768;

const int AV_CODEC_FLAG_INTERLACED_DCT = 262144;

const int AV_CODEC_FLAG_LOW_DELAY = 524288;

const int AV_CODEC_FLAG_GLOBAL_HEADER = 4194304;

const int AV_CODEC_FLAG_BITEXACT = 8388608;

const int AV_CODEC_FLAG_AC_PRED = 16777216;

const int AV_CODEC_FLAG_INTERLACED_ME = 536870912;

const int AV_CODEC_FLAG_CLOSED_GOP = 2147483648;

const int AV_CODEC_FLAG2_FAST = 1;

const int AV_CODEC_FLAG2_NO_OUTPUT = 4;

const int AV_CODEC_FLAG2_LOCAL_HEADER = 8;

const int AV_CODEC_FLAG2_CHUNKS = 32768;

const int AV_CODEC_FLAG2_IGNORE_CROP = 65536;

const int AV_CODEC_FLAG2_SHOW_ALL = 4194304;

const int AV_CODEC_FLAG2_EXPORT_MVS = 268435456;

const int AV_CODEC_FLAG2_SKIP_MANUAL = 536870912;

const int AV_CODEC_FLAG2_RO_FLUSH_NOOP = 1073741824;

const int AV_CODEC_FLAG2_ICC_PROFILES = 2147483648;

const int AV_CODEC_EXPORT_DATA_MVS = 1;

const int AV_CODEC_EXPORT_DATA_PRFT = 2;

const int AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS = 4;

const int AV_CODEC_EXPORT_DATA_FILM_GRAIN = 8;

const int AV_CODEC_EXPORT_DATA_ENHANCEMENTS = 16;

const int AV_GET_BUFFER_FLAG_REF = 1;

const int AV_GET_ENCODE_BUFFER_FLAG_REF = 1;

const int SLICE_FLAG_CODED_ORDER = 1;

const int SLICE_FLAG_ALLOW_FIELD = 2;

const int SLICE_FLAG_ALLOW_PLANE = 4;

const int FF_CMP_SAD = 0;

const int FF_CMP_SSE = 1;

const int FF_CMP_SATD = 2;

const int FF_CMP_DCT = 3;

const int FF_CMP_PSNR = 4;

const int FF_CMP_BIT = 5;

const int FF_CMP_RD = 6;

const int FF_CMP_ZERO = 7;

const int FF_CMP_VSAD = 8;

const int FF_CMP_VSSE = 9;

const int FF_CMP_NSSE = 10;

const int FF_CMP_W53 = 11;

const int FF_CMP_W97 = 12;

const int FF_CMP_DCTMAX = 13;

const int FF_CMP_DCT264 = 14;

const int FF_CMP_MEDIAN_SAD = 15;

const int FF_CMP_CHROMA = 256;

const int FF_MB_DECISION_SIMPLE = 0;

const int FF_MB_DECISION_BITS = 1;

const int FF_MB_DECISION_RD = 2;

const int FF_COMPRESSION_DEFAULT = -1;

const int FF_BUG_AUTODETECT = 1;

const int FF_BUG_XVID_ILACE = 4;

const int FF_BUG_UMP4 = 8;

const int FF_BUG_NO_PADDING = 16;

const int FF_BUG_AMV = 32;

const int FF_BUG_QPEL_CHROMA = 64;

const int FF_BUG_STD_QPEL = 128;

const int FF_BUG_QPEL_CHROMA2 = 256;

const int FF_BUG_DIRECT_BLOCKSIZE = 512;

const int FF_BUG_EDGE = 1024;

const int FF_BUG_HPEL_CHROMA = 2048;

const int FF_BUG_DC_CLIP = 4096;

const int FF_BUG_MS = 8192;

const int FF_BUG_TRUNCATED = 16384;

const int FF_BUG_IEDGE = 32768;

const int FF_EC_GUESS_MVS = 1;

const int FF_EC_DEBLOCK = 2;

const int FF_EC_FAVOR_INTER = 256;

const int FF_DEBUG_PICT_INFO = 1;

const int FF_DEBUG_RC = 2;

const int FF_DEBUG_BITSTREAM = 4;

const int FF_DEBUG_MB_TYPE = 8;

const int FF_DEBUG_QP = 16;

const int FF_DEBUG_DCT_COEFF = 64;

const int FF_DEBUG_SKIP = 128;

const int FF_DEBUG_STARTCODE = 256;

const int FF_DEBUG_ER = 1024;

const int FF_DEBUG_MMCO = 2048;

const int FF_DEBUG_BUGS = 4096;

const int FF_DEBUG_BUFFERS = 32768;

const int FF_DEBUG_THREADS = 65536;

const int FF_DEBUG_GREEN_MD = 8388608;

const int FF_DEBUG_NOMC = 16777216;

const int FF_DCT_AUTO = 0;

const int FF_DCT_FASTINT = 1;

const int FF_DCT_INT = 2;

const int FF_DCT_MMX = 3;

const int FF_DCT_ALTIVEC = 5;

const int FF_DCT_FAAN = 6;

const int FF_DCT_NEON = 7;

const int FF_IDCT_AUTO = 0;

const int FF_IDCT_INT = 1;

const int FF_IDCT_SIMPLE = 2;

const int FF_IDCT_SIMPLEMMX = 3;

const int FF_IDCT_ARM = 7;

const int FF_IDCT_ALTIVEC = 8;

const int FF_IDCT_SIMPLEARM = 10;

const int FF_IDCT_XVID = 14;

const int FF_IDCT_SIMPLEARMV5TE = 16;

const int FF_IDCT_SIMPLEARMV6 = 17;

const int FF_IDCT_FAAN = 20;

const int FF_IDCT_SIMPLENEON = 22;

const int FF_IDCT_SIMPLEAUTO = 128;

const int FF_THREAD_FRAME = 1;

const int FF_THREAD_SLICE = 2;

const int FF_PROFILE_UNKNOWN = -99;

const int FF_PROFILE_RESERVED = -100;

const int FF_PROFILE_AAC_MAIN = 0;

const int FF_PROFILE_AAC_LOW = 1;

const int FF_PROFILE_AAC_SSR = 2;

const int FF_PROFILE_AAC_LTP = 3;

const int FF_PROFILE_AAC_HE = 4;

const int FF_PROFILE_AAC_HE_V2 = 28;

const int FF_PROFILE_AAC_LD = 22;

const int FF_PROFILE_AAC_ELD = 38;

const int FF_PROFILE_MPEG2_AAC_LOW = 128;

const int FF_PROFILE_MPEG2_AAC_HE = 131;

const int FF_PROFILE_DNXHD = 0;

const int FF_PROFILE_DNXHR_LB = 1;

const int FF_PROFILE_DNXHR_SQ = 2;

const int FF_PROFILE_DNXHR_HQ = 3;

const int FF_PROFILE_DNXHR_HQX = 4;

const int FF_PROFILE_DNXHR_444 = 5;

const int FF_PROFILE_DTS = 20;

const int FF_PROFILE_DTS_ES = 30;

const int FF_PROFILE_DTS_96_24 = 40;

const int FF_PROFILE_DTS_HD_HRA = 50;

const int FF_PROFILE_DTS_HD_MA = 60;

const int FF_PROFILE_DTS_EXPRESS = 70;

const int FF_PROFILE_DTS_HD_MA_X = 61;

const int FF_PROFILE_DTS_HD_MA_X_IMAX = 62;

const int FF_PROFILE_EAC3_DDP_ATMOS = 30;

const int FF_PROFILE_TRUEHD_ATMOS = 30;

const int FF_PROFILE_MPEG2_422 = 0;

const int FF_PROFILE_MPEG2_HIGH = 1;

const int FF_PROFILE_MPEG2_SS = 2;

const int FF_PROFILE_MPEG2_SNR_SCALABLE = 3;

const int FF_PROFILE_MPEG2_MAIN = 4;

const int FF_PROFILE_MPEG2_SIMPLE = 5;

const int FF_PROFILE_H264_CONSTRAINED = 512;

const int FF_PROFILE_H264_INTRA = 2048;

const int FF_PROFILE_H264_BASELINE = 66;

const int FF_PROFILE_H264_CONSTRAINED_BASELINE = 578;

const int FF_PROFILE_H264_MAIN = 77;

const int FF_PROFILE_H264_EXTENDED = 88;

const int FF_PROFILE_H264_HIGH = 100;

const int FF_PROFILE_H264_HIGH_10 = 110;

const int FF_PROFILE_H264_HIGH_10_INTRA = 2158;

const int FF_PROFILE_H264_MULTIVIEW_HIGH = 118;

const int FF_PROFILE_H264_HIGH_422 = 122;

const int FF_PROFILE_H264_HIGH_422_INTRA = 2170;

const int FF_PROFILE_H264_STEREO_HIGH = 128;

const int FF_PROFILE_H264_HIGH_444 = 144;

const int FF_PROFILE_H264_HIGH_444_PREDICTIVE = 244;

const int FF_PROFILE_H264_HIGH_444_INTRA = 2292;

const int FF_PROFILE_H264_CAVLC_444 = 44;

const int FF_PROFILE_VC1_SIMPLE = 0;

const int FF_PROFILE_VC1_MAIN = 1;

const int FF_PROFILE_VC1_COMPLEX = 2;

const int FF_PROFILE_VC1_ADVANCED = 3;

const int FF_PROFILE_MPEG4_SIMPLE = 0;

const int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = 1;

const int FF_PROFILE_MPEG4_CORE = 2;

const int FF_PROFILE_MPEG4_MAIN = 3;

const int FF_PROFILE_MPEG4_N_BIT = 4;

const int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = 5;

const int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6;

const int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7;

const int FF_PROFILE_MPEG4_HYBRID = 8;

const int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9;

const int FF_PROFILE_MPEG4_CORE_SCALABLE = 10;

const int FF_PROFILE_MPEG4_ADVANCED_CODING = 11;

const int FF_PROFILE_MPEG4_ADVANCED_CORE = 12;

const int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;

const int FF_PROFILE_MPEG4_SIMPLE_STUDIO = 14;

const int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = 15;

const int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 1;

const int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 2;

const int FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768;

const int FF_PROFILE_JPEG2000_DCINEMA_2K = 3;

const int FF_PROFILE_JPEG2000_DCINEMA_4K = 4;

const int FF_PROFILE_VP9_0 = 0;

const int FF_PROFILE_VP9_1 = 1;

const int FF_PROFILE_VP9_2 = 2;

const int FF_PROFILE_VP9_3 = 3;

const int FF_PROFILE_HEVC_MAIN = 1;

const int FF_PROFILE_HEVC_MAIN_10 = 2;

const int FF_PROFILE_HEVC_MAIN_STILL_PICTURE = 3;

const int FF_PROFILE_HEVC_REXT = 4;

const int FF_PROFILE_HEVC_SCC = 9;

const int FF_PROFILE_VVC_MAIN_10 = 1;

const int FF_PROFILE_VVC_MAIN_10_444 = 33;

const int FF_PROFILE_AV1_MAIN = 0;

const int FF_PROFILE_AV1_HIGH = 1;

const int FF_PROFILE_AV1_PROFESSIONAL = 2;

const int FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = 192;

const int FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 193;

const int FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = 194;

const int FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS = 195;

const int FF_PROFILE_MJPEG_JPEG_LS = 247;

const int FF_PROFILE_SBC_MSBC = 1;

const int FF_PROFILE_PRORES_PROXY = 0;

const int FF_PROFILE_PRORES_LT = 1;

const int FF_PROFILE_PRORES_STANDARD = 2;

const int FF_PROFILE_PRORES_HQ = 3;

const int FF_PROFILE_PRORES_4444 = 4;

const int FF_PROFILE_PRORES_XQ = 5;

const int FF_PROFILE_ARIB_PROFILE_A = 0;

const int FF_PROFILE_ARIB_PROFILE_C = 1;

const int FF_PROFILE_KLVA_SYNC = 0;

const int FF_PROFILE_KLVA_ASYNC = 1;

const int FF_PROFILE_EVC_BASELINE = 0;

const int FF_PROFILE_EVC_MAIN = 1;

const int FF_LEVEL_UNKNOWN = -99;

const int FF_CODEC_PROPERTY_LOSSLESS = 1;

const int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = 2;

const int FF_CODEC_PROPERTY_FILM_GRAIN = 4;

const int FF_SUB_CHARENC_MODE_DO_NOTHING = -1;

const int FF_SUB_CHARENC_MODE_AUTOMATIC = 0;

const int FF_SUB_CHARENC_MODE_PRE_DECODER = 1;

const int FF_SUB_CHARENC_MODE_IGNORE = 2;

const int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = 512;

const int AV_HWACCEL_FLAG_IGNORE_LEVEL = 1;

const int AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = 2;

const int AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = 4;

const int AV_HWACCEL_FLAG_UNSAFE_OUTPUT = 8;

const int AV_SUBTITLE_FLAG_FORCED = 1;

const int AV_PARSER_PTS_NB = 4;

const int PARSER_FLAG_COMPLETE_FRAMES = 1;

const int PARSER_FLAG_ONCE = 2;

const int PARSER_FLAG_FETCHED_OFFSET = 4;

const int PARSER_FLAG_USE_CODEC_TS = 4096;

const int MAX_DWT_LEVELS = 5;

const int AV_OPT_FLAG_ENCODING_PARAM = 1;

const int AV_OPT_FLAG_DECODING_PARAM = 2;

const int AV_OPT_FLAG_AUDIO_PARAM = 8;

const int AV_OPT_FLAG_VIDEO_PARAM = 16;

const int AV_OPT_FLAG_SUBTITLE_PARAM = 32;

const int AV_OPT_FLAG_EXPORT = 64;

const int AV_OPT_FLAG_READONLY = 128;

const int AV_OPT_FLAG_BSF_PARAM = 256;

const int AV_OPT_FLAG_RUNTIME_PARAM = 32768;

const int AV_OPT_FLAG_FILTERING_PARAM = 65536;

const int AV_OPT_FLAG_DEPRECATED = 131072;

const int AV_OPT_FLAG_CHILD_CONSTS = 262144;

const int AV_OPT_SEARCH_CHILDREN = 1;

const int AV_OPT_SEARCH_FAKE_OBJ = 2;

const int AV_OPT_ALLOW_NULL = 4;

const int AV_OPT_ARRAY_REPLACE = 8;

const int AV_OPT_MULTI_COMPONENT_RANGE = 4096;

const int AV_OPT_SERIALIZE_SKIP_DEFAULTS = 1;

const int AV_OPT_SERIALIZE_OPT_FLAGS_EXACT = 2;

const int AV_OPT_SERIALIZE_SEARCH_CHILDREN = 4;

const int VORBIS_FLAG_HEADER = 1;

const int VORBIS_FLAG_COMMENT = 2;

const int VORBIS_FLAG_SETUP = 4;

const int DV_PROFILE_BYTES = 480;

const int LIBAVDEVICE_VERSION_MAJOR = 61;

const int FF_API_BKTR_DEVICE = 1;

const int FF_API_OPENGL_DEVICE = 1;

const int FF_API_SDL2_DEVICE = 1;

const int LIBAVDEVICE_VERSION_MINOR = 3;

const int LIBAVDEVICE_VERSION_MICRO = 100;

const int LIBAVDEVICE_VERSION_INT = 3998564;

const int LIBAVDEVICE_BUILD = 3998564;

const String LIBAVDEVICE_IDENT = 'Lavd61.3.100';

const int LIBAVFORMAT_VERSION_MAJOR = 61;

const int FF_API_COMPUTE_PKT_FIELDS2 = 1;

const int FF_API_LAVF_SHORTEST = 1;

const int FF_API_ALLOW_FLUSH = 1;

const int FF_API_AVSTREAM_SIDE_DATA = 1;

const int FF_API_GET_DUR_ESTIMATE_METHOD = 1;

const int FF_API_INTERNAL_TIMING = 1;

const int FF_API_R_FRAME_RATE = 1;

const int AVIO_SEEKABLE_NORMAL = 1;

const int AVIO_SEEKABLE_TIME = 2;

const int AVSEEK_SIZE = 65536;

const int AVSEEK_FORCE = 131072;

const int AVIO_FLAG_READ = 1;

const int AVIO_FLAG_WRITE = 2;

const int AVIO_FLAG_READ_WRITE = 3;

const int AVIO_FLAG_NONBLOCK = 8;

const int AVIO_FLAG_DIRECT = 32768;

const int LIBAVFORMAT_VERSION_MINOR = 7;

const int LIBAVFORMAT_VERSION_MICRO = 100;

const int LIBAVFORMAT_VERSION_INT = 3999588;

const int LIBAVFORMAT_BUILD = 3999588;

const String LIBAVFORMAT_IDENT = 'Lavf61.7.100';

const int AVPROBE_SCORE_RETRY = 25;

const int AVPROBE_SCORE_STREAM_RETRY = 24;

const int AVPROBE_SCORE_EXTENSION = 50;

const int AVPROBE_SCORE_MIME = 75;

const int AVPROBE_SCORE_MAX = 100;

const int AVPROBE_PADDING_SIZE = 32;

const int AVFMT_NOFILE = 1;

const int AVFMT_NEEDNUMBER = 2;

const int AVFMT_EXPERIMENTAL = 4;

const int AVFMT_SHOW_IDS = 8;

const int AVFMT_GLOBALHEADER = 64;

const int AVFMT_NOTIMESTAMPS = 128;

const int AVFMT_GENERIC_INDEX = 256;

const int AVFMT_TS_DISCONT = 512;

const int AVFMT_VARIABLE_FPS = 1024;

const int AVFMT_NODIMENSIONS = 2048;

const int AVFMT_NOSTREAMS = 4096;

const int AVFMT_NOBINSEARCH = 8192;

const int AVFMT_NOGENSEARCH = 16384;

const int AVFMT_NO_BYTE_SEEK = 32768;

const int AVFMT_ALLOW_FLUSH = 65536;

const int AVFMT_TS_NONSTRICT = 131072;

const int AVFMT_TS_NEGATIVE = 262144;

const int AVFMT_SEEK_TO_PTS = 67108864;

const int AVINDEX_KEYFRAME = 1;

const int AVINDEX_DISCARD_FRAME = 2;

const int AV_DISPOSITION_DEFAULT = 1;

const int AV_DISPOSITION_DUB = 2;

const int AV_DISPOSITION_ORIGINAL = 4;

const int AV_DISPOSITION_COMMENT = 8;

const int AV_DISPOSITION_LYRICS = 16;

const int AV_DISPOSITION_KARAOKE = 32;

const int AV_DISPOSITION_FORCED = 64;

const int AV_DISPOSITION_HEARING_IMPAIRED = 128;

const int AV_DISPOSITION_VISUAL_IMPAIRED = 256;

const int AV_DISPOSITION_CLEAN_EFFECTS = 512;

const int AV_DISPOSITION_ATTACHED_PIC = 1024;

const int AV_DISPOSITION_TIMED_THUMBNAILS = 2048;

const int AV_DISPOSITION_NON_DIEGETIC = 4096;

const int AV_DISPOSITION_CAPTIONS = 65536;

const int AV_DISPOSITION_DESCRIPTIONS = 131072;

const int AV_DISPOSITION_METADATA = 262144;

const int AV_DISPOSITION_DEPENDENT = 524288;

const int AV_DISPOSITION_STILL_IMAGE = 1048576;

const int AV_DISPOSITION_MULTILAYER = 2097152;

const int AV_PTS_WRAP_IGNORE = 0;

const int AV_PTS_WRAP_ADD_OFFSET = 1;

const int AV_PTS_WRAP_SUB_OFFSET = -1;

const int AVSTREAM_EVENT_FLAG_METADATA_UPDATED = 1;

const int AVSTREAM_EVENT_FLAG_NEW_PACKETS = 2;

const int AV_PROGRAM_RUNNING = 1;

const int AVFMTCTX_NOHEADER = 1;

const int AVFMTCTX_UNSEEKABLE = 2;

const int AVFMT_FLAG_GENPTS = 1;

const int AVFMT_FLAG_IGNIDX = 2;

const int AVFMT_FLAG_NONBLOCK = 4;

const int AVFMT_FLAG_IGNDTS = 8;

const int AVFMT_FLAG_NOFILLIN = 16;

const int AVFMT_FLAG_NOPARSE = 32;

const int AVFMT_FLAG_NOBUFFER = 64;

const int AVFMT_FLAG_CUSTOM_IO = 128;

const int AVFMT_FLAG_DISCARD_CORRUPT = 256;

const int AVFMT_FLAG_FLUSH_PACKETS = 512;

const int AVFMT_FLAG_BITEXACT = 1024;

const int AVFMT_FLAG_SORT_DTS = 65536;

const int AVFMT_FLAG_FAST_SEEK = 524288;

const int AVFMT_FLAG_SHORTEST = 1048576;

const int AVFMT_FLAG_AUTO_BSF = 2097152;

const int FF_FDEBUG_TS = 1;

const int AVFMT_EVENT_FLAG_METADATA_UPDATED = 1;

const int AVFMT_AVOID_NEG_TS_AUTO = -1;

const int AVFMT_AVOID_NEG_TS_DISABLED = 0;

const int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = 1;

const int AVFMT_AVOID_NEG_TS_MAKE_ZERO = 2;

const int AVSEEK_FLAG_BACKWARD = 1;

const int AVSEEK_FLAG_BYTE = 2;

const int AVSEEK_FLAG_ANY = 4;

const int AVSEEK_FLAG_FRAME = 8;

const int AVSTREAM_INIT_IN_WRITE_HEADER = 0;

const int AVSTREAM_INIT_IN_INIT_OUTPUT = 1;

const int AV_FRAME_FILENAME_FLAGS_MULTIPLE = 1;

const int LIBAVFILTER_VERSION_MAJOR = 10;

const int FF_API_LINK_PUBLIC = 1;

const int LIBAVFILTER_VERSION_MINOR = 4;

const int LIBAVFILTER_VERSION_MICRO = 100;

const int LIBAVFILTER_VERSION_INT = 656484;

const int LIBAVFILTER_BUILD = 656484;

const String LIBAVFILTER_IDENT = 'Lavfi10.4.100';

const int AVFILTER_FLAG_DYNAMIC_INPUTS = 1;

const int AVFILTER_FLAG_DYNAMIC_OUTPUTS = 2;

const int AVFILTER_FLAG_SLICE_THREADS = 4;

const int AVFILTER_FLAG_METADATA_ONLY = 8;

const int AVFILTER_FLAG_HWDEVICE = 16;

const int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = 65536;

const int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = 131072;

const int AVFILTER_FLAG_SUPPORT_TIMELINE = 196608;

const int AVFILTER_THREAD_SLICE = 1;

const int AVFILTER_CMD_FLAG_ONE = 1;

const int AVFILTER_CMD_FLAG_FAST = 2;

const int AV_BUFFERSINK_FLAG_PEEK = 1;

const int AV_BUFFERSINK_FLAG_NO_REQUEST = 2;

const int AV_IAMF_LAYER_FLAG_RECON_GAIN = 1;

const int AV_DETECTION_BBOX_LABEL_NAME_MAX_SIZE = 64;

const int AV_NUM_DETECTION_BBOX_CLASSIFY = 4;

const int AV_FIFO_FLAG_AUTO_GROW = 1;

const int AV_BF_ROUNDS = 16;

const int AV_STEREO3D_FLAG_INVERT = 1;

const int AV_PIX_FMT_FLAG_BE = 1;

const int AV_PIX_FMT_FLAG_PAL = 2;

const int AV_PIX_FMT_FLAG_BITSTREAM = 4;

const int AV_PIX_FMT_FLAG_HWACCEL = 8;

const int AV_PIX_FMT_FLAG_PLANAR = 16;

const int AV_PIX_FMT_FLAG_RGB = 32;

const int AV_PIX_FMT_FLAG_ALPHA = 128;

const int AV_PIX_FMT_FLAG_BAYER = 256;

const int AV_PIX_FMT_FLAG_FLOAT = 512;

const int AV_PIX_FMT_FLAG_XYZ = 1024;

const int FF_LOSS_RESOLUTION = 1;

const int FF_LOSS_DEPTH = 2;

const int FF_LOSS_COLORSPACE = 4;

const int FF_LOSS_ALPHA = 8;

const int FF_LOSS_COLORQUANT = 16;

const int FF_LOSS_CHROMA = 32;

const int FF_LOSS_EXCESS_RESOLUTION = 64;

const int FF_LOSS_EXCESS_DEPTH = 128;

const String AV_PRI_UUID =
    '%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx';

const String AV_PRI_URN_UUID =
    'urn:uuid:%02hhx%02hhx%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx-%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx';

const int AV_UUID_LEN = 16;

const String FFMPEG_VERSION = '7.1';

const int AV_TIMECODE_STR_SIZE = 23;

const int AV_DOVI_MAX_PIECES = 8;

const int AV_DOVI_MAX_EXT_BLOCKS = 32;

const int AV_CPU_FLAG_FORCE = 2147483648;

const int AV_CPU_FLAG_MMX = 1;

const int AV_CPU_FLAG_MMXEXT = 2;

const int AV_CPU_FLAG_MMX2 = 2;

const int AV_CPU_FLAG_3DNOW = 4;

const int AV_CPU_FLAG_SSE = 8;

const int AV_CPU_FLAG_SSE2 = 16;

const int AV_CPU_FLAG_SSE2SLOW = 1073741824;

const int AV_CPU_FLAG_3DNOWEXT = 32;

const int AV_CPU_FLAG_SSE3 = 64;

const int AV_CPU_FLAG_SSE3SLOW = 536870912;

const int AV_CPU_FLAG_SSSE3 = 128;

const int AV_CPU_FLAG_SSSE3SLOW = 67108864;

const int AV_CPU_FLAG_ATOM = 268435456;

const int AV_CPU_FLAG_SSE4 = 256;

const int AV_CPU_FLAG_SSE42 = 512;

const int AV_CPU_FLAG_AESNI = 524288;

const int AV_CPU_FLAG_AVX = 16384;

const int AV_CPU_FLAG_AVXSLOW = 134217728;

const int AV_CPU_FLAG_XOP = 1024;

const int AV_CPU_FLAG_FMA4 = 2048;

const int AV_CPU_FLAG_CMOV = 4096;

const int AV_CPU_FLAG_AVX2 = 32768;

const int AV_CPU_FLAG_FMA3 = 65536;

const int AV_CPU_FLAG_BMI1 = 131072;

const int AV_CPU_FLAG_BMI2 = 262144;

const int AV_CPU_FLAG_AVX512 = 1048576;

const int AV_CPU_FLAG_AVX512ICL = 2097152;

const int AV_CPU_FLAG_SLOW_GATHER = 33554432;

const int AV_CPU_FLAG_ALTIVEC = 1;

const int AV_CPU_FLAG_VSX = 2;

const int AV_CPU_FLAG_POWER8 = 4;

const int AV_CPU_FLAG_ARMV5TE = 1;

const int AV_CPU_FLAG_ARMV6 = 2;

const int AV_CPU_FLAG_ARMV6T2 = 4;

const int AV_CPU_FLAG_VFP = 8;

const int AV_CPU_FLAG_VFPV3 = 16;

const int AV_CPU_FLAG_NEON = 32;

const int AV_CPU_FLAG_ARMV8 = 64;

const int AV_CPU_FLAG_VFP_VM = 128;

const int AV_CPU_FLAG_DOTPROD = 256;

const int AV_CPU_FLAG_I8MM = 512;

const int AV_CPU_FLAG_SETEND = 65536;

const int AV_CPU_FLAG_MMI = 1;

const int AV_CPU_FLAG_MSA = 2;

const int AV_CPU_FLAG_LSX = 1;

const int AV_CPU_FLAG_LASX = 2;

const int AV_CPU_FLAG_RVI = 1;

const int AV_CPU_FLAG_RVF = 2;

const int AV_CPU_FLAG_RVD = 4;

const int AV_CPU_FLAG_RVV_I32 = 8;

const int AV_CPU_FLAG_RVV_F32 = 16;

const int AV_CPU_FLAG_RVV_I64 = 32;

const int AV_CPU_FLAG_RVV_F64 = 64;

const int AV_CPU_FLAG_RVB_BASIC = 128;

const int AV_CPU_FLAG_RVB_ADDR = 256;

const int AV_CPU_FLAG_RV_ZVBB = 512;

const int AV_CPU_FLAG_RV_MISALIGNED = 1024;

const int AV_CPU_FLAG_RVB = 2048;

const int AV_LZO_INPUT_DEPLETED = 1;

const int AV_LZO_OUTPUT_FULL = 2;

const int AV_LZO_INVALID_BACKPTR = 4;

const int AV_LZO_ERROR = 8;

const int AV_LZO_INPUT_PADDING = 8;

const int AV_LZO_OUTPUT_PADDING = 12;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 6;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_MONOTONIC_RAW_APPROX = 5;

const int CLOCK_UPTIME_RAW = 8;

const int CLOCK_UPTIME_RAW_APPROX = 9;

const int CLOCK_PROCESS_CPUTIME_ID = 12;

const int CLOCK_THREAD_CPUTIME_ID = 16;

const int TIME_UTC = 1;

const int AV_ESCAPE_FLAG_WHITESPACE = 1;

const int AV_ESCAPE_FLAG_STRICT = 2;

const int AV_ESCAPE_FLAG_XML_SINGLE_QUOTES = 4;

const int AV_ESCAPE_FLAG_XML_DOUBLE_QUOTES = 8;

const int AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES = 1;

const int AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS = 2;

const int AV_UTF8_FLAG_ACCEPT_SURROGATES = 4;

const int AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES = 8;

const int AV_UTF8_FLAG_ACCEPT_ALL = 7;

const int AV_BPRINT_SIZE_UNLIMITED = 4294967295;

const int AV_BPRINT_SIZE_AUTOMATIC = 1;

const int AV_BPRINT_SIZE_COUNT_ONLY = 0;

const int AV_HDR_PLUS_MAX_PAYLOAD_SIZE = 907;

const int AES_CTR_KEY_SIZE = 16;

const int AES_CTR_IV_SIZE = 8;

const int AV_TS_MAX_STRING_SIZE = 32;

const int AV_HASH_MAX_SIZE = 64;

const int LIBPOSTPROC_VERSION_MAJOR = 58;

const int LIBPOSTPROC_VERSION_MINOR = 3;

const int LIBPOSTPROC_VERSION_MICRO = 100;

const int LIBPOSTPROC_VERSION_INT = 3801956;

const int LIBPOSTPROC_BUILD = 3801956;

const String LIBPOSTPROC_IDENT = 'postproc58.3.100';

const int PP_QUALITY_MAX = 6;

const int PP_CPU_CAPS_MMX = 2147483648;

const int PP_CPU_CAPS_MMX2 = 536870912;

const int PP_CPU_CAPS_3DNOW = 1073741824;

const int PP_CPU_CAPS_ALTIVEC = 268435456;

const int PP_CPU_CAPS_AUTO = 524288;

const int PP_FORMAT = 8;

const int PP_FORMAT_420 = 25;

const int PP_FORMAT_422 = 9;

const int PP_FORMAT_411 = 10;

const int PP_FORMAT_444 = 8;

const int PP_FORMAT_440 = 24;

const int PP_PICT_TYPE_QP2 = 16;

const int LIBSWRESAMPLE_VERSION_MAJOR = 5;

const int LIBSWRESAMPLE_VERSION_MINOR = 3;

const int LIBSWRESAMPLE_VERSION_MICRO = 100;

const int LIBSWRESAMPLE_VERSION_INT = 328548;

const int LIBSWRESAMPLE_BUILD = 328548;

const String LIBSWRESAMPLE_IDENT = 'SwR5.3.100';

const int SWR_FLAG_RESAMPLE = 1;

const int LIBSWSCALE_VERSION_MAJOR = 8;

const int LIBSWSCALE_VERSION_MINOR = 3;

const int LIBSWSCALE_VERSION_MICRO = 100;

const int LIBSWSCALE_VERSION_INT = 525156;

const int LIBSWSCALE_BUILD = 525156;

const String LIBSWSCALE_IDENT = 'SwS8.3.100';

const int SWS_FAST_BILINEAR = 1;

const int SWS_BILINEAR = 2;

const int SWS_BICUBIC = 4;

const int SWS_X = 8;

const int SWS_POINT = 16;

const int SWS_AREA = 32;

const int SWS_BICUBLIN = 64;

const int SWS_GAUSS = 128;

const int SWS_SINC = 256;

const int SWS_LANCZOS = 512;

const int SWS_SPLINE = 1024;

const int SWS_SRC_V_CHR_DROP_MASK = 196608;

const int SWS_SRC_V_CHR_DROP_SHIFT = 16;

const int SWS_PARAM_DEFAULT = 123456;

const int SWS_PRINT_INFO = 4096;

const int SWS_FULL_CHR_H_INT = 8192;

const int SWS_FULL_CHR_H_INP = 16384;

const int SWS_DIRECT_BGR = 32768;

const int SWS_ACCURATE_RND = 262144;

const int SWS_BITEXACT = 524288;

const int SWS_ERROR_DIFFUSION = 8388608;

const double SWS_MAX_REDUCE_CUTOFF = 0.002;

const int SWS_CS_ITU709 = 1;

const int SWS_CS_FCC = 4;

const int SWS_CS_ITU601 = 5;

const int SWS_CS_ITU624 = 5;

const int SWS_CS_SMPTE170M = 5;

const int SWS_CS_SMPTE240M = 7;

const int SWS_CS_DEFAULT = 5;

const int SWS_CS_BT2020 = 9;
